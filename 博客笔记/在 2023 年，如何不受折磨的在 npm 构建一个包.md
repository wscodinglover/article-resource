构建一个 npm 包需要考虑很多决策。从选择默认的打包工具到选择适当的编译器，再到理解工具或包的使用场景，或者更准确地说，是你正在创建的库。

在这个过程中需要考虑的问题比实际编写代码的过程还要多。是的，有时候，这个所谓的“深度思考”甚至可能是不必要的。但是，重要的是你要有这个意识。

## Webpack，老古董

多年前，构建这些包的一种方法完全依赖于使用 webpack<sup data-darkreader-inline-color="">[1]</sup> 作为首选打包工具，它还附带了许多插件，可以用来打包 JavaScript 代码。

但是，Webpack 有很多复杂性。每次我尝试使用它时，我总是对配置文件中出现的许多事物感到沮丧，我甚至写了一篇关于我的困扰的文章。

> **注意：**我在这里的目的不是抱怨 webpack，而是提供一种更温和的方法来构建这些包并将它们发布出去。

很多人可能对我在这里的观点有异议，并引用那句著名的话 **“Webpack 用于构建应用程序，其他工具用于构建库”**。

但是，我认为很多人在这里忽视的是“其他”打包工具相对于 webpack 在开发者体验（Developer Experience）方面所具有的优势。

是的，webpack 给你提供了很多功能。好吧，很不错。但是以我发疯为代价吗？

正如我之前提到的，本文的目的与我所犯的错误及如何规避这些错误有关。

最近几天，我一直在开发一个 React Tab 组件<sup data-darkreader-inline-color="">[2]</sup>，它在每次点击标签（或导航项）时以及从其他地方返回到该组件所在位置时保留每个标签的状态。

在开发过程中，我证实了我一直以来思考的一个问题。"我们可以将组件状态保持在浏览器 URL 中吗？"

你可以尝试使用这个包，并告诉我你的想法。

我写了一篇关于为什么 你可能不需要状态管理库<sup data-darkreader-inline-color="">[3]</sup> 的简短文章，因为它证明了这个组件的概念验证。在你有空的时候可以看一下。

现在，让我们来谈谈 npm 包的问题。

根据我过去的经验，我认为当你决定构建一个与组件库或依赖某种带有 CSS 样式的包完全不相似的 npm 包时，你应该使用 TypeScript 编译器（`tsc`）作为打包工具。

我之前开发的一个示例是这个辅助函数<sup data-darkreader-inline-color="">[4]</sup>，它可以从任何 Markdown 文件中提取标题文本。你可以在这里<sup data-darkreader-inline-color="">[5]</sup>查看编译器的配置。

让我简要介绍一下这个配置的要点。这个配置与仓库中的配置相同。

```
{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">"include"</span>:&nbsp;[<span data-darkreader-inline-color="">"src"</span>],<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">"exclude"</span>:&nbsp;[<span data-darkreader-inline-color="">"node_modules"</span>,&nbsp;<span data-darkreader-inline-color="">"dist"</span>],<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">"compilerOptions"</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"lib"</span>:&nbsp;[<span data-darkreader-inline-color="">"ESNext"</span>],<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"module"</span>:&nbsp;<span data-darkreader-inline-color="">"ESNext"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"sourceMap"</span>:&nbsp;<span data-darkreader-inline-color="">true</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"importHelpers"</span>:&nbsp;<span data-darkreader-inline-color="">true</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"declaration"</span>:&nbsp;<span data-darkreader-inline-color="">true</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"rootDir"</span>:&nbsp;<span data-darkreader-inline-color="">"./src"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"outDir"</span>:&nbsp;<span data-darkreader-inline-color="">"./dist/esm"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"strict"</span>:&nbsp;<span data-darkreader-inline-color="">true</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"noImplicitReturns"</span>:&nbsp;<span data-darkreader-inline-color="">true</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"noUnusedLocals"</span>:&nbsp;<span data-darkreader-inline-color="">true</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"noUnusedParameters"</span>:&nbsp;<span data-darkreader-inline-color="">true</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"moduleResolution"</span>:&nbsp;<span data-darkreader-inline-color="">"node"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"jsx"</span>:&nbsp;<span data-darkreader-inline-color="">"react"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"esModuleInterop"</span>:&nbsp;<span data-darkreader-inline-color="">true</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"skipLibCheck"</span>:&nbsp;<span data-darkreader-inline-color="">true</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"forceConsistentCasingInFileNames"</span>:&nbsp;<span data-darkreader-inline-color="">true</span><br>&nbsp;&nbsp;}<br>}<br>
```

-   `include`指定在编译 TypeScript 代码时应包含的文件或目录。在这种情况下，对于该辅助函数，它包括`src`目录。你的情况可能会有所不同。
    
-   `exclude`指定在编译过程中应排除的文件或目录。这里，它排除了`node_modules`和`dist`目录。
    
-   在`compilerOptions`部分，有一个`lib`属性，它确保在编译过程中应包含特定的库。这里，它包含了"ESNext"库，该库提供了最新的 ECMAScript 功能。
    
-   `module`属性确定要使用的模块系统。在这种情况下，它设置为"ESNext"，以启用使用现代 JavaScript 模块。
    
-   `sourceMap`启用源映射生成，这对于在浏览器或开发工具中调试 TypeScript 代码非常有用。
    
-   `importHelpers`启用导入 TypeScript 帮助函数，以辅助处理某些功能，如装饰器和 async/await。
    
-   `declaration`在编译的 JavaScript 文件旁生成相应的`.d.ts`声明文件，允许在消费该代码的其他 TypeScript 项目中进行类型检查和代码完成。
    
-   `rootDir`指定 TypeScript 源文件的根目录。在这里，它设置为`src`目录。你的情况可能完全不同。在我最近的包中，我将其设置为`packages`，因为该库对于不同组件的许多用例都是适用的。
    
-   `outDir`决定了编译后的 JavaScript 文件的输出目录。在这种情况下，它设置为`dist/esm`目录。
    
-   `strict`启用严格的类型检查和更严格的编译器选项。
    
-   `noImplicitReturns`在函数缺少返回语句时报告错误。
    
-   `noUnusedLocals`在声明了但未使用的局部变量时报告错误。
    
-   `noUnusedParameters`在声明了但未使用的函数参数时报告错误。
    
-   `moduleResolution`指定了 TypeScript 解析模块导入的方式。在这里，它设置为"node"，使用 Node.js 的模块解析。这部分有时可能会非常令人沮丧。
    
-   `jsx`确定用于 JSX 的语法。在这种情况下，它设置为"react"以支持 React JSX 语法。
    
-   `esModuleInterop`启用 CommonJS 和 ES 模块之间的互操作性，允许更轻松地在 TypeScript 中导入 CommonJS 模块。
    
-   `skipLibCheck`跳过对依赖项中的声明文件（\*.d.ts）进行类型检查，这可以提高编译速度。
    
-   `forceConsistentCasingInFileNames`强制文件名的大小写一致，这有助于在不同操作系统上进行工作时避免出现问题。
    

如果不想严格使用此配置，您可以自由地设置适合自己的配置。

## 接入 Rollup.js

Rollup 是用于 JavaScript 应用程序的打包工具，如果您想构建组件库或任何 npm 包，它是迄今为止最推荐的工具，因为与 webpack 相比，它具有直观和简单的开发过程。

好处是，当您想构建一个 npm 包，尤其是依赖于样式的包时，您可以同时使用 TypeScript 和 Rollup。

您只需要找到合适的插件。当我开始构建react-tab<sup data-darkreader-inline-color="">[6]</sup>包时，我首先使用了 TypeScript 的编译器`tsc`作为我的打包工具。

但是，它带来了很多限制，因为它无法正确提取和处理 CSS 输出。由于 Rollup 有一个我可以使用的插件生态系统，进行研究并找到合适的插件并不太费力。

还记得我之前谈到的创建理想包时所需的"思考"吗？

如果您要构建的 npm 包在某种程度上依赖于使用 CSS，您可能要考虑选择一种适合您的方法。

有些人喜欢使用 CSS 模块，有些人喜欢使用 scss 或 Sass，还有些人喜欢使用纯 CSS。我在`react-tab`中使用了 styled-components。

"为什么你要这样做呢？styled-components 有很多限制。"

稍后我会解释。我这里的重点是涉及到一些小的边缘情况。例如，如果你决定在一个主要面向 Next.js 项目的包中使用 CSS 模块，你将遇到一些问题。

对我来说，选择使用 styled-components 是明智的，因为 Tab 组件旨在为开发人员提供直观且完全可自定义的体验。我需要暴露一些特定的样式属性。

而且，使用 styled-components 可以扩展组件的 props 是一种常见的方式。

```
<span data-darkreader-inline-color="">//&nbsp;component.styled.ts</span><br><span data-darkreader-inline-color="">import</span>&nbsp;styled&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">"styled-components"</span>;<br><br><span data-darkreader-inline-color="">type</span>&nbsp;themeProps&nbsp;=&nbsp;{<br>&nbsp;&nbsp;theme:&nbsp;<span data-darkreader-inline-color="">string</span>;<br>};<br><br><span data-darkreader-inline-color="">export</span>&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;Container&nbsp;=&nbsp;styled.div&lt;themeProps&gt;<span data-darkreader-inline-color="">`<br>&nbsp;&nbsp;background:&nbsp;<span data-darkreader-inline-color="">${({&nbsp;theme&nbsp;}</span>)&nbsp;=&gt;&nbsp;(theme&nbsp;?&nbsp;theme&nbsp;:&nbsp;"brown")};<br>`</span>;<br>
```

然后 `Container` 变成了下面类似的代码片段。这只是使用这个 CSS 组件库能实现的冰山一角。

```
&lt;Container&nbsp;theme=<span data-darkreader-inline-color="">"purple"</span>&gt;<span data-darkreader-inline-color="">//&nbsp;children&lt;/Container&gt;</span><br>
```

但是，限制仍然存在。因为正如我之前提到的，TypeScript 的编译器无法正确处理将打包到组件上的样式的输出，Rollup 就应运而生了。

## 真相之源 —— rollup.config.js

大多数打包工具通常会有一个配置文件，该文件在某种程度上控制着应用程序在后台如何进行分块、压缩、编译以及其他操作。

下面是一个示例配置文件。它导出了应用程序的入口点（`input`）和输出目录。

```
<span data-darkreader-inline-color="">export</span>&nbsp;<span data-darkreader-inline-color="">default</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">input</span>:&nbsp;<span data-darkreader-inline-color="">"packages/index.ts"</span>,<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">output</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">file</span>:&nbsp;<span data-darkreader-inline-color="">"dist/index.js"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">format</span>:&nbsp;<span data-darkreader-inline-color="">"cjs"</span>,<br>&nbsp;&nbsp;},<br>};<br>
```

由于 `react-tab` 使用了外部依赖项 `next/router`，当我尝试使用 `rollup -c` 命令构建该包时，会记录一个 "未解析的依赖项" 警告。

Rollup 根据导入路径的不同方式处理依赖项。当遇到以 `.` 或 `/` 开头的导入时，它会将其视为本地文件并相应地解析。

然而，当导入以模块名称开头，比如 `next/router`，它会将其视为由使用该包的人来解析的外部依赖项。

为了绕过此警告，我必须在 rollup 配置中指定 `next/router` 是一个外部依赖项。

一旦你确定了你的应用程序/库依赖的外部包，你也可以采用相同的方法。

```
<span data-darkreader-inline-color="">export</span>&nbsp;<span data-darkreader-inline-color="">default</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">input</span>:&nbsp;<span data-darkreader-inline-color="">"packages/index.ts"</span>,<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">output</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">file</span>:&nbsp;<span data-darkreader-inline-color="">"dist/index.js"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">format</span>:&nbsp;<span data-darkreader-inline-color="">"cjs"</span>,<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">external</span>:&nbsp;[<span data-darkreader-inline-color="">"react"</span>,&nbsp;<span data-darkreader-inline-color="">"react-dom"</span>,&nbsp;<span data-darkreader-inline-color="">"next/router"</span>],<br>};<br>
```

在之前我提到了与 styled-components 相关的限制。下面是其中的问题。

当在共享组件或库中使用 styled-components 时，你应该牢记三个要点，以确保在其他项目中使用该包时正确应用样式。

将其列为 peerDependencies：我必须确保在我的 package.json 文件中将 styled-components 列为 peerDependencies。

这告知使用者在自己的项目中需要安装 styled-components 来正确使用你的组件。

如果你的 package.json 文件中没有这样的设置，你可以通过使用 generatePackageJSON 插件修改 peerDependencies 属性来实现，如下所示：

```
generatePackageJSON({<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">outputFolder</span>:&nbsp;<span data-darkreader-inline-color="">"dist"</span>,<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">baseContents</span>:&nbsp;<span>(<span data-darkreader-inline-color="">pkg</span>)&nbsp;=&gt;</span>&nbsp;({<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">name</span>:&nbsp;pkg.name,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">main</span>:&nbsp;<span data-darkreader-inline-color="">"/dist/index.js"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">peerDependencies</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">react</span>:&nbsp;<span data-darkreader-inline-color="">"^18.2.0"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"styled-components"</span>:&nbsp;<span data-darkreader-inline-color="">"^6.0.0-rc.3"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;}),<br>});<br>
```

CSS 提取：默认情况下，styled-components 会在运行时将样式注入到 DOM 中。

然而，当构建共享组件库或包时，最好在构建过程中提取样式，以便它们可以被打包并被使用者项目使用。

为了实现这一点，我需要在我的 rollup 配置中使用类似 `babel-plugin-styled-components` 的工具，结合 Babel 插件来处理。

```
babel({<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">extensions</span>:&nbsp;[<span data-darkreader-inline-color="">".ts"</span>,&nbsp;<span data-darkreader-inline-color="">".tsx"</span>],<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">exclude</span>:&nbsp;<span data-darkreader-inline-color="">"node_modules/**"</span>,<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">presets</span>:&nbsp;[<span data-darkreader-inline-color="">"@babel/preset-react"</span>,&nbsp;<span data-darkreader-inline-color="">"@babel/preset-typescript"</span>],<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">plugins</span>:&nbsp;[<span data-darkreader-inline-color="">"styled-components"</span>],<br>}),<br>
```

CSS 输出：有一个名为 `rollup-plugin-styles` 的 Rollup 插件，如果你编写的内容会被转译为 CSS，则应该将其包含在配置文件中。

该插件确保你编写的样式被正确提取。

```
<span data-darkreader-inline-color="">export</span>&nbsp;<span data-darkreader-inline-color="">default</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">input</span>:&nbsp;<span data-darkreader-inline-color="">"packages/index.ts"</span>,<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">output</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">file</span>:&nbsp;<span data-darkreader-inline-color="">"dist/index.js"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">format</span>:&nbsp;<span data-darkreader-inline-color="">"cjs"</span>,<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">external</span>:&nbsp;[<span data-darkreader-inline-color="">"react"</span>,&nbsp;<span data-darkreader-inline-color="">"react-dom"</span>,&nbsp;<span data-darkreader-inline-color="">"next/router"</span>],<br>&nbsp;&nbsp;styles(),<br>}<br>
```

在`peerDependencies`属性中，依赖项的确切版本被硬编码了。但是，有一种方法可以确保 peerDependencies 自动更新到最新的兼容版本，而不需要手动硬编码它们。

你可以在 peerDependencies 的版本范围中使用`latest`标签。

```
peerDependencies:&nbsp;{<br>&nbsp;react:&nbsp;<span data-darkreader-inline-color="">"latest"</span>,<br>&nbsp;<span data-darkreader-inline-color="">"styled-components"</span>:&nbsp;<span data-darkreader-inline-color="">"latest"</span>,<br>}<br>
```

通过使用`latest`标签，它会自动获取满足指定版本范围的最新版本的 peerDependencies。

这样，你就不需要每次有新的兼容版本时手动更新版本。

当用户安装你的包或运行`npm install`或`yarn install`时，包管理器将根据`package.json`中指定的版本范围获取 peerDependencies 的最新兼容版本。

但是——总会有一个但是——请记住，使用`latest`标签也可能引入潜在的破坏性变更，如果 peerDependencies 发布了新的主要版本并包含了破坏性变更。

为了减轻这个问题，在发布新版本之前，最好使用 peerDependencies 的最新版本进行全面测试。

这是完整的 rollup 配置的样例：

```
<span data-darkreader-inline-color="">import</span>&nbsp;babel&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">"rollup-plugin-babel"</span>;<br><span data-darkreader-inline-color="">import</span>&nbsp;commonjs&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">"rollup-plugin-commonjs"</span>;<br><span data-darkreader-inline-color="">import</span>&nbsp;generatePackageJSON&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">"rollup-plugin-generate-package-json"</span>;<br><span data-darkreader-inline-color="">import</span>&nbsp;{&nbsp;nodeResolve&nbsp;}&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">"@rollup/plugin-node-resolve"</span>;<br><span data-darkreader-inline-color="">import</span>&nbsp;styles&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">"rollup-plugin-styles"</span>;<br><span data-darkreader-inline-color="">import</span>&nbsp;{&nbsp;terser&nbsp;}&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">"rollup-plugin-terser"</span>;<br><br><span data-darkreader-inline-color="">const</span>&nbsp;dev&nbsp;=&nbsp;process.env.NODE_ENV&nbsp;!==&nbsp;<span data-darkreader-inline-color="">"production"</span>;<br><br><span data-darkreader-inline-color="">export</span>&nbsp;<span data-darkreader-inline-color="">default</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">input</span>:&nbsp;<span data-darkreader-inline-color="">"packages/index.ts"</span>,<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">output</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">file</span>:&nbsp;<span data-darkreader-inline-color="">"dist/index.js"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">format</span>:&nbsp;<span data-darkreader-inline-color="">"cjs"</span>,<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">external</span>:&nbsp;[<span data-darkreader-inline-color="">"react"</span>,&nbsp;<span data-darkreader-inline-color="">"react-dom"</span>],<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">plugins</span>:&nbsp;[<br>&nbsp;&nbsp;&nbsp;&nbsp;nodeResolve({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">extensions</span>:&nbsp;[<span data-darkreader-inline-color="">".ts"</span>,&nbsp;<span data-darkreader-inline-color="">".tsx"</span>],<br>&nbsp;&nbsp;&nbsp;&nbsp;}),<br>&nbsp;&nbsp;&nbsp;&nbsp;babel({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">extensions</span>:&nbsp;[<span data-darkreader-inline-color="">".ts"</span>,&nbsp;<span data-darkreader-inline-color="">".tsx"</span>],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">exclude</span>:&nbsp;<span data-darkreader-inline-color="">"node_modules/**"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">presets</span>:&nbsp;[<span data-darkreader-inline-color="">"@babel/preset-react"</span>,&nbsp;<span data-darkreader-inline-color="">"@babel/preset-typescript"</span>],<br>&nbsp;&nbsp;&nbsp;&nbsp;}),<br>&nbsp;&nbsp;&nbsp;&nbsp;generatePackageJSON({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">outputFolder</span>:&nbsp;<span data-darkreader-inline-color="">"dist"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">baseContents</span>:&nbsp;<span>(<span data-darkreader-inline-color="">pkg</span>)&nbsp;=&gt;</span>&nbsp;({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">name</span>:&nbsp;pkg.name,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">main</span>:&nbsp;<span data-darkreader-inline-color="">"/dist/index.js"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">peerDependencies</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">react</span>:&nbsp;<span data-darkreader-inline-color="">"^18.2.0"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"styled-components"</span>:&nbsp;<span data-darkreader-inline-color="">"^6.0.0-rc.3"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}),<br>&nbsp;&nbsp;&nbsp;&nbsp;}),<br>&nbsp;&nbsp;&nbsp;&nbsp;terser({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">ecma</span>:&nbsp;<span data-darkreader-inline-color="">2015</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">mangle</span>:&nbsp;{&nbsp;<span data-darkreader-inline-color="">toplevel</span>:&nbsp;<span data-darkreader-inline-color="">true</span>&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">compress</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">toplevel</span>:&nbsp;<span data-darkreader-inline-color="">true</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">drop_console</span>:&nbsp;!dev,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">drop_debugger</span>:&nbsp;!dev,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">output</span>:&nbsp;{&nbsp;<span data-darkreader-inline-color="">quote_style</span>:&nbsp;<span data-darkreader-inline-color="">1</span>&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;}),<br>&nbsp;&nbsp;&nbsp;&nbsp;commonjs(),<br>&nbsp;&nbsp;&nbsp;&nbsp;styles(),<br>&nbsp;&nbsp;],<br>};<br>
```

这是`package.json`文件的重要部分，它指定了 react-tab 包的构建配置和脚本。

你可以根据你的用例进行调整：

```
{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">"main"</span>:&nbsp;<span data-darkreader-inline-color="">"./dist/cjs/index.js"</span>,<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">"module"</span>:&nbsp;<span data-darkreader-inline-color="">"./dist/esm/index.js"</span>,<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">"types"</span>:&nbsp;<span data-darkreader-inline-color="">"./dist/esm/index.d.ts"</span>,<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">"scripts"</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"build:esm"</span>:&nbsp;<span data-darkreader-inline-color="">"tsc"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"build"</span>:&nbsp;<span data-darkreader-inline-color="">"yarn&nbsp;build:esm&nbsp;&amp;&amp;&nbsp;yarn&nbsp;build:cjs"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"build:cjs"</span>:&nbsp;<span data-darkreader-inline-color="">"rollup&nbsp;-c"</span><br>&nbsp;&nbsp;}<br>}<br>
```

以下是代码段的解释：

`"main": "./dist/cjs/index.js"` 指定了 CommonJS (CJS) 模块的入口点。当在 CommonJS 环境中使用 require() 或 import 导入你的包时，将加载此文件。

`"module": "./dist/esm/index.js"` 指定了 ECMAScript 模块 (ESM) 的入口点。当在支持 ESM 的环境中使用 import 导入你的包时，将加载此文件。

`"types": "./dist/esm/index.d.ts"` 指定了 TypeScript 声明文件 (`.d.ts`) 的位置。

该文件为你的包提供类型信息，允许 TypeScript 用户在使用你的包时进行类型检查和自动补全。

`"build:esm": "tsc"` 运行 TypeScript 编译器 `tsc` 来构建你的包的 ESM 版本。它将 TypeScript 代码编译为 JavaScript，并将文件输出到 `./dist/esm` 目录中。

`"build": "yarn build:esm && yarn build:cjs"` 首先运行 `build:esm` 脚本，然后执行 `build:cjs` 脚本。

这确保构建了你的包的 ESM 和 CJS 版本。

`"build:cjs": "rollup -c"` 使用 Rollup 打包工具 `rollup` 和配置文件（`-c`）运行。Rollup 读取配置文件来打包你的代码，应用任何指定的转换或优化。输出文件生成在 `./dist/cjs` 目录中。

本地测试发布之前的部分有些棘手，因为它可能会在一定程度上影响你的工具的版本管理过程。

不要在每次进行重大更改时都运行 `npm publish`，而应该使用 `npm link` 将包链接起来。

如果你使用的是 Linux 发行版操作系统，你需要在 `npm link` 前面添加 `sudo` 来授予权限。这样可以创建一个软链接来引用该包。

然后，你可以在另一个项目中使用如下命令来链接该包：

```
npm&nbsp;link&nbsp;package-name<br>
```

以上是对如何构建一个 React 和 TypeScript 组件库的过程的一些步骤和资源。

希望对你实现目标有所帮助。

以下是一些可能帮助你的资源：

-   如何使用 React 和 TypeScript 构建组件库<sup data-darkreader-inline-color="">[7]</sup>
    
-   使用 React、TypeScript 和 Rollup 设置组件库<sup data-darkreader-inline-color="">[8]</sup>
    
-   使用 Storybook 和 Rollup 轻松构建和发布 React / TypeScript 组件库到 Npm<sup data-darkreader-inline-color="">[9]</sup>
    

参考：https://dev.to/seven/building-an-npm-package-in-2023-10l4

-   **喜欢点赞，再看，转发谢谢！**  
    

-   ```
    <p mp-original-font-size="16" mp-original-line-height="28" data-darkreader-inline-outline="" data-darkreader-inline-color=""><span data-darkreader-inline-color="">扫描下方二维码，加我微信，看我逗比朋友圈，拉你进gpt前端</span><span data-darkreader-inline-color="">交流群，一起抱团取暖。</span></p>
    ```
    
-   ![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)
    
-   ![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)
    
    点个在看支持我吧，转发就更好了
    
-   参考资料  
    

\[1\]

webpack: _https://webpack.js.org/_

\[2\]

React Tab 组件: _https://github.com/kaf-lamed-beyt/react-tab_

\[3\]

你可能不需要状态管理库: _https://meje.dev/blog/keep-state-in-the-url_

\[4\]

辅助函数: _https://github.com/kaf-lamed-beyt/extract-md-headings_

\[5\]

这里: _https://github.com/kaf-lamed-beyt/extract-md-headings/blob/master/tsconfig.json_

\[6\]

react-tab: _https://github.com/kaf-lamed-beyt/react-tab_

\[7\]

如何使用 React 和 TypeScript 构建组件库: _https://blog.logrocket.com/how-to-build-component-library-react-typescript/_

\[8\]

使用 React、TypeScript 和 Rollup 设置组件库: _https://dev.to/siddharthvenkatesh/component-library-setup-with-react-typescript-and-rollup-onj_

\[9\]

使用 Storybook 和 Rollup 轻松构建和发布 React / TypeScript 组件库到 Npm: _https://medium.com/soulweb-academy/easily-build-and-publish-a-react-typescript-component-library-package-to-npm-using-storybook-and-4836d4f700b6_