> 装饰器来啦

## 前言

大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心。

![Image](https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdjNrLicAeuIo3yFeyKpAoAWQ6Cq95ngiahhHJFUdjY1N953V6x6ribOAVlxTIXkGrpAA5MwD6SgzO3kg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## 基本介绍

装饰器是一种以 @ 符号开头的特殊语法，放在目标代码的前面用于包装或扩展代码功能。JavaScript 的装饰器语法目前仍处于提案阶段，现阶段使用的话需要通过 bable 等方式进行编译之后，才能在浏览器正常运行。装饰器分为两种：类装饰器，类成员装饰器，分别用于装饰我们的类以及类的成员。

## 基本使用（类装饰器）

```
<span><span data-darkreader-inline-color="">class</span>&nbsp;<span data-darkreader-inline-color="">MyClass</span>&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">constructor</span>()&nbsp;{}<br>}<br>
```

比如现在有一个类或者函数 `MyClass`，它的身上没有任何的东西，但是我想要给他加一个 `log` 方法，那我们应该怎么做呢？很多人回想说，直接在它身上加一个 `log` 方法即可~

```
<span><span data-darkreader-inline-color="">class</span>&nbsp;<span data-darkreader-inline-color="">MyClass</span>&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">constructor</span>()&nbsp;{}<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;log()&nbsp;{}<br>}<br>
```

但是这么做的话，一个 class 是能做，那如果要给 1000 个 class 加上 `log`方法呢？那岂不是每一个都得写~很麻烦，这个时候可以使用 `装饰器` 去拓展每一个 class

-   可以拓展原型方法
    
-   可以拓展静态属性
    

装饰器接收的参数是装饰的目标类，这里的 `cls` 就是 `MyClass`

```
<span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">addConcole</span>(<span>target</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;拓展原型方法</span><br>&nbsp;&nbsp;target.prototype.log&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>msg</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">`[<span data-darkreader-inline-color="">${<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Date</span>()}</span>&nbsp;<span data-darkreader-inline-color="">${msg}</span>`</span>);<br>&nbsp;&nbsp;};<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;拓展静态属性</span><br>&nbsp;&nbsp;target.myName&nbsp;=&nbsp;<span data-darkreader-inline-color="">'一个类'</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;target;<br>}<br><br>@addConcole<br><span><span data-darkreader-inline-color="">class</span>&nbsp;<span data-darkreader-inline-color="">MyClass</span>&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">constructor</span>()&nbsp;{}<br>}<br><br><span data-darkreader-inline-color="">const</span>&nbsp;myObj&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;MyClass();<br>myObj.log(<span data-darkreader-inline-color="">'林三心'</span>);<br><span data-darkreader-inline-color="">//&nbsp;[Sat&nbsp;Jul&nbsp;08&nbsp;2023&nbsp;17:31:55&nbsp;GMT+0800&nbsp;(中国标准时间)&nbsp;林三心</span><br><span data-darkreader-inline-color="">console</span>.log(MyClass.myName)<br><span data-darkreader-inline-color="">//&nbsp;一个类</span><br>
```

## 应用场景

### Node路由请求Url（类成员装饰器）

我们在使用一些 Node 的框架时，在写接口的时候，我们可能会经常看到这样的代码

-   当我们请求路径是 GET doc 时会匹配到findDocById
    
-   当我们请求路径是 POST doc 时会匹配到createDoc
    

```
<span data-darkreader-inline-color="">class</span>&nbsp;Doc&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">@Get</span>(<span data-darkreader-inline-color="">'doc'</span>)<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">async</span>&nbsp;findDocById(id)&nbsp;{}<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">@Post</span>(<span data-darkreader-inline-color="">'doc'</span>)<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">async</span>&nbsp;createDoc(data)&nbsp;{}<br>}<br>
```

其实这个 `@Get` 和 `@Post` ，是框架提供给我们的 `类成员装饰器`，是的，类成员也能使用装饰器，类成员装饰器接收三个参数：

-   `target` 是目标类的原型对象
    
-   `key` 表示目标类成员的键名
    
-   `descriptor` 是一个属性描述符对象，它包含目标类成员的属性特性（例如 value、writable 等）
    

```
<span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">Get</span>(<span>path</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>target,&nbsp;key,&nbsp;descriptor</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;descriptor<br>&nbsp;&nbsp;&nbsp;&nbsp;})<br>&nbsp;&nbsp;}<br>}<br>
```

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

他的基本实现原理大概是这样的

```
<span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">Get</span>(<span>routePath</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>target,&nbsp;key,&nbsp;descriptor</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;originalMethod&nbsp;=&nbsp;descriptor.value;&nbsp;<span data-darkreader-inline-color="">//&nbsp;保存原始方法</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;descriptor.value&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;在原始方法执行前加入逻辑</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">'处理&nbsp;Get&nbsp;请求，路由路径:&nbsp;'</span>&nbsp;+&nbsp;routePath);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;执行原始方法</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;result&nbsp;=&nbsp;originalMethod.apply(<span data-darkreader-inline-color="">this</span>,&nbsp;<span data-darkreader-inline-color="">arguments</span>);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;在原始方法执行后加入逻辑</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">'Get&nbsp;请求处理完成'</span>);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;result;<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;descriptor;<br>&nbsp;&nbsp;};<br>}<br>
```

### 接口权限控制（类成员装饰器叠加）

上面我们介绍了一下 Nodejs Url 的路由匹配基本原理，但是这是不够的，因为很多接口还需要权限控制，比如：

-   GET doc 接口只能 管理员 才能访问
    
-   POST doc 接口只能 超级管理员 才能访问
    

这也可以用装饰器来实现，并且装饰器是可以叠加的~

```
<span><span data-darkreader-inline-color="">class</span>&nbsp;<span data-darkreader-inline-color="">Doc</span>&nbsp;</span>{<br>&nbsp;&nbsp;@Get(<span data-darkreader-inline-color="">'doc'</span>)<br>&nbsp;&nbsp;@Role(<span data-darkreader-inline-color="">'admin'</span>)<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">async</span>&nbsp;findDocById(id)&nbsp;{}<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;@Post(<span data-darkreader-inline-color="">'doc'</span>)<br>&nbsp;&nbsp;@Role(<span data-darkreader-inline-color="">'superAdmin'</span>)<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">async</span>&nbsp;createDoc(data)&nbsp;{}<br>}<br>
```

装饰器叠加的执行顺序是 从下往上 的~我们可以看一下下面的例子，发现输出顺序是

-   2
    
-   1
    

```
<span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">A</span>&nbsp;(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">1</span>)<br>}<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">B</span>&nbsp;(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">2</span>)<br>}<br><span><span data-darkreader-inline-color="">class</span>&nbsp;<span data-darkreader-inline-color="">Doc</span>&nbsp;</span>{<br>&nbsp;&nbsp;@A<br>&nbsp;&nbsp;@B<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">async</span>&nbsp;test()&nbsp;{}<br>}<br>
```

至于权限控制的装饰器实现，需要根据不同业务去实现，我这里就粗略实现一下

```
<span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">Role</span>(<span>permissions</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>target,&nbsp;key,&nbsp;descriptor</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;originalMethod&nbsp;=&nbsp;descriptor.value;&nbsp;<span data-darkreader-inline-color="">//&nbsp;保存原始方法</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;descriptor.value&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;在原始方法执行前进行权限验证</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;user&nbsp;=&nbsp;getCurrentUser();&nbsp;<span data-darkreader-inline-color="">//&nbsp;获取当前用户信息</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;检查用户是否拥有所需权限</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;hasPermission&nbsp;=&nbsp;checkUserPermissions(user,&nbsp;permissions);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!hasPermission)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果用户没有权限，则抛出错误或执行其他处理</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">throw</span>&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Error</span>(<span data-darkreader-inline-color="">'无权限访问该接口'</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;执行原始方法</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;result&nbsp;=&nbsp;originalMethod.apply(<span data-darkreader-inline-color="">this</span>,&nbsp;<span data-darkreader-inline-color="">arguments</span>);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;result;<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;descriptor;<br>&nbsp;&nbsp;};<br>}<br>
```

### 记录日志的装饰器

我们想要在执行某个函数的时候，记录一下

-   函数调用时间
    
-   函数调用参数
    

这个时候我们也可以使用装饰器来完成，非常方便！！！

```
<span data-darkreader-inline-color="">//&nbsp;日志装饰器函数</span><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">logDecorator</span>(<span>target,&nbsp;key,&nbsp;descriptor</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;originalMethod&nbsp;=&nbsp;descriptor.value;&nbsp;<span data-darkreader-inline-color="">//&nbsp;保存原始方法</span><br><br>&nbsp;&nbsp;descriptor.value&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>...args</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">`调用函数：<span data-darkreader-inline-color="">${key}</span>`</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">`参数：<span data-darkreader-inline-color="">${<span data-darkreader-inline-color="">JSON</span>.stringify(args)}</span>`</span>);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;执行原始方法</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;result&nbsp;=&nbsp;originalMethod.apply(<span data-darkreader-inline-color="">this</span>,&nbsp;args);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">`返回值：<span data-darkreader-inline-color="">${result}</span>`</span>);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;result;<br>&nbsp;&nbsp;};<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;descriptor;<br>}<br><br><span data-darkreader-inline-color="">//&nbsp;示例类</span><br><span><span data-darkreader-inline-color="">class</span>&nbsp;<span data-darkreader-inline-color="">Example</span>&nbsp;</span>{<br>&nbsp;&nbsp;@logDecorator<br>&nbsp;&nbsp;greet(name)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">`Hello,&nbsp;<span data-darkreader-inline-color="">${name}</span>!`</span>;<br>&nbsp;&nbsp;}<br>}<br><br><span data-darkreader-inline-color="">//&nbsp;测试</span><br><span data-darkreader-inline-color="">const</span>&nbsp;example&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Example();<br>example.greet(<span data-darkreader-inline-color="">'林三心'</span>);<br>
```

### 缓存的装饰器

如果我们执行一个方法，获取返回值需要经过一系列的计算，非常耗时间，那么我们可以判断入参，第一次时计算完缓存起来，第二次的时候如果还是这个入参，就直接从缓存中去拿，这个操作也可以使用装饰器去完成

```
<span data-darkreader-inline-color="">//&nbsp;缓存装饰器函数</span><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">cacheDecorator</span>(<span>target,&nbsp;key,&nbsp;descriptor</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;cache&nbsp;=&nbsp;{};&nbsp;<span data-darkreader-inline-color="">//&nbsp;缓存对象</span><br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;originalMethod&nbsp;=&nbsp;descriptor.value;&nbsp;<span data-darkreader-inline-color="">//&nbsp;保存原始方法</span><br><br>&nbsp;&nbsp;descriptor.value&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>...args</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;cacheKey&nbsp;=&nbsp;<span data-darkreader-inline-color="">JSON</span>.stringify(args);&nbsp;<span data-darkreader-inline-color="">//&nbsp;生成缓存键</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(cacheKey&nbsp;<span data-darkreader-inline-color="">in</span>&nbsp;cache)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">'从缓存中获取结果'</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;cache[cacheKey];&nbsp;<span data-darkreader-inline-color="">//&nbsp;直接返回缓存结果</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;执行原始方法</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;result&nbsp;=&nbsp;originalMethod.apply(<span data-darkreader-inline-color="">this</span>,&nbsp;args);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">'将结果缓存起来'</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;cache[cacheKey]&nbsp;=&nbsp;result;&nbsp;<span data-darkreader-inline-color="">//&nbsp;缓存结果</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;result;<br>&nbsp;&nbsp;};<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;descriptor;<br>}<br><br><span data-darkreader-inline-color="">//&nbsp;示例类</span><br><span><span data-darkreader-inline-color="">class</span>&nbsp;<span data-darkreader-inline-color="">Example</span>&nbsp;</span>{<br>&nbsp;&nbsp;@cacheDecorator<br>&nbsp;&nbsp;getValue(key)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">'执行函数逻辑'</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;key&nbsp;+&nbsp;<span data-darkreader-inline-color="">Math</span>.random();&nbsp;<span data-darkreader-inline-color="">//&nbsp;模拟复杂的计算逻辑</span><br>&nbsp;&nbsp;}<br>}<br><br><span data-darkreader-inline-color="">//&nbsp;测试</span><br><span data-darkreader-inline-color="">const</span>&nbsp;example&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Example();<br><span data-darkreader-inline-color="">console</span>.log(example.getValue(<span data-darkreader-inline-color="">'foo'</span>));<br><span data-darkreader-inline-color="">console</span>.log(example.getValue(<span data-darkreader-inline-color="">'foo'</span>));&nbsp;<span data-darkreader-inline-color="">//&nbsp;从缓存中获取结果</span><br>
```

### 防抖节流的装饰器

对于防抖节流，我们平时可能会这么去做

```
<span><span data-darkreader-inline-color="">class</span>&nbsp;<span data-darkreader-inline-color="">C</span>&nbsp;</span>{<br>&nbsp;&nbsp;onClick&nbsp;=&nbsp;debounce(fn,&nbsp;<span data-darkreader-inline-color="">100</span>)<br>}<br>
```

但是这么做的话会使这个函数不好拓展，所以使用装饰器真的很方便

```
<span data-darkreader-inline-color="">//&nbsp;防抖装饰器</span><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">debounce</span>(<span>time</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span>target,&nbsp;key,&nbsp;descriptor</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;oldFunction&nbsp;=&nbsp;descriptor.value;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;timer&nbsp;=&nbsp;<span data-darkreader-inline-color="">null</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;descriptor.value&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timer);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timer&nbsp;=&nbsp;setTimeout(<span><span>()</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oldFunction.apply(<span data-darkreader-inline-color="">this</span>,&nbsp;<span data-darkreader-inline-color="">arguments</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;time);<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;descriptor;<br>&nbsp;&nbsp;}<br>}<br><br><span data-darkreader-inline-color="">//&nbsp;节流装饰器</span><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">throttle</span>(<span>time</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span>target,&nbsp;key,&nbsp;descriptor</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;oldFunction&nbsp;=&nbsp;descriptor.value;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;isLock&nbsp;=&nbsp;<span data-darkreader-inline-color="">false</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;descriptor.value&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>(isLock)&nbsp;{&nbsp;<span data-darkreader-inline-color="">return</span>;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isLock&nbsp;=&nbsp;<span data-darkreader-inline-color="">true</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oldFunction.apply(<span data-darkreader-inline-color="">this</span>,&nbsp;<span data-darkreader-inline-color="">arguments</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(<span><span>()</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isLock&nbsp;=&nbsp;<span data-darkreader-inline-color="">false</span>;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;time);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;descriptor;<br>&nbsp;&nbsp;}<br>}<br><br><span><span data-darkreader-inline-color="">class</span>&nbsp;<span data-darkreader-inline-color="">C</span>&nbsp;</span>{<br>&nbsp;&nbsp;@debounce(<span data-darkreader-inline-color="">1000</span>)<br>&nbsp;&nbsp;onClick()&nbsp;{}<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;@throttle(<span data-darkreader-inline-color="">1000</span>)<br>&nbsp;&nbsp;onScroll()&nbsp;{}<br>}<br>
```

## 结语

我是林三心

-   一个待过**小型toG型外包公司、大型外包公司、小公司、潜力型创业公司、大公司**的作死型前端选手；
    
-   一个偏前端的全干工程师；
    
-   一个不正经的掘金作者；
    
-   逗比的B站up主；
    
-   不帅的小红书博主；
    
-   喜欢打铁的篮球菜鸟；
    
-   喜欢历史的乏味少年；
    
-   喜欢rap的五音不全弱鸡
    

如果你想一起学习前端，一起摸鱼，一起研究简历优化，一起研究面试进步，一起交流历史音乐篮球rap，可以来俺的摸鱼学习群哈哈，点这个，有7000多名前端小伙伴在等着一起学习哦 -->