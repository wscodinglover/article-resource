## 前言

在之前的性能优化系列文章中，分享了前端性能优化的具体措施。但是在实际工作中，如何量化性能也是相当重要的一环，需要一些客观的指标来衡量页面的性能。本文会介绍几个性能指标及其衡量方式。

## 性能指标

### FP

FP（First Paint，首次绘制），也被称为白屏时间，用于记录页面第一次绘制像素的时间。

![Image](https://mmbiz.qpic.cn/mmbiz_png/wnFvhQqHtzy91BlknicIKwoP6wESgNELBZz985F7n5CDztcXlr8sOFjlGx7OSnsKqbclcgoqYFVIzVDJZ31VOOA/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

FP示意图

可以通过 Performance API<sup>[1]</sup> 获取 FP 值。

```
<span></span><code><span>//&nbsp;获取&nbsp;FP&nbsp;值</span><br><span>new</span>&nbsp;PerformanceObserver(<span>(<span>entryList</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span>for</span>&nbsp;(<span>const</span>&nbsp;entry&nbsp;<span>of</span>&nbsp;entryList.getEntriesByName(<span>"first-paint"</span>))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span>console</span>.log(<span>"FP&nbsp;candidate:"</span>,&nbsp;entry.startTime&nbsp;+&nbsp;<span>"ms"</span>);<br>&nbsp;&nbsp;}<br>}).observe({&nbsp;<span>type</span>:&nbsp;<span>"paint"</span>,&nbsp;<span>buffered</span>:&nbsp;<span>true</span>&nbsp;});<br></code>
```

该指标侧重的是像素绘制，比如开始绘制背景色。虽然背景颜色可能绘制得很快，但实际内容/交互可能需要更长的时间才能加载。在这种情况下，FP 指标的价值并不大，可以使用 FCP 来替代。

### FCP

FCP(First Contentful Paint，首次内容绘制)，用于记录页面首次绘制文本、图片、非空白 Canvas 或 `<svg>`元素的时间。

![Image](https://mmbiz.qpic.cn/mmbiz_png/wnFvhQqHtzy91BlknicIKwoP6wESgNELBp4MFaQNxwp1utdA7yXLuSBLGdQiaJJCkWNiboAteibI0biczgtBtjnWXjQ/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

FCP示意图

该指标关注的焦点是内容，用来度量用户第一次看到有用的信息的时间。对于用户体验评估而言，该指标比 FP 更有实际价值。

根据 Google 的建议<sup>[2]</sup>，为了提供良好的用户体验，网站应该努力将 FCP 控制在 1.8 秒或以内。

![Image](https://mmbiz.qpic.cn/mmbiz_svg/bj9JGugn6Uck6P2zNYBmaibTjuFiakkRibtFFOZYtmj6dQe77J3icicFHIfW1j3gkL1W6icAxicjdPDPb6pKOSyIg7fiaQmuOiaAroI5N/640?wx_fmt=svg&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

FCP评分示意

可以通过 Performance API 获取 FCP 值。

```
<span></span><code><span>//&nbsp;获取&nbsp;FCP&nbsp;值</span><br><span>new</span>&nbsp;PerformanceObserver(<span>(<span>entryList</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span>for</span>&nbsp;(<span>const</span>&nbsp;entry&nbsp;<span>of</span>&nbsp;entryList.getEntriesByName(<span>"first-contentful-paint"</span>))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span>console</span>.log(<span>"FCP&nbsp;candidate:"</span>,&nbsp;entry.startTime&nbsp;+&nbsp;<span>"ms"</span>);<br>&nbsp;&nbsp;}<br>}).observe({&nbsp;<span>type</span>:&nbsp;<span>"paint"</span>,&nbsp;<span>buffered</span>:&nbsp;<span>true</span>&nbsp;});<br></code>
```

### LCP

LCP（Largest Contentful Paint，最大内容绘制），用于衡量可视区域内可见的最大的内容元素绘制到页面上的速度。

![Image](https://mmbiz.qpic.cn/mmbiz_png/wnFvhQqHtzy91BlknicIKwoP6wESgNELBMmQb1icibr5wUd31zxzvIRhUua5OM2nstngDPJicZFPcEUB1sEfn2Vzxg/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

LCP示意图

值得注意的是，该时间通常会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变。如下面例子所示，随着页面滚动，最大元素从标题区域变化成了图片元素（绿色线条包围部分）。

![Image](https://mmbiz.qpic.cn/mmbiz_jpg/wnFvhQqHtzy91BlknicIKwoP6wESgNELBtGh4AFOUU7nEUd86g989I3nGdrQZzOkb1V5jSadOib9tccOicdErISeg/640?wx_fmt=other&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

最大内容变更示意

根据 Google 建议，为了提供良好的用户体验，网站应该努力将 LCP 控制在 2.5 秒或以内。

![Image](https://mmbiz.qpic.cn/mmbiz_svg/bj9JGugn6Uck6P2zNYBmaibTjuFiakkRibtNcUIkWLdVB5MW1E6rjl3MIqj1duoTVdcskYbXCaSNxbbUelv6zTNUnLRkUfme0E1/640?wx_fmt=svg&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

LCP分数值

可使用 Performance API 获取 LCP 值。

```
<span></span><code><span>//&nbsp;获取&nbsp;LCP&nbsp;值</span><br><span>new</span>&nbsp;PerformanceObserver(<span>(<span>entryList</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span>for</span>&nbsp;(<span>const</span>&nbsp;entry&nbsp;<span>of</span>&nbsp;entryList.getEntries())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span>console</span>.log(<span>"LCP&nbsp;candidate:"</span>,&nbsp;entry.startTime&nbsp;+&nbsp;<span>"ms"</span>,&nbsp;entry);<br>&nbsp;&nbsp;}<br>}).observe({&nbsp;<span>type</span>:&nbsp;<span>"largest-contentful-paint"</span>,&nbsp;<span>buffered</span>:&nbsp;<span>true</span>&nbsp;});<br></code>
```

### TTI

TTI（Time to Interactive，可交互时间），该指标测量首次内容绘制 (FCP)之后页面可靠地为用户交互做好准备的最早时间。简单来说，快速的 TTI 有助于确保页面可用。

TTI 被测量为 5 秒空闲窗口之前最后一个长任务的时间或者 FCP 时间。

![Image](https://mmbiz.qpic.cn/mmbiz_svg/bj9JGugn6Uck6P2zNYBmaibTjuFiakkRibtC9nIhCu1sibqlXHDXoIGrT097IQSU0S3jUn00NJibuaetI3p2kof8iabWLSqSnhkJXY/640?wx_fmt=svg&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

TTI计算图

一般而言，应将 FCP 和 TTI 之间的差值降至最低。因为当用户尝试与看似具备交互性但实际上并非如此的页面进行交互时，反而会带来不好的体验。

### FID

FID（First Input Delay，首次输入延迟），测量用户第一次与页面交互直到浏览器对交互作出响应，并实际能够开始处理事件处理程序所经过的时间。FID 有助于衡量网站的交互性和响应度，低 FID 有助于让用户确信页面是有效的。

![Image](https://mmbiz.qpic.cn/mmbiz_png/wnFvhQqHtzy91BlknicIKwoP6wESgNELBx0ZVXa7Pf1Oib5LOmPBST82hTZx8gn4rGiajJH67iaZ8uibml9OEqs7puA/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

FID示意图

较长的 FID 通常发生在 FCP 和 TTI 之间，如下图所示，如果用户在长任务执行时就尝试与页面进行交互，那么浏览器必须等到任务完成后才能对输入作出响应。浏览器必须等待的这段时间就是这位用户在该页面上体验到的 FID 值。

![Image](https://mmbiz.qpic.cn/mmbiz_svg/bj9JGugn6Uck6P2zNYBmaibTjuFiakkRibticBIox2dQYAiamLxJjBGglrTMvhpiarlMuNc9AU1xEfeic9CcFzxEkzBj5pOWTFIKTz0/640?wx_fmt=svg&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

FID解释

根据 Google 建议，为了提供良好的用户体验，网站应该努力将 FID 控制在 100 毫秒或以内。

![Image](https://mmbiz.qpic.cn/mmbiz_svg/bj9JGugn6Uck6P2zNYBmaibTjuFiakkRibtUS5OOf5HFF7n2ia2ibRroSeUia1eJCJsiaKAnyibjDMbcUMmmoDyk1716XIjr5W72PZq2/640?wx_fmt=svg&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

FID分数值

可以使用 Performance API 获取 FID 值

```
<span></span><code><span>//&nbsp;获取&nbsp;FID&nbsp;值</span><br><span>new</span>&nbsp;PerformanceObserver(<span>(<span>entryList</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span>for</span>&nbsp;(<span>const</span>&nbsp;entry&nbsp;<span>of</span>&nbsp;entryList.getEntries())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span>const</span>&nbsp;delay&nbsp;=&nbsp;entry.processingStart&nbsp;-&nbsp;entry.startTime;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span>console</span>.log(<span>"FID&nbsp;candidate:"</span>,&nbsp;delay&nbsp;+&nbsp;<span>"ms"</span>,&nbsp;entry);<br>&nbsp;&nbsp;}<br>}).observe({&nbsp;<span>type</span>:&nbsp;<span>"first-input"</span>,&nbsp;<span>buffered</span>:&nbsp;<span>true</span>&nbsp;});<br></code>
```

### TBT

TBT（Total Blocking Time，总阻塞时间），记录在 FCP 到 TTI 之间所有长任务的阻塞时间总和。在实际场景中，可以认为 TBT 是 FID 的替代品。

以下面这张页面加载期间浏览器主线程的图表为例，时间轴上有五个任务，其中三个是长任务（在主线程上运行超过 50 毫秒的任务）。

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

浏览器主线程图

下图显示了各个长任务的阻塞时间，虽然在主线程上运行任务的总时间为 560 毫秒，但其中只有 345 毫秒被视为阻塞时间。因此 TBT 为 345ms

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

TBT示意图

可通过 Performance API 获取 TBT 值。

```
<span></span><code><span>//&nbsp;获取&nbsp;TBT&nbsp;值</span><br><span>var</span>&nbsp;totalBlockingTime&nbsp;=&nbsp;<span>0</span>;<br><span>var</span>&nbsp;observer&nbsp;=&nbsp;<span>new</span>&nbsp;PerformanceObserver(<span><span>function</span>&nbsp;(<span>list</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span>let</span>&nbsp;perfEntries&nbsp;=&nbsp;list.getEntries();<br>&nbsp;&nbsp;<span>for</span>&nbsp;(<span>const</span>&nbsp;perfEntry&nbsp;<span>of</span>&nbsp;perfEntries)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;totalBlockingTime&nbsp;+=&nbsp;perfEntry.duration&nbsp;-&nbsp;<span>50</span>;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span>console</span>.log(<span>"TBT:&nbsp;"</span>,&nbsp;totalBlockingTime&nbsp;+&nbsp;<span>"ms"</span>);<br>});<br>observer.observe({&nbsp;<span>type</span>:&nbsp;<span>"longtask"</span>,&nbsp;<span>buffered</span>:&nbsp;<span>true</span>&nbsp;});<br></code>
```

## 总结

本文介绍了 6 个性能指标及其使用 Performance API 的获取方式。另外，在 Chrome DevTools 工具中，也可以通过 Performance 和 LightHouse 面板来进行可视化性能监测。

## 参考资料

\[1\]

Performance API: https://developer.mozilla.org/en-US/docs/Web/API/Performance\_API

\[2\]

Google 的建议: https://developer.chrome.google.cn/docs/lighthouse/performance/first-contentful-paint

## 关于我

如果觉得本文还不错，希望大家**分享、点赞**，本公众号**前端快爆**会定期为您推送最新技术文章，全都是硬菜干货~~

本文到此结束，感谢您的阅读，我们下篇文章见。

关注前端快爆

获取更多精彩

前端快爆

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

点下"在看"，你最好看