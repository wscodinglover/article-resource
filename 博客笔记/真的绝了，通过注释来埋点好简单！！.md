关注公众号 前端界，回复“加群”

加入我们一起学习，天天进步

这篇文章主要讲如何根据注释，通过babel插件自动地，给相应函数插入埋点代码，在实现埋点逻辑和业务逻辑分离的基础上，配置更加灵活

这篇文章想要达到的效果：  
源代码：

```
<span data-darkreader-inline-color="">//##箭头函数</span><br><span data-darkreader-inline-color="">//_tracker</span><br><span data-darkreader-inline-color="">const</span>&nbsp;test1&nbsp;=&nbsp;<span><span>()</span>&nbsp;=&gt;</span>&nbsp;{};<br><br><br><span data-darkreader-inline-color="">const</span>&nbsp;test1_2&nbsp;=&nbsp;<span><span>()</span>&nbsp;=&gt;</span>&nbsp;{};<br>
```

转译之后：

```
<span data-darkreader-inline-color="">import</span>&nbsp;_tracker&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">"tracker"</span>;<br><span data-darkreader-inline-color="">//##箭头函数</span><br><span data-darkreader-inline-color="">//_tracker</span><br><span data-darkreader-inline-color="">const</span>&nbsp;test1&nbsp;=&nbsp;<span><span>()</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;_tracker();<br>};<br><br><span data-darkreader-inline-color="">const</span>&nbsp;test1_2&nbsp;=&nbsp;<span><span>()</span>&nbsp;=&gt;</span>&nbsp;{};<br>
```

代码中有两个函数，其中一个`//_tracker`的注释，另一个没有。转译之后只给有注释的函数添加埋点函数。  
要达到这个效果就需要读取函数上面的注释，如果注释中有`//_tracker`，我们就给函数添加埋点。这样做避免了僵硬的给每个函数都添加埋点的情况，让埋点更加灵活。

下面让我们来看看怎么做

## 开始

准备babel入口文件`index.js`

```
<span data-darkreader-inline-color="">const</span>&nbsp;{&nbsp;transformFileSync&nbsp;}&nbsp;=&nbsp;<span data-darkreader-inline-color="">require</span>(<span data-darkreader-inline-color="">"@babel/core"</span>);<br><span data-darkreader-inline-color="">const</span>&nbsp;path&nbsp;=&nbsp;<span data-darkreader-inline-color="">require</span>(<span data-darkreader-inline-color="">"path"</span>);<br><span data-darkreader-inline-color="">const</span>&nbsp;tracker&nbsp;=&nbsp;<span data-darkreader-inline-color="">require</span>(<span data-darkreader-inline-color="">"./babel-plugin-tracker-comment.js"</span>);<br><br><span data-darkreader-inline-color="">const</span>&nbsp;pathFile&nbsp;=&nbsp;path.resolve(__dirname,&nbsp;<span data-darkreader-inline-color="">"./sourceCode.js"</span>);<br><br><span data-darkreader-inline-color="">//transform&nbsp;ast&nbsp;and&nbsp;generate&nbsp;code</span><br><span data-darkreader-inline-color="">const</span>&nbsp;{&nbsp;code&nbsp;}&nbsp;=&nbsp;transformFileSync(pathFile,&nbsp;{<br>&nbsp;<span>plugins</span>:&nbsp;[[tracker,&nbsp;{&nbsp;<span>trackerPath</span>:&nbsp;<span data-darkreader-inline-color="">"tracker"</span>,&nbsp;<span>commentsTrack</span>:&nbsp;<span data-darkreader-inline-color="">"_tracker"</span>&nbsp;}]],<br>});<br><br><span data-darkreader-inline-color="">console</span>.log(code);<br><br>
```

这里我们使用`transformFileSync`API转译源代码，并将转译之后的代码打印出来。过程中，将手写的插件作为参数传入`plugins: [[tracker, { trackerPath: "tracker", commentsTrack: "_tracker"}]]`。除此之外，还有插件的参数

-   `trackerPath`表示埋点函数的路径，插件在插入埋点函数之前会检查是否已经引入了该函数，如果没有引入就需要额外引入。
    
-   `commentsTrack`标识埋点，如果函数前的注释有这个，就说明函数需要埋点。判断的标识是动态传入的，这样比较灵活
    

入口文件准备好了，接下来准备下源代码文件`sourceCode.js`

```
<span data-darkreader-inline-color="">import</span>&nbsp;<span data-darkreader-inline-color="">"./index.css"</span>;<br><br><span data-darkreader-inline-color="">//##箭头函数</span><br><span data-darkreader-inline-color="">//_tracker</span><br><span data-darkreader-inline-color="">const</span>&nbsp;test1&nbsp;=&nbsp;<span><span>()</span>&nbsp;=&gt;</span>&nbsp;{};<br><br><span data-darkreader-inline-color="">const</span>&nbsp;test1_2&nbsp;=&nbsp;<span><span>()</span>&nbsp;=&gt;</span>&nbsp;{};<br><br><span data-darkreader-inline-color="">//函数表达式</span><br><span data-darkreader-inline-color="">//_tracker</span><br><span data-darkreader-inline-color="">const</span>&nbsp;test2&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;()&nbsp;</span>{};<br><br><span data-darkreader-inline-color="">const</span>&nbsp;test2_1&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;()&nbsp;</span>{};<br><br><span data-darkreader-inline-color="">//&nbsp;函数声明</span><br><span data-darkreader-inline-color="">//_tracker</span><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">test3</span>()&nbsp;</span>{}<br><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">test3_1</span>()&nbsp;</span>{}<br>
```

这里准备了三种不同的函数类型，并且各个函数类型都有一个加了注释，另一个没加作为参照对象  
就差插件了，下面写插件代码`babel-plugin-tracker-comment.js`

## 插件编写

### 功能一

功能实现过程中，涉及到了读取函数的注释，并且判断注释中是否有`//_tracker`

```
<span data-darkreader-inline-color="">const</span>&nbsp;leadingComments&nbsp;=&nbsp;path.get(<span data-darkreader-inline-color="">"leadingComments"</span>);<br><span data-darkreader-inline-color="">const</span>&nbsp;paramCommentPath&nbsp;=&nbsp;hasTrackerComments(leadingComments,&nbsp;options.commentsTrack);<br><br><span data-darkreader-inline-color="">//函数实现</span><br><span data-darkreader-inline-color="">const</span>&nbsp;hasTrackerComments&nbsp;=&nbsp;<span>(<span>leadingComments,&nbsp;comments</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!leadingComments)&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">null</span>;<br>&nbsp;}<br>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">Array</span>.isArray(leadingComments))&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;res&nbsp;=&nbsp;leadingComments.filter(<span>(<span>item</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;item.node.value.includes(comments);<br>&nbsp;&nbsp;});<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;res[<span>0</span>]&nbsp;||&nbsp;<span data-darkreader-inline-color="">null</span>;<br>&nbsp;}<br>&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">null</span>;<br>};<br>
```

具体函数实现，接收函数前的注释，注释可能会有多个，所以需要一一判断。还接受埋点的标识。如果找到了含有注释标识的注释，就将这行注释返回。否则一律返回`null`，表示这个函数不需要埋点

> 那什么是多个注释？

这个很好理解，我们看下AST explorer<sup data-darkreader-inline-color="">[2]</sup>就知道了  
![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)  
`a函数`，前面有4个注释，三个行注释，一个块注释。  
其对应的AST解析是这样的：  
![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)  
AST对象中，用`leadingComments`表示前面的注释，用`trailingComments`表示后面的注释。`leadingComments`中确实有4个注释，并且三个行注释，一个块注释，和代码对应上了。  
函数要做的就是将其中含有`//_tracker`的comment path对象找出来

### 功能二

判断函数确实需要埋点之后，就要开始插入埋点函数了。但在这之前，还需要做一件事，就是检查埋点函数是否引入，如果没有引入就需要额外引入了

```
<span data-darkreader-inline-color="">const</span>&nbsp;{&nbsp;addDefault&nbsp;}&nbsp;=&nbsp;<span data-darkreader-inline-color="">require</span>(<span data-darkreader-inline-color="">"@babel/helper-module-imports"</span>);<br><br><br><span data-darkreader-inline-color="">if</span>&nbsp;(paramCommentPath)&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//add&nbsp;Import</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;programPath&nbsp;=&nbsp;path.hub.file.path;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;importId&nbsp;=&nbsp;checkImport(programPath,&nbsp;options.trackerPath);<br>&nbsp;&nbsp;state.importTackerId&nbsp;=&nbsp;importId;<br>}<br><br><span data-darkreader-inline-color="">//函数实现</span><br><span data-darkreader-inline-color="">const</span>&nbsp;checkImport&nbsp;=&nbsp;<span>(<span>programPath,&nbsp;trackPath</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;importTrackerId&nbsp;=&nbsp;<span data-darkreader-inline-color="">""</span>;<br>&nbsp;&nbsp;programPath.traverse({<br>&nbsp;&nbsp;&nbsp;&nbsp;ImportDeclaration(path)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;sourceValue&nbsp;=&nbsp;path.get(<span data-darkreader-inline-color="">"source"</span>).node.value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(sourceValue&nbsp;===&nbsp;trackPath)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;specifiers&nbsp;=&nbsp;path.get(<span data-darkreader-inline-color="">"specifiers.0"</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;importTrackerId&nbsp;=&nbsp;specifiers.get(<span data-darkreader-inline-color="">"local"</span>).toString();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path.stop();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!importTrackerId)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;importTrackerId&nbsp;=&nbsp;addDefault(programPath,&nbsp;trackPath,&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>nameHint</span>:&nbsp;programPath.scope.generateUid(<span data-darkreader-inline-color="">"tracker"</span>),<br>&nbsp;&nbsp;&nbsp;&nbsp;}).name;<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;importTrackerId;<br>};<br>
```

拿到`import语句`需要program节点。`checkImport`函数的实现就是在当前文件中，找出埋点函数的引入。寻找的过程中，用到了引入插件时传入的参数`trackerPath`。还用到了`traverse`API，用来遍历`import语句`。  
如果找到了引入，就获取引入的变量。这个变量在之后埋点的时候需要。即如果引入的变量命名了`tracker2`，那么埋点的时候埋点函数就是`tracker2`了  
如果没有引入，就插入引入。

`addDefault`就是引入path的函数，并且会返回插入引用的变量。

### 功能三

确定好了函数需要埋点，并且确定了埋点函数引入的变量，接下来就插入函数了。

```
<span data-darkreader-inline-color="">if</span>&nbsp;(paramCommentPath)&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//add&nbsp;Import</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;programPath&nbsp;=&nbsp;path.hub.file.path;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;importId&nbsp;=&nbsp;checkImport(programPath,&nbsp;options.trackerPath);<br>&nbsp;&nbsp;state.importTackerId&nbsp;=&nbsp;importId;<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;insertTracker(path,&nbsp;state);<br>}<br><span data-darkreader-inline-color="">const</span>&nbsp;insertTracker&nbsp;=&nbsp;<span>(<span>path,&nbsp;state</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;bodyPath&nbsp;=&nbsp;path.get(<span data-darkreader-inline-color="">"body"</span>);<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(bodyPath.isBlockStatement())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;ast&nbsp;=&nbsp;template.statement(<span data-darkreader-inline-color="">`<span>${state.importTackerId}</span>();`</span>)();<br>&nbsp;&nbsp;&nbsp;&nbsp;bodyPath.node.body.unshift(ast);<br>&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;ast&nbsp;=&nbsp;template.statement(<span data-darkreader-inline-color="">`{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>${state.importTackerId}</span>();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;BODY;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}`</span>)({&nbsp;<span>BODY</span>:&nbsp;bodyPath.node&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;bodyPath.replaceWith(ast);<br>&nbsp;&nbsp;}<br>};<br>
```

在生成埋点函数的时候，就用到了之前获取到的埋点函数的变量`importTackerId`。还有在实际插入的时候，要区分函数体是一个`Block`，还是直接返回的值--`()=>''`

### 合并功能

三个功能都写好了，接下来将三个功能合起来，就是我们的插件代码了

```
<span data-darkreader-inline-color="">const</span>&nbsp;{&nbsp;declare&nbsp;}&nbsp;=&nbsp;<span data-darkreader-inline-color="">require</span>(<span data-darkreader-inline-color="">"@babel/helper-plugin-utils"</span>);<br><span data-darkreader-inline-color="">const</span>&nbsp;{&nbsp;addDefault&nbsp;}&nbsp;=&nbsp;<span data-darkreader-inline-color="">require</span>(<span data-darkreader-inline-color="">"@babel/helper-module-imports"</span>);<br><span data-darkreader-inline-color="">const</span>&nbsp;{&nbsp;template&nbsp;}&nbsp;=&nbsp;<span data-darkreader-inline-color="">require</span>(<span data-darkreader-inline-color="">"@babel/core"</span>);<br><br><span data-darkreader-inline-color="">//get&nbsp;comments&nbsp;path&nbsp;from&nbsp;leadingComments</span><br><span data-darkreader-inline-color="">const</span>&nbsp;hasTrackerComments&nbsp;=&nbsp;<span>(<span>leadingComments,&nbsp;comments</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!leadingComments)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span>;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">Array</span>.isArray(leadingComments))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;res&nbsp;=&nbsp;leadingComments.filter(<span>(<span>item</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;item.node.value.includes(comments);<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;res[<span>0</span>]&nbsp;||&nbsp;<span data-darkreader-inline-color="">null</span>;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">null</span>;<br>};<br><br><span data-darkreader-inline-color="">//insert&nbsp;path</span><br><span data-darkreader-inline-color="">const</span>&nbsp;insertTracker&nbsp;=&nbsp;<span>(<span>path,&nbsp;param,&nbsp;state</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;bodyPath&nbsp;=&nbsp;path.get(<span data-darkreader-inline-color="">"body"</span>);<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(bodyPath.isBlockStatement())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;ast&nbsp;=&nbsp;template.statement(<span data-darkreader-inline-color="">`<span>${state.importTackerId}</span>(<span>${param}</span>);`</span>)();<br>&nbsp;&nbsp;&nbsp;&nbsp;bodyPath.node.body.unshift(ast);<br>&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;ast&nbsp;=&nbsp;template.statement(<span data-darkreader-inline-color="">`{<br>&nbsp;&nbsp;&nbsp;<span>${state.importTackerId}</span>(<span>${param}</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;BODY;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}`</span>)({&nbsp;<span>BODY</span>:&nbsp;bodyPath.node&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;bodyPath.replaceWith(ast);<br>&nbsp;&nbsp;}<br>};<br><br><span data-darkreader-inline-color="">//check&nbsp;if&nbsp;tacker&nbsp;func&nbsp;was&nbsp;imported</span><br><span data-darkreader-inline-color="">const</span>&nbsp;checkImport&nbsp;=&nbsp;<span>(<span>programPath,&nbsp;trackPath</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;importTrackerId&nbsp;=&nbsp;<span data-darkreader-inline-color="">""</span>;<br>&nbsp;&nbsp;programPath.traverse({<br>&nbsp;&nbsp;&nbsp;&nbsp;ImportDeclaration(path)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;sourceValue&nbsp;=&nbsp;path.get(<span data-darkreader-inline-color="">"source"</span>).node.value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(sourceValue&nbsp;===&nbsp;trackPath)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;specifiers&nbsp;=&nbsp;path.get(<span data-darkreader-inline-color="">"specifiers.0"</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;importTrackerId&nbsp;=&nbsp;specifiers.get(<span data-darkreader-inline-color="">"local"</span>).toString();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path.stop();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!importTrackerId)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;importTrackerId&nbsp;=&nbsp;addDefault(programPath,&nbsp;trackPath,&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>nameHint</span>:&nbsp;programPath.scope.generateUid(<span data-darkreader-inline-color="">"tracker"</span>),<br>&nbsp;&nbsp;&nbsp;&nbsp;}).name;<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;importTrackerId;<br>};<br><br><span data-darkreader-inline-color="">module</span>.exports&nbsp;=&nbsp;declare(<span>(<span>api,&nbsp;options</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">"babel-plugin-tracker-comment"</span>);<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span>visitor</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"ArrowFunctionExpression|FunctionDeclaration|FunctionExpression"</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enter(path,&nbsp;state)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;nodeComments&nbsp;=&nbsp;path;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(path.isExpression())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodeComments&nbsp;=&nbsp;path.parentPath.parentPath;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;获取leadingComments</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;leadingComments&nbsp;=&nbsp;nodeComments.get(<span data-darkreader-inline-color="">"leadingComments"</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;paramCommentPath&nbsp;=&nbsp;hasTrackerComments(leadingComments,options.commentsTrack);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//查看作用域中是否有——trackerParam</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果有注释，就插入函数</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(paramCommentPath)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//add&nbsp;Import</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;programPath&nbsp;=&nbsp;path.hub.file.path;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;importId&nbsp;=&nbsp;checkImport(programPath,&nbsp;options.trackerPath);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state.importTackerId&nbsp;=&nbsp;importId;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insertTracker(path,&nbsp;state);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;};<br>});<br>
```

在获取注释的时候，代码中并不是直接获取到`path`的`leadingComments`，这是为什么？  
比如这串代码：

```
<span data-darkreader-inline-color="">//_tracker</span><br><span data-darkreader-inline-color="">const</span>&nbsp;test1&nbsp;=&nbsp;<span><span>()</span>&nbsp;=&gt;</span>&nbsp;{};<br>
```

我们在函数中遍历得到的path是`()=>{}`ast的path，这个path的`leadingComments`其实是`null`，而想要获取`//_tracker`，我们真正需要拿到的path，是注释下面的`变量声明语句`。所以在代码中有判断是否为表达式，如果是，那就需要先`parentPath`，得到`赋值表达式`的`path`，然后在`parentPath`，才能拿到`变量声明语句`

## 运行代码

```
node&nbsp;index.js<br>
```

得到输出：  
![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

## 总结

这篇文章写了如何根据函数上方的注释，选择性的给函数埋点。过程详尽，例子通俗易懂，真是不可多得的一篇好文章啊  
有任何问题，欢迎金友们留言评论哦～

> 相关文章：
> 
> 1.  通过工具babel，给函数都添加埋点<sup data-darkreader-inline-color="">[4]</sup>
>     
> 2.  通过工具babel，给埋点函数传递参数<sup data-darkreader-inline-color="">[5]</sup>
>     

> 作者：慢功夫
> 
> 链接：https://juejin.cn/post/7253744712409088057

加我微信，拉你进前端进阶、面试交流群，互相监督学习进步等！

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

### 推荐链接

-   [TypeScript中 interface 和 type 的区别，你真的懂了吗](http://mp.weixin.qq.com/s?__biz=MzkyOTE5NzQ2Nw==&mid=2247485013&idx=1&sn=9324e663eb2d6ed02a2f167e12b56692&chksm=c20c7aa1f57bf3b7f7e00ecc07d753a201ea08da5ad083dc5f70adc8553ef731f9e295afe8a2&scene=21#wechat_redirect)？
    
-   [2022年，前端er们都在看哪些网站？](http://mp.weixin.qq.com/s?__biz=MzkyOTE5NzQ2Nw==&mid=2247485101&idx=1&sn=09322752bb7e63dea5286f9a0c51164a&chksm=c20c7a59f57bf34f2142aef77367ec01e1cd2471637920f48f53552eafcca8b35f93625eaec9&scene=21#wechat_redirect)
    
-   [良心提醒：这些你常用的vscode 扩展，应该卸载啦!](http://mp.weixin.qq.com/s?__biz=MzkyOTE5NzQ2Nw==&mid=2247487807&idx=1&sn=272daf982b072f39d882d85577d5f398&chksm=c20c6dcbf57be4dd9a53642843a41ba179b8d8789e7ac1c3182cf35bbf2a0642f81f8f2b7eea&scene=21#wechat_redirect)
    
-   [百度一面，手写 EventBus 直接被三连问，来看看最优解](http://mp.weixin.qq.com/s?__biz=MzkyOTE5NzQ2Nw==&mid=2247488056&idx=1&sn=b09e4e666b19b20d93f5e02a28363ad7&chksm=c20c6eccf57be7dae02650c4a85abebf3b5def85e3c8951ab1b9b33809fe0ef7659632980c20&scene=21#wechat_redirect)
    
-   [线上紧急Bug：80%你可能会遇到的数据精度问题](http://mp.weixin.qq.com/s?__biz=MzkyOTE5NzQ2Nw==&mid=2247487908&idx=1&sn=a85832bb76575a59721c5138ab93916e&chksm=c20c6d50f57be446ad1054c79064c76b87923754dcf2a3e8d186c7dc63cc8d78625c019364ab&scene=21#wechat_redirect)
    

创作不易，加个点赞、在看 支持一下哦！