关注公众号 前端界，回复“加群”

加入我们一起学习，天天进步

## 背景

**随着SPA大规模的应用，紧接着就带来一个新问题：一个规模化应用需要拆分。**

一方面功能快速增加导致打包时间成比例上升，而紧急发布时要求是越短越好，这是矛盾的。另一方面当一个代码库集成了所有功能时，日常协作绝对是非常困难的。而且最近十多年，前端技术的发展是非常快的，每隔两年就是一个时代，导致同志们必须升级项目甚至于换一个框架。但如果大家想在一个规模化应用中一个版本做好这件事，基本上是不可能的。

最早的解决方案是采用iframe的方法，根据功能主要模块拆分规模化应用，子应用之间使用跳转。但这个方案最大问题是导致页面重新加载和白屏。

那有什么好的解决方案呢？微前端这样具有跨应用的解决方案在此背景下应运而生了！

## 微前端的概念

微前端是什么：微前端是一种类似于微服务的架构，是一种由独立交付的多个前端应用组成整体的架构风格，将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的应用，而在用户看来仍然是内聚的单个产品。有一个**基座应用**（主应用），来管理各个**子应用**的加载和卸载。

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

f135ab0912746bd6.png

所以微前端不是指具体的库，不是指具体的框架，不是指具体的工具，而是一种理想与架构模式。

微前端的核心三大原则就是：**独立运行、独立部署、独立开发**

### 微前端的优势

采用微前端架构的好处就是，将这些小型应用融合为一个完整的应用，或者将原本运行已久、没有关联的几个应用融合为一个应用可以将多个项目融合为一，又可以减少项目之间的耦合，提升项目扩展性。

### 实现微前端的几种方式

-   从**single-spa**到**qiankun**
    
-   基于WebComponent的**micro-app**
    
-   webpack5实现的**Module Federation**
    

## 微前端框架的分类

### Single-spa

`single-spa`是一个很好的微前端基础框架，而`qiankun`框架就是基于`single-spa`来实现的，在`single-spa`的基础上做了一层封装，也解决了`single-spa`的一些缺陷。

首先我们先来了解该如何使用`single-spa`来完成微前端的搭建。

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

single-spa.jpg

#### **Single-spa实现原理**

首先在基座应用中注册所有App的路由，`single-spa`保存各子应用的路由映射关系，充当微前端控制器**Controler**，。URL响应时，匹配子应用路由并加载渲染子应用。上图便是对`single-spa`完整的描述。

有了理论基础，接下来，我们来看看代码层面时如何使用的。

以下以Vue工程为例基座构建single-spa,在Vue工程入口文件main.js完成基座的配置。

#### 基座配置

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">//main.js</span><br><span data-darkreader-inline-color="">import</span>&nbsp;Vue&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">'vue'</span><br><span data-darkreader-inline-color="">import</span>&nbsp;App&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">'./App.vue'</span><br><span data-darkreader-inline-color="">import</span>&nbsp;router&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">'./router'</span><br><span data-darkreader-inline-color="">import</span>&nbsp;{&nbsp;registerApplication,&nbsp;start&nbsp;}&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">'single-spa'</span><br><br>Vue.config.productionTip&nbsp;=&nbsp;<span data-darkreader-inline-color="">false</span><br><br><span data-darkreader-inline-color="">const</span>&nbsp;mountApp&nbsp;=&nbsp;<span>(<span>url</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Promise</span>(<span>(<span>resolve,&nbsp;reject</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;script&nbsp;=&nbsp;<span data-darkreader-inline-color="">document</span>.createElement(<span data-darkreader-inline-color="">'script'</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;script.src&nbsp;=&nbsp;url<br><br>&nbsp;&nbsp;&nbsp;&nbsp;script.onload&nbsp;=&nbsp;resolve<br>&nbsp;&nbsp;&nbsp;&nbsp;script.onerror&nbsp;=&nbsp;reject<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;通过插入script标签的方式挂载子应用</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;firstScript&nbsp;=&nbsp;<span data-darkreader-inline-color="">document</span>.getElementsByTagName(<span data-darkreader-inline-color="">'script'</span>)[<span data-darkreader-inline-color="">0</span>]<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;挂载子应用</span><br>&nbsp;&nbsp;&nbsp;&nbsp;firstScript.parentNode.insertBefore(script,&nbsp;firstScript)<br>&nbsp;&nbsp;})<br>}<br><br><span data-darkreader-inline-color="">const</span>&nbsp;loadApp&nbsp;=&nbsp;<span>(<span>appRouter,&nbsp;appName</span>)&nbsp;=&gt;</span>&nbsp;{<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;远程加载子应用</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">async</span>&nbsp;()&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//手动挂载子应用</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">await</span>&nbsp;mountApp(appRouter&nbsp;+&nbsp;<span data-darkreader-inline-color="">'/js/chunk-vendors.js'</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">await</span>&nbsp;mountApp(appRouter&nbsp;+&nbsp;<span data-darkreader-inline-color="">'/js/app.js'</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;获取子应用生命周期函数</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">window</span>[appName]<br>&nbsp;&nbsp;}<br>}<br><br><span data-darkreader-inline-color="">//&nbsp;子应用列表</span><br><span data-darkreader-inline-color="">const</span>&nbsp;appList&nbsp;=&nbsp;[<br>&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;子应用名称</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>name</span>:&nbsp;<span data-darkreader-inline-color="">'app1'</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;挂载子应用</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>app</span>:&nbsp;loadApp(<span data-darkreader-inline-color="">'http://localhost:8083'</span>,&nbsp;<span data-darkreader-inline-color="">'app1'</span>),<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;匹配该子路由的条件</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>activeWhen</span>:&nbsp;<span><span>location</span>&nbsp;=&gt;</span>&nbsp;location.pathname.startsWith(<span data-darkreader-inline-color="">'/app1'</span>),<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;传递给子应用的对象</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>customProps</span>:&nbsp;{}<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span>name</span>:&nbsp;<span data-darkreader-inline-color="">'app2'</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span>app</span>:&nbsp;loadApp(<span data-darkreader-inline-color="">'http://localhost:8082'</span>,&nbsp;<span data-darkreader-inline-color="">'app2'</span>),<br>&nbsp;&nbsp;&nbsp;&nbsp;<span>activeWhen</span>:&nbsp;<span><span>location</span>&nbsp;=&gt;</span>&nbsp;location.pathname.startsWith(<span data-darkreader-inline-color="">'/app2'</span>),<br>&nbsp;&nbsp;&nbsp;&nbsp;<span>customProps</span>:&nbsp;{}<br>&nbsp;&nbsp;}<br>]<br><br><span data-darkreader-inline-color="">//&nbsp;注册子应用</span><br>appList.map(<span><span>item</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;registerApplication(item)<br>})<br>&nbsp;<br><span data-darkreader-inline-color="">//&nbsp;注册路由并启动基座</span><br><span data-darkreader-inline-color="">new</span>&nbsp;Vue({<br>&nbsp;&nbsp;router,<br>&nbsp;&nbsp;mounted()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;start()<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;<span>render</span>:&nbsp;<span><span>h</span>&nbsp;=&gt;</span>&nbsp;h(App)<br>}).$mount(<span data-darkreader-inline-color="">'#app'</span>)<br><br><br>复制代码<br></code>
```

构建基座的核心是：配置子应用信息，通过**registerApplication**注册子应用，在基座工程挂载阶段**start**启动基座。

#### **子应用配置**

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">import</span>&nbsp;Vue&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">'vue'</span><br><span data-darkreader-inline-color="">import</span>&nbsp;App&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">'./App.vue'</span><br><span data-darkreader-inline-color="">import</span>&nbsp;router&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">'./router'</span><br><span data-darkreader-inline-color="">import</span>&nbsp;singleSpaVue&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">'single-spa-vue'</span><br><br>Vue.config.productionTip&nbsp;=&nbsp;<span data-darkreader-inline-color="">false</span><br><br><span data-darkreader-inline-color="">const</span>&nbsp;appOptions&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span>el</span>:&nbsp;<span data-darkreader-inline-color="">'#microApp'</span>,<br>&nbsp;&nbsp;router,<br>&nbsp;&nbsp;<span>render</span>:&nbsp;<span><span>h</span>&nbsp;=&gt;</span>&nbsp;h(App)<br>}<br><br><span data-darkreader-inline-color="">//&nbsp;支持应用独立运行、部署，不依赖于基座应用</span><br><span data-darkreader-inline-color="">//&nbsp;如果不是微应用环境，即启动自身挂载的方式</span><br><span data-darkreader-inline-color="">if</span>&nbsp;(!process.env.isMicro)&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">delete</span>&nbsp;appOptions.el<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Vue(appOptions).$mount(<span data-darkreader-inline-color="">'#app'</span>)<br>}<br><span data-darkreader-inline-color="">//&nbsp;基于基座应用，导出生命周期函数</span><br><span data-darkreader-inline-color="">const</span>&nbsp;appLifecycle&nbsp;=&nbsp;singleSpaVue({<br>&nbsp;&nbsp;Vue,<br>&nbsp;&nbsp;appOptions<br>})<br><br><span data-darkreader-inline-color="">//&nbsp;抛出子应用生命周期</span><br><span data-darkreader-inline-color="">//&nbsp;启动生命周期函数</span><br><span data-darkreader-inline-color="">export</span>&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;bootstrap&nbsp;=&nbsp;<span>(<span>props</span>)&nbsp;&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">'app2&nbsp;bootstrap'</span>)<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;appLifecycle.bootstrap(<span><span>()</span>&nbsp;=&gt;</span>&nbsp;{&nbsp;})<br>}<br><span data-darkreader-inline-color="">//&nbsp;挂载生命周期函数</span><br><span data-darkreader-inline-color="">export</span>&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;mount&nbsp;=&nbsp;<span>(<span>props</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">'app2&nbsp;mount'</span>)<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;appLifecycle.mount(<span><span>()</span>&nbsp;=&gt;</span>&nbsp;{&nbsp;})<br>}<br><span data-darkreader-inline-color="">//&nbsp;卸载生命周期函数</span><br><span data-darkreader-inline-color="">export</span>&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;unmount&nbsp;=&nbsp;<span>(<span>props</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">'app2&nbsp;unmount'</span>)<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;appLifecycle.unmount(<span><span>()</span>&nbsp;=&gt;</span>&nbsp;{&nbsp;})<br>}<br><br>复制代码<br></code>
```

配置子应用为umd打包方式

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">//vue.config.js</span><br><span data-darkreader-inline-color="">const</span>&nbsp;package&nbsp;=&nbsp;<span data-darkreader-inline-color="">require</span>(<span data-darkreader-inline-color="">'./package.json'</span>)<br><span data-darkreader-inline-color="">module</span>.exports&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;告诉子应用在这个地址加载静态资源，否则会去基座应用的域名下加载</span><br>&nbsp;&nbsp;<span>publicPath</span>:&nbsp;<span data-darkreader-inline-color="">'//localhost:8082'</span>,<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;开发服务器</span><br>&nbsp;&nbsp;<span>devServer</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span>port</span>:&nbsp;<span data-darkreader-inline-color="">8082</span><br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;<span>configureWebpack</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;导出umd格式的包，在全局对象上挂载属性package.name，基座应用需要通过这个</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;全局对象获取一些信息，比如子应用导出的生命周期函数</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>output</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;library的值在所有子应用中需要唯一</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>library</span>:&nbsp;package.name,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>libraryTarget</span>:&nbsp;<span data-darkreader-inline-color="">'umd'</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br><br>复制代码<br></code>
```

配置子应用环境变量

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">//&nbsp;.env.micro&nbsp;</span><br>NODE_ENV=development<br>VUE_APP_BASE_URL=<span data-darkreader-inline-color="">/app2<br>isMicro=true<br>复制代码<br></span></code>
```

子应用配置的核心是用singleSpaVue生成子路由配置后，**必须要抛出其生命周期函数**。

用以上方式便可轻松实现一个简单的微前端应用了。

**那么我们有`single-spa`这种微前端解决方案，为什么还需要`qiankun`呢？**

相比于`single-spa`，`qiankun`他解决了JS沙盒环境，不需要我们自己去进行处理。在`single-spa`的开发过程中，我们需要自己手动的去写调用子应用JS的方法（如上面的 createScript方法），而`qiankun`不需要，乾坤只需要你传入响应的apps的配置即可，会帮助我们去加载。

### Qiankun

#### Qiankun的优势

-   **基于 single-spa<sup data-darkreader-inline-color="">[1]</sup>** 封装，提供了更加开箱即用的 API。
    
-   **技术栈无关**，任意技术栈的应用均可 使用/接入，不论是 React/Vue/Angular/JQuery 还是其他等框架。
    
-   **HTML Entry 接入方式**，让你接入微应用像使用 iframe 一样简单。
    
-   **样式隔离**，确保微应用之间样式互相不干扰。
    
-   **JS 沙箱**，确保微应用之间 全局变量/事件 不冲突。
    
-   **资源预加载**，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度。
    

#### 基座配置

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">import&nbsp;{&nbsp;registerMicroApps,&nbsp;start&nbsp;}&nbsp;from&nbsp;<span data-darkreader-inline-color="">'qiankun'</span>;<br><br><br>registerMicroApps([<br>&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;<span data-darkreader-inline-color="">'reactApp'</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;entry:&nbsp;<span data-darkreader-inline-color="">'//localhost:3000'</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;container:&nbsp;<span data-darkreader-inline-color="">'#container'</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;activeRule:&nbsp;<span data-darkreader-inline-color="">'/app-react'</span>,<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;<span data-darkreader-inline-color="">'vueApp'</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;entry:&nbsp;<span data-darkreader-inline-color="">'//localhost:8080'</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;container:&nbsp;<span data-darkreader-inline-color="">'#container'</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;activeRule:&nbsp;<span data-darkreader-inline-color="">'/app-vue'</span>,<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;<span data-darkreader-inline-color="">'angularApp'</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;entry:&nbsp;<span data-darkreader-inline-color="">'//localhost:4200'</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;container:&nbsp;<span data-darkreader-inline-color="">'#container'</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;activeRule:&nbsp;<span data-darkreader-inline-color="">'/app-angular'</span>,<br>&nbsp;&nbsp;},<br>]);<br>//&nbsp;启动&nbsp;qiankun<br>start();<br>复制代码<br></code>
```

#### 子应用配置

以 `create react app` 生成的 `react 16` 项目为例，搭配 `react-router-dom` 5.x。

1.在 `src` 目录新增 `public-path.js`，解决子应用挂载时，访问静态资源冲突

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(window.__POWERED_BY_QIANKUN__)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;__webpack_public_path__&nbsp;=&nbsp;window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;<br>&nbsp;&nbsp;}<br>复制代码<br></code>
```

2.设置 `history` 模式路由的 `base`：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">&nbsp;&nbsp;&lt;BrowserRouter&nbsp;basename={window.__POWERED_BY_QIANKUN__&nbsp;?&nbsp;<span data-darkreader-inline-color="">'/app-react'</span>&nbsp;:&nbsp;<span data-darkreader-inline-color="">'/'</span>}&gt;<br>复制代码<br></code>
```

3.入口文件 `index.js` 修改，为了避免根 id `#root` 与其他的 DOM 冲突，需要限制查找范围。

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">&nbsp;&nbsp;import&nbsp;<span data-darkreader-inline-color="">'./public-path'</span>;<br>&nbsp;&nbsp;import&nbsp;React&nbsp;from&nbsp;<span data-darkreader-inline-color="">'react'</span>;<br>&nbsp;&nbsp;import&nbsp;ReactDOM&nbsp;from&nbsp;<span data-darkreader-inline-color="">'react-dom'</span>;<br>&nbsp;&nbsp;import&nbsp;App&nbsp;from&nbsp;<span data-darkreader-inline-color="">'./App'</span>;<br><br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">function</span>&nbsp;render(props)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;{&nbsp;container&nbsp;}&nbsp;=&nbsp;props;<br>&nbsp;&nbsp;&nbsp;&nbsp;ReactDOM.render(&lt;App&nbsp;/&gt;,&nbsp;container&nbsp;?&nbsp;container.querySelector(<span data-darkreader-inline-color="">'#root'</span>)&nbsp;:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;document.querySelector(<span data-darkreader-inline-color="">'#root'</span>));<br>&nbsp;&nbsp;}<br><br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!window.__POWERED_BY_QIANKUN__)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;render({});<br>&nbsp;&nbsp;}<br><br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">export</span>&nbsp;async&nbsp;<span data-darkreader-inline-color="">function</span>&nbsp;<span><span data-darkreader-inline-color="">bootstrap</span></span>()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(<span data-darkreader-inline-color="">'[react16]&nbsp;react&nbsp;app&nbsp;bootstraped'</span>);<br>&nbsp;&nbsp;}<br><br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">export</span>&nbsp;async&nbsp;<span data-darkreader-inline-color="">function</span>&nbsp;mount(props)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(<span data-darkreader-inline-color="">'[react16]&nbsp;props&nbsp;from&nbsp;main&nbsp;framework'</span>,&nbsp;props);<br>&nbsp;&nbsp;&nbsp;&nbsp;render(props);<br>&nbsp;&nbsp;}<br><br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">export</span>&nbsp;async&nbsp;<span data-darkreader-inline-color="">function</span>&nbsp;unmount(props)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;{&nbsp;container&nbsp;}&nbsp;=&nbsp;props;<br>&nbsp;&nbsp;&nbsp;&nbsp;ReactDOM.unmountComponentAtNode(container&nbsp;?&nbsp;container.querySelector(<span data-darkreader-inline-color="">'#root'</span>)&nbsp;:&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;document.querySelector(<span data-darkreader-inline-color="">'#root'</span>));<br>&nbsp;&nbsp;}<br>复制代码<br></code>
```

4.修改 `webpack` 配置

安装插件 `@rescripts/cli`，当然也可以选择其他的插件，例如 `react-app-rewired`。

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">npm&nbsp;i&nbsp;-D&nbsp;@rescripts/cli<br>复制代码<br></code>
```

根目录新增 `.rescriptsrc.js`：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">const&nbsp;{&nbsp;name&nbsp;}&nbsp;=&nbsp;require(<span data-darkreader-inline-color="">'./package'</span>);<br><br><br>module.exports&nbsp;=&nbsp;{<br>&nbsp;&nbsp;webpack:&nbsp;(config)&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;config.output.library&nbsp;=&nbsp;`<span data-darkreader-inline-color="">${name}</span>-[name]`;<br>&nbsp;&nbsp;&nbsp;&nbsp;config.output.libraryTarget&nbsp;=&nbsp;<span data-darkreader-inline-color="">'umd'</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;config.output.jsonpFunction&nbsp;=&nbsp;`webpackJsonp_<span data-darkreader-inline-color="">${name}</span>`;<br>&nbsp;&nbsp;&nbsp;&nbsp;config.output.globalObject&nbsp;=&nbsp;<span data-darkreader-inline-color="">'window'</span>;<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;config;<br>&nbsp;&nbsp;},<br><br><br>&nbsp;&nbsp;devServer:&nbsp;(_)&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;config&nbsp;=&nbsp;_;<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;config.headers&nbsp;=&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">'Access-Control-Allow-Origin'</span>:&nbsp;<span data-darkreader-inline-color="">'*'</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;config.historyApiFallback&nbsp;=&nbsp;<span data-darkreader-inline-color="">true</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;config.hot&nbsp;=&nbsp;<span data-darkreader-inline-color="">false</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;config.watchContentBase&nbsp;=&nbsp;<span data-darkreader-inline-color="">false</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;config.liveReload&nbsp;=&nbsp;<span data-darkreader-inline-color="">false</span>;<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;config;<br>&nbsp;&nbsp;},<br>};<br>复制代码<br></code>
```

以上对Qiankun的使用可以看出，与single-spa使用过程很相似。不同的是，Qiankun的使用过程更简便了。一些内置的操作交由给Qiankun内部实现。**这是一种IOC思想的实现**，我们只管面向容器化开发，其他操作交给Qiankun框架管理。

### Micro-app

`micro-app`并没有沿袭`single-spa`的思路，而是借鉴了WebComponent的思想，通过CustomElement结合自定义的ShadowDom，将微前端封装成一个类WebComponent组件，从而实现微前端的组件化渲染。并且由于自定义ShadowDom的隔离特性，`micro-app`不需要像`single-spa`和`qiankun`一样要求子应用修改渲染逻辑并暴露出方法，也不需要修改webpack配置，是目前市面上接入微前端成本最低的方案。

#### WebComponent的概念

\*\*WebComponent\*\*<sup data-darkreader-inline-color="">[2]</sup>是HTML5提供的一套自定义元素的接口，\*\*WebComponent\*\*<sup data-darkreader-inline-color="">[3]</sup>是一套不同的技术，允许您创建可重用的定制元素（它们的功能封装在您的代码之外）并且在您的 web 应用中使用它们。以上是MDN社区对WebComponent的解释。

-   **Custom elements（自定义元素）：** 一组 JavaScript API，允许您定义 custom elements 及其行为，然后可以在您的用户界面中按照需要使用它们。
    
-   **Shadow DOM（影子 DOM）** ：一组 JavaScript API，用于将封装的“影子”DOM 树附加到元素（与主文档 DOM 分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。
    
-   **HTML templates（HTML 模板）：**  `<template>` 和 `<slot>` 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。
    

**接下来用一个小例子更快来理解WebComponent的概念。**

一个存在组件内交互的WebComponent

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">//&nbsp;基于HTMLElement自定义组件元素</span><br><span><span data-darkreader-inline-color="">class</span>&nbsp;<span data-darkreader-inline-color="">CounterElement</span>&nbsp;<span data-darkreader-inline-color="">extends</span>&nbsp;<span data-darkreader-inline-color="">HTMLElement</span>&nbsp;</span>{<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;在构造器中生成shadow节点</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">constructor</span>()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">super</span>();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.counter&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;打开影子节点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;影子节点是为了隔离外部元素的影响</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;shadowRoot&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span>.attachShadow({&nbsp;<span>mode</span>:&nbsp;<span data-darkreader-inline-color="">'open'</span>&nbsp;});<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;定义组件内嵌样式</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;styles&nbsp;=&nbsp;<span data-darkreader-inline-color="">`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#counter-increment&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;60px;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height:&nbsp;30px;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;margin:&nbsp;20px;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;background:&nbsp;none;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;border:&nbsp;1px&nbsp;solid&nbsp;black;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`</span>;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;定义组件HTMl结构</span><br>&nbsp;&nbsp;&nbsp;&nbsp;shadowRoot.innerHTML&nbsp;=&nbsp;<span data-darkreader-inline-color="">`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;style&gt;<span data-darkreader-inline-color="">${styles}</span>&lt;/style&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h3&gt;Counter&lt;/h3&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&nbsp;name='counter-content'&gt;Button&lt;/slot&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;span id='counter-value'&gt;;&nbsp;0&nbsp;&lt;/span&gt;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button&nbsp;id='counter-increment'&gt;&nbsp;+&nbsp;&lt;/button&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`</span>;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;获取+号按钮及数值内容</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.incrementButton&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span>.shadowRoot.querySelector(<span data-darkreader-inline-color="">'#counter-increment'</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.counterValue&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span>.shadowRoot.querySelector(<span data-darkreader-inline-color="">'#counter-value'</span>);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;实现点击组件内事件驱动</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.incrementButton.addEventListener(<span data-darkreader-inline-color="">"click"</span>,&nbsp;<span data-darkreader-inline-color="">this</span>.decrement.bind(<span data-darkreader-inline-color="">this</span>));<br><br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;increment()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.counter++<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.updateValue();<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;替换counter节点内容，达到更新数值的效果</span><br>&nbsp;&nbsp;updateValue()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.counterValue.innerHTML&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span>.counter;<br>&nbsp;&nbsp;}<br>}<br><br><span data-darkreader-inline-color="">//&nbsp;在真实dom上，生成自定义组件元素</span><br>customElements.define(<span data-darkreader-inline-color="">'counter-element'</span>,&nbsp;CounterElement);<br><br>复制代码<br></code>
```

有了对WebComponent的理解，接下来，我们更明白了Micro-app的优势。

#### micro-app的优势

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

d879637b4bb34253.png

-   使用简单
    
    我们将所有功能都封装到一个类WebComponent组件中，从而实现在基座应用中嵌入一行代码即可渲染一个微前端应用。
    
    同时`micro-app`还提供了`js沙箱`、`样式隔离`、`元素隔离`、`预加载`、`数据通信`、`静态资源补全`等一系列完善的功能。
    
-   零依赖
    
    `micro-app`没有任何依赖，这赋予它小巧的体积和更高的扩展性。
    
-   兼容所有框架
    
    为了保证各个业务之间独立开发、独立部署的能力，`micro-app`做了诸多兼容，在任何技术框架中都可以正常运行。
    

#### 基座的简易配置

基座存在预加载子应用、父子应用通信、公共文件共享等等

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><br><span data-darkreader-inline-color="">//&nbsp;index.js</span><br><span data-darkreader-inline-color="">import</span>&nbsp;React&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">"react"</span><br><span data-darkreader-inline-color="">import</span>&nbsp;ReactDOM&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">"react-dom"</span><br><span data-darkreader-inline-color="">import</span>&nbsp;App&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">'./App'</span><br><span data-darkreader-inline-color="">import</span>&nbsp;microApp&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">'@micro-zoe/micro-app'</span><br><br><span data-darkreader-inline-color="">const</span>&nbsp;appName&nbsp;=&nbsp;<span data-darkreader-inline-color="">'my-app'</span><br><br><span data-darkreader-inline-color="">//&nbsp;预加载</span><br>microApp.preFetch([<br>&nbsp;&nbsp;{&nbsp;<span>name</span>:&nbsp;appName,&nbsp;<span>url</span>:&nbsp;<span data-darkreader-inline-color="">'xxx'</span>&nbsp;}<br>])<br><br><span data-darkreader-inline-color="">//&nbsp;基座向子应用数据通信</span><br>microApp.setData(appName,&nbsp;{&nbsp;<span>type</span>:&nbsp;<span data-darkreader-inline-color="">'新的数据'</span>&nbsp;})<br><span data-darkreader-inline-color="">//&nbsp;获取指定子应用数据</span><br><span data-darkreader-inline-color="">const</span>&nbsp;childData&nbsp;=&nbsp;microApp.getData(appName)<br><br>microApp.start({<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;公共文件共享</span><br>&nbsp;&nbsp;<span>globalAssets</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span>js</span>:&nbsp;[<span data-darkreader-inline-color="">'js地址1'</span>,&nbsp;<span data-darkreader-inline-color="">'js地址2'</span>,&nbsp;...],&nbsp;<span data-darkreader-inline-color="">//&nbsp;js地址</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>css</span>:&nbsp;[<span data-darkreader-inline-color="">'css地址1'</span>,&nbsp;<span data-darkreader-inline-color="">'css地址2'</span>,&nbsp;...],&nbsp;<span data-darkreader-inline-color="">//&nbsp;css地址</span><br>&nbsp;&nbsp;}<br>})<br>复制代码<br></code>
```

分配一个路由给子应用

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">//&nbsp;router.js</span><br><span data-darkreader-inline-color="">import</span>&nbsp;{&nbsp;BrowserRouter,&nbsp;Switch,&nbsp;Route&nbsp;}&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">'react-router-dom'</span><br><br><span data-darkreader-inline-color="">export</span>&nbsp;<span data-darkreader-inline-color="">default</span>&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">AppRoute</span>&nbsp;(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;(<br>&nbsp;&nbsp;&nbsp;&nbsp;<span><span data-darkreader-inline-color="">&lt;<span data-darkreader-inline-color="">BrowserRouter</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">&lt;<span data-darkreader-inline-color="">Switch</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">&lt;<span data-darkreader-inline-color="">Route</span>&nbsp;<span data-darkreader-inline-color="">path</span>=<span data-darkreader-inline-color="">'/'</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">&lt;<span data-darkreader-inline-color="">micro-app</span>&nbsp;<span data-darkreader-inline-color="">name</span>=<span data-darkreader-inline-color="">'app1'</span>&nbsp;<span data-darkreader-inline-color="">url</span>=<span data-darkreader-inline-color="">'http://localhost:3000/'</span>&nbsp;<span data-darkreader-inline-color="">baseroute</span>=<span data-darkreader-inline-color="">'/'</span>&gt;</span><span data-darkreader-inline-color="">&lt;/<span data-darkreader-inline-color="">micro-app</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">&lt;/<span data-darkreader-inline-color="">Route</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">&lt;/<span data-darkreader-inline-color="">Switch</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">&lt;/<span data-darkreader-inline-color="">BrowserRouter</span>&gt;</span></span><br>&nbsp;&nbsp;)<br>}<br><br>复制代码<br></code>
```

#### 子应用的简易配置

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">//&nbsp;index.js</span><br><span data-darkreader-inline-color="">import</span>&nbsp;React&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">"react"</span><br><span data-darkreader-inline-color="">import</span>&nbsp;ReactDOM&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">"react-dom"</span><br><span data-darkreader-inline-color="">import</span>&nbsp;App&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">'./App'</span><br><span data-darkreader-inline-color="">import</span>&nbsp;microApp&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">'@micro-zoe/micro-app'</span><br><br><span data-darkreader-inline-color="">const</span>&nbsp;appName&nbsp;=&nbsp;<span data-darkreader-inline-color="">'my-app'</span><br><br><span data-darkreader-inline-color="">//&nbsp;子应用运行时，切换静态资源访问路径</span><br><span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">window</span>.__MICRO_APP_ENVIRONMENT__)&nbsp;{<br>&nbsp;&nbsp;__webpack_public_path__&nbsp;=&nbsp;<span data-darkreader-inline-color="">window</span>.__MICRO_APP_PUBLIC_PATH__<br>}<br><br><span data-darkreader-inline-color="">//&nbsp;基子应用向基座发送数据</span><br><span data-darkreader-inline-color="">//&nbsp;dispatch只接受对象作为参数</span><br><span data-darkreader-inline-color="">window</span>.microApp.dispatch({&nbsp;<span>type</span>:&nbsp;<span data-darkreader-inline-color="">'子应用发送的数据'</span>&nbsp;})<br><span data-darkreader-inline-color="">//&nbsp;获取基座数据</span><br><span data-darkreader-inline-color="">const</span>&nbsp;data&nbsp;=&nbsp;<span data-darkreader-inline-color="">window</span>.microApp.getData()&nbsp;<span data-darkreader-inline-color="">//&nbsp;返回基座下发的data数据</span><br><br><span data-darkreader-inline-color="">//性能优化，umd模式</span><br><span data-darkreader-inline-color="">//&nbsp;如果子应用渲染和卸载不频繁，那么使用默认模式即可，如果子应用渲染和卸载非常频繁建议使用umd模式</span><br><span data-darkreader-inline-color="">//&nbsp;将渲染操作放入&nbsp;mount&nbsp;函数&nbsp;--&nbsp;必填</span><br><span data-darkreader-inline-color="">export</span>&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">mount</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;ReactDOM.render(<span><span data-darkreader-inline-color="">&lt;<span data-darkreader-inline-color="">App</span>&nbsp;/&gt;</span></span>,&nbsp;<span data-darkreader-inline-color="">document</span>.getElementById(<span data-darkreader-inline-color="">"root"</span>))<br>}<br><br><span data-darkreader-inline-color="">//&nbsp;将卸载操作放入&nbsp;unmount&nbsp;函数&nbsp;--&nbsp;必填</span><br><span data-darkreader-inline-color="">export</span>&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">unmount</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;ReactDOM.unmountComponentAtNode(<span data-darkreader-inline-color="">document</span>.getElementById(<span data-darkreader-inline-color="">"root"</span>))<br>}<br><br><span data-darkreader-inline-color="">//&nbsp;微前端环境下，注册mount和unmount方法</span><br><span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">window</span>.__MICRO_APP_ENVIRONMENT__)&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">window</span>[<span data-darkreader-inline-color="">`micro-app-<span data-darkreader-inline-color="">${<span data-darkreader-inline-color="">window</span>.__MICRO_APP_NAME__}</span>`</span>]&nbsp;=&nbsp;{&nbsp;mount,&nbsp;unmount&nbsp;}<br>}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;非微前端环境直接渲染</span><br>&nbsp;&nbsp;mount()<br>}<br><br>复制代码<br></code>
```

设置子应用路由

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">import</span>&nbsp;{&nbsp;BrowserRouter,&nbsp;Switch,&nbsp;Route&nbsp;}&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">'react-router-dom'</span><br><br><span data-darkreader-inline-color="">export</span>&nbsp;<span data-darkreader-inline-color="">default</span>&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">AppRoute</span>&nbsp;(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;(<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;设置基础路由，子应用可以通过window.__MICRO_APP_BASE_ROUTE__获取基座下发的baseroute，</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果没有设置baseroute属性，则此值默认为空字符串</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span><span data-darkreader-inline-color="">&lt;<span data-darkreader-inline-color="">BrowserRouter</span>&nbsp;<span data-darkreader-inline-color="">basename</span>=<span data-darkreader-inline-color="">{window.__MICRO_APP_BASE_ROUTE__</span>&nbsp;||&nbsp;'/'}&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">&lt;/<span data-darkreader-inline-color="">BrowserRouter</span>&gt;</span></span><br>&nbsp;&nbsp;)<br>}<br><br>复制代码<br></code>
```

以上便是Micro-app的用法

### Module Federation

Module Federation是Webpack5提出的概念，module federation用来解决多个应用之间**代码共享**的问题，让我们更加优雅的实现**跨应用**的代码共享。

**MF**想做的事和微前端想解决的问题是类似的，把一个应用进行拆分成多个应用，每个应用可独立开发，独立部署，一个应用可以**动态加载**并运行另一个应用的代码，并实现应用之间的**依赖共享。**

为了实现这样的功能， MF在设计上提出了这几个核心概念。

#### Container

一个被 ModuleFederationPlugin 打包出来的模块被称为 **Container**。通俗点讲就是，如果我们的一个应用使用了 ModuleFederationPlugin 构建，那么它就成为一个 **Container**，它可以加载其他的 **Container**，可以被其他的 **Container** 所加载。

#### Host&Remote

从消费者和生产者的角度看 **Container**，**Container** 又可被称作 **Host** 或 **Remote**。

`Host`：消费方，它动态加载并运行其他 Container 的代码。

`Remote`：提供方，它**暴露属性**（如组件、方法等）供 **Host** 使用

可以知道，这里的 **Host** 和 **Remote** 是相对的，因为 一个 **Container** 既可以作为 **Host**，也可以作为 **Remote**。

#### Shared

一个 **Container** 可以 **Shared** 它的依赖（如 react、react-dom）给其他 **Container** 使用，也就是共享依赖。

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

微信图片\_20220626184254.png

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

微信图片\_20220626184305.png

以上是webpack5与之前版本的模块管理对比图

#### 微应用配置

通过webpack5的配置达成微应用的效果

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">//&nbsp;配置webpack.config.js</span><br><span data-darkreader-inline-color="">const</span>&nbsp;{&nbsp;ModuleFederationPlugin&nbsp;}&nbsp;=&nbsp;<span data-darkreader-inline-color="">require</span>(<span data-darkreader-inline-color="">"webpack"</span>).container;<br><span data-darkreader-inline-color="">new</span>&nbsp;ModuleFederationPlugin({<br>&nbsp;&nbsp;<span>name</span>:&nbsp;<span data-darkreader-inline-color="">"appA"</span>,<br>&nbsp;<span data-darkreader-inline-color="">//出口文件</span><br>&nbsp;&nbsp;<span>filename</span>:&nbsp;<span data-darkreader-inline-color="">"remoteEntry.js"</span>,<br>&nbsp;<span data-darkreader-inline-color="">//暴露可访问的组件</span><br>&nbsp;&nbsp;<span>exposes</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"./input"</span>:&nbsp;<span data-darkreader-inline-color="">"./src/input"</span>,<br>&nbsp;&nbsp;},<br>&nbsp;<span data-darkreader-inline-color="">//或者其他模块的组件</span><br>&nbsp;<span data-darkreader-inline-color="">//如果把这一模块当作基座模块的话，</span><br>&nbsp;<span data-darkreader-inline-color="">//这里应该配置其他子应用模块的入口文件</span><br>&nbsp;&nbsp;<span>remotes</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span>appB</span>:&nbsp;<span data-darkreader-inline-color="">"appB@http://localhost:3002/remoteEntry.js"</span>,<br>&nbsp;&nbsp;},<br>&nbsp;<span data-darkreader-inline-color="">//共享依赖，其他模块不需要再次下载，便可使用</span><br>&nbsp;&nbsp;<span>shared</span>:&nbsp;[<span data-darkreader-inline-color="">'react'</span>,&nbsp;<span data-darkreader-inline-color="">'react-dom'</span>],<br>})<br><br>复制代码<br></code>
```

以上便是我对微应用架构的理解，以及微应用架构技术的演变过程。不难看出，这些技术的演变都朝着易用性和可拓展性的方向演进。其中技术也有其时代的局限性，不过思想和技术总是在不断进步的。这几类技术选型都有其优缺点，各有千秋，我们可以根据不同的需要选择不同的技术来构建应用。

_下列是本文写作时的参考资料：_

single-spa: zh-hans.single-spa.js.org/docs/gettin…<sup data-darkreader-inline-color="">[4]</sup>

qiankun: qiankun.umijs.org/zh/guide<sup data-darkreader-inline-color="">[5]</sup>

WebComponent: developer.mozilla.org/zh-CN/docs/…<sup data-darkreader-inline-color="">[6]</sup>

micro-app: cangdu.org/micro-app/d…<sup data-darkreader-inline-color="">[7]</sup>

### 参考资料

\[1\]

https://github.com/CanopyTax/single-spa

\[2\]

https://developer.mozilla.org/zh-CN/docs/Web/Web\_Components#%E4%BE%8B%E5%AD%90

\[3\]

https://developer.mozilla.org/zh-CN/docs/Web/Web\_Components#%E4%BE%8B%E5%AD%90

\[4\]

https://zh-hans.single-spa.js.org/docs/getting-started-overview

\[5\]

https://qiankun.umijs.org/zh/guide

\[6\]

https://developer.mozilla.org/zh-CN/docs/Web/Web\_Components

\[7\]

http://cangdu.org/micro-app/docs.html#/