缘起  

现在大厂面试中，算法题几乎为必考项，且近几年频现 LeetCode 真题，此篇为拿到字节、腾讯、京东 Offer 的笔者本人在准备面试过程中亲自刷过以及遇到过高频算法题。文章内容会分模块整理，对于笔者在面试过程中遇到的真题，会给予着重 【🔥】标出。

同时，可以毫不客气的说，如果你准备时间有限，又想追求算法题准备效率最大化，那么你只需要按照大纲把下面的题目刷完，并把代码烂熟于心，就几乎可以应对 90% 的面试算法考题了。

整理这篇内容的目的一个是笔者在之前准备面试时的一点积累，而它确实也帮助笔者在面试算法题中过关斩将，同时呢，也希望能够给予拼搏的你，一点点帮助就好！💪

本篇内容包括如下模块：

-   高频算法题系列：链表
    
-   【🔥】【有真题】高频算法题系列：字符串
    
-   【🔥】【有真题】高频算法题系列：数组问题
    
-   高频算法题系列：二叉树
    
-   【🔥】高频算法题系列：排序算法
    
-   【🔥】高频算法题系列：二分查找
    
-   【🔥】高频算法题系列：动态规划
    
-   高频算法题系列：BFS
    
-   【🔥】高频算法题系列：栈
    
-   【🔥】高频算法题系列：DFS
    
-   【🔥】高频算法题系列：回溯算法
    

其中标🔥的部分代表非常高频的考题，其中不乏笔者遇到的原题。其中对于每一类，首先会列出包含的考题，然后针对每一道考题会给出难度、考察知识点、是否是面试真题，在每道题详细介绍时，还会给出每道题的 LeetCode 链接，帮助读者理解题意，以及能够进行实际的测验，还可以观看其他人的答案，更好的帮助准备。

## 高频算法题系列：链表

笔者遇到的高频链表题主要包含这几道：

-   通过快慢指针寻找链表中点 【简单】
    
-   通过链表的后续遍历判断回文链表问题 【简单】
    
-   链表的反向输出 【简单】
    
-   合并 K 个升序链表 【困难】
    
-   K个一组翻转链表 【困难】
    
-   环形链表 【简单】
    
-   排序链表 【中等】
    
-   相交链表 【简单】
    

### 寻找链表中点

#### 题解

通过快慢指针寻找链表中点

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;*<br>&nbsp;&nbsp;*/</span><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">findCenter</span>(<span>head</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;slower&nbsp;=&nbsp;head,&nbsp;faster&nbsp;=&nbsp;head;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(faster&nbsp;&amp;&amp;&nbsp;faster.next&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slower&nbsp;=&nbsp;slower.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;faster&nbsp;=&nbsp;faster.next.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果&nbsp;faster&nbsp;不等于&nbsp;null，说明是奇数个，slower&nbsp;再移动一格</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(faster&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slower&nbsp;=&nbsp;slower.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;slower;<br>}<br></code>
```

### 前序遍历判断回文链表

👉 【LeetCode 直通车】：234 回文链表（简单）<sup data-darkreader-inline-color="">[1]</sup>

#### 题解1

利用链表的后续遍历，使用函数调用栈作为后序遍历栈，来判断是否回文

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;*<br>&nbsp;&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;isPalindrome&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>head</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;left&nbsp;=&nbsp;head;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">traverse</span>(<span>right</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(right&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">true</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;res&nbsp;=&nbsp;traverse(right.next);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;=&nbsp;res&nbsp;&amp;&amp;&nbsp;(right.val&nbsp;===&nbsp;left.val);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left&nbsp;=&nbsp;left.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;res;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;traverse(head);<br>};<br></code>
```

#### 题解2

通过 快、慢指针找链表中点，然后反转链表，比较两个链表两侧是否相等，来判断是否是回文链表

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;*<br>&nbsp;&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;isPalindrome&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>head</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;反转&nbsp;slower&nbsp;链表</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;right&nbsp;=&nbsp;reverse(findCenter(head));<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;left&nbsp;=&nbsp;head;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;开始比较</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(right&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(left.val&nbsp;!==&nbsp;right.val)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left&nbsp;=&nbsp;left.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right&nbsp;=&nbsp;right.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">true</span>;<br>}<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">findCenter</span>(<span>head</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;slower&nbsp;=&nbsp;head,&nbsp;faster&nbsp;=&nbsp;head;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(faster&nbsp;&amp;&amp;&nbsp;faster.next&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slower&nbsp;=&nbsp;slower.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;faster&nbsp;=&nbsp;faster.next.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果&nbsp;faster&nbsp;不等于&nbsp;null，说明是奇数个，slower&nbsp;再移动一格</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(faster&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slower&nbsp;=&nbsp;slower.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;slower;<br>}<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">reverse</span>(<span>head</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;prev&nbsp;=&nbsp;<span data-darkreader-inline-color="">null</span>,&nbsp;cur&nbsp;=&nbsp;head,&nbsp;nxt&nbsp;=&nbsp;head;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(cur&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nxt&nbsp;=&nbsp;cur.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cur.next&nbsp;=&nbsp;prev;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prev&nbsp;=&nbsp;cur;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cur&nbsp;=&nbsp;nxt;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;prev;<br>}<br></code>
```

### 反转链表

👉 【LeetCode 直通车】：206 反转链表（简单）<sup data-darkreader-inline-color="">[2]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;Definition&nbsp;for&nbsp;singly-linked&nbsp;list.<br>&nbsp;*&nbsp;function&nbsp;ListNode(val)&nbsp;{<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.val&nbsp;=&nbsp;val;<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.next&nbsp;=&nbsp;null;<br>&nbsp;*&nbsp;}<br>&nbsp;*/</span><br><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{ListNode}</span>&nbsp;<span data-darkreader-inline-color="">head</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{ListNode}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;reverseList&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>head</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(head&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>&nbsp;||&nbsp;head.next&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;head;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;last&nbsp;=&nbsp;reverseList(head.next);<br>&nbsp;&nbsp;&nbsp;&nbsp;head.next.next&nbsp;=&nbsp;head;<br>&nbsp;&nbsp;&nbsp;&nbsp;head.next&nbsp;=&nbsp;<span data-darkreader-inline-color="">null</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;last;<br>};<br></code>
```

### 合并K个升序链表

👉 【LeetCode 直通车】：23 合并K个升序链表（困难）<sup data-darkreader-inline-color="">[3]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;Definition&nbsp;for&nbsp;singly-linked&nbsp;list.<br>&nbsp;*&nbsp;function&nbsp;ListNode(val)&nbsp;{<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.val&nbsp;=&nbsp;val;<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.next&nbsp;=&nbsp;null;<br>&nbsp;*&nbsp;}<br>&nbsp;*/</span><br><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{ListNode[]}</span>&nbsp;<span data-darkreader-inline-color="">lists</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{ListNode}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;mergeKLists&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>lists</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(lists.length&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">null</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;mergeArr(lists);<br>};<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">mergeArr</span>(<span>lists</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(lists.length&nbsp;&lt;=&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;lists[<span data-darkreader-inline-color="">0</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;index&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.floor(lists.length&nbsp;/&nbsp;<span data-darkreader-inline-color="">2</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;left&nbsp;=&nbsp;mergeArr(lists.slice(<span data-darkreader-inline-color="">0</span>,&nbsp;index))<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;right&nbsp;=&nbsp;mergeArr(lists.slice(index));<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;merge(left,&nbsp;right);<br>}<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">merge</span>(<span>l1,&nbsp;l2</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(l1&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>&nbsp;&amp;&amp;&nbsp;l2&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">null</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(l1&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>&nbsp;&amp;&amp;&nbsp;l2&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;l1;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(l1&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>&nbsp;&amp;&amp;&nbsp;l2&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;l2;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;newHead&nbsp;=&nbsp;<span data-darkreader-inline-color="">null</span>,&nbsp;head&nbsp;=&nbsp;<span data-darkreader-inline-color="">null</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(l1&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>&nbsp;&amp;&amp;&nbsp;l2&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(l1.val&nbsp;&lt;&nbsp;l2.val)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!head)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newHead&nbsp;=&nbsp;l1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;head&nbsp;=&nbsp;l1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newHead.next&nbsp;=&nbsp;l1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newHead&nbsp;=&nbsp;newHead.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l1&nbsp;=&nbsp;l1.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!head)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newHead&nbsp;=&nbsp;l2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;head&nbsp;=&nbsp;l2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newHead.next&nbsp;=&nbsp;l2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newHead&nbsp;=&nbsp;newHead.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l2&nbsp;=&nbsp;l2.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;newHead.next&nbsp;=&nbsp;l1&nbsp;?&nbsp;l1&nbsp;:&nbsp;l2;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;head;<br>}<br></code>
```

### K 个一组翻转链表

👉 【LeetCode 直通车】：25 K 个一组翻转链表（困难）<sup data-darkreader-inline-color="">[4]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;Definition&nbsp;for&nbsp;singly-linked&nbsp;list.<br>&nbsp;*&nbsp;function&nbsp;ListNode(val)&nbsp;{<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.val&nbsp;=&nbsp;val;<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.next&nbsp;=&nbsp;null;<br>&nbsp;*&nbsp;}<br>&nbsp;*/</span><br><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{ListNode}</span>&nbsp;<span data-darkreader-inline-color="">head</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number}</span>&nbsp;<span data-darkreader-inline-color="">k</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{ListNode}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;reverseKGroup&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>head,&nbsp;k</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;a&nbsp;=&nbsp;head,&nbsp;b&nbsp;=&nbsp;head;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;k;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(b&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;head;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;b.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;newHead&nbsp;=&nbsp;reverse(a,&nbsp;b);<br>&nbsp;&nbsp;&nbsp;&nbsp;a.next&nbsp;=&nbsp;reverseKGroup(b,&nbsp;k);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;newHead;<br>};<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">reverse</span>(<span>a,&nbsp;b</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;prev&nbsp;=&nbsp;<span data-darkreader-inline-color="">null</span>,&nbsp;cur&nbsp;=&nbsp;a,&nbsp;nxt&nbsp;=&nbsp;a;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(cur&nbsp;!=&nbsp;b)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nxt&nbsp;=&nbsp;cur.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cur.next&nbsp;=&nbsp;prev;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prev&nbsp;=&nbsp;cur;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cur&nbsp;=&nbsp;nxt;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;prev;<br>}<br></code>
```

### 环形链表

👉 【LeetCode 直通车】：141 环形链表（简单）<sup data-darkreader-inline-color="">[5]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;Definition&nbsp;for&nbsp;singly-linked&nbsp;list.<br>&nbsp;*&nbsp;function&nbsp;ListNode(val)&nbsp;{<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.val&nbsp;=&nbsp;val;<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.next&nbsp;=&nbsp;null;<br>&nbsp;*&nbsp;}<br>&nbsp;*/</span><br><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{ListNode}</span>&nbsp;<span data-darkreader-inline-color="">head</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{boolean}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;hasCycle&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>head</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(head&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>&nbsp;||&nbsp;head.next&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;slower&nbsp;=&nbsp;head,&nbsp;faster&nbsp;=&nbsp;head;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(faster&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>&nbsp;&amp;&amp;&nbsp;faster.next&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slower&nbsp;=&nbsp;slower.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;faster&nbsp;=&nbsp;faster.next.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(slower&nbsp;===&nbsp;faster)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">true</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span>;<br>};<br></code>
```

### 排序链表

👉 【LeetCode 直通车】：148 排序链表（中等）<sup data-darkreader-inline-color="">[6]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;Definition&nbsp;for&nbsp;singly-linked&nbsp;list.<br>&nbsp;*&nbsp;function&nbsp;ListNode(val)&nbsp;{<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.val&nbsp;=&nbsp;val;<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.next&nbsp;=&nbsp;null;<br>&nbsp;*&nbsp;}<br>&nbsp;*/</span><br><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{ListNode}</span>&nbsp;<span data-darkreader-inline-color="">head</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{ListNode}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;sortList&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>head</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(head&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">null</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;newHead&nbsp;=&nbsp;head;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;mergeSort(head);<br>};<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">mergeSort</span>(<span>head</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(head.next&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;slower&nbsp;=&nbsp;getCenter(head);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;nxt&nbsp;=&nbsp;slower.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slower.next&nbsp;=&nbsp;<span data-darkreader-inline-color="">null</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(head,&nbsp;slower,&nbsp;nxt);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;left&nbsp;=&nbsp;mergeSort(head);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;right&nbsp;=&nbsp;mergeSort(nxt);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;head&nbsp;=&nbsp;merge(left,&nbsp;right);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;head;<br>}<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">merge</span>(<span>left,&nbsp;right</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;newHead&nbsp;=&nbsp;<span data-darkreader-inline-color="">null</span>,&nbsp;head&nbsp;=&nbsp;<span data-darkreader-inline-color="">null</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(left&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>&nbsp;&amp;&amp;&nbsp;right&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(left.val&nbsp;&lt;&nbsp;right.val)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!head)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newHead&nbsp;=&nbsp;left;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;head&nbsp;=&nbsp;left;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newHead.next&nbsp;=&nbsp;left;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newHead&nbsp;=&nbsp;newHead.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left&nbsp;=&nbsp;left.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!head)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newHead&nbsp;=&nbsp;right;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;head&nbsp;=&nbsp;right;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newHead.next&nbsp;=&nbsp;right;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newHead&nbsp;=&nbsp;newHead.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right&nbsp;=&nbsp;right.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;newHead.next&nbsp;=&nbsp;left&nbsp;?&nbsp;left&nbsp;:&nbsp;right;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;head;<br>}<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">getCenter</span>(<span>head</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;slower&nbsp;=&nbsp;head,&nbsp;faster&nbsp;=&nbsp;head.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(faster&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>&nbsp;&amp;&amp;&nbsp;faster.next&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slower&nbsp;=&nbsp;slower.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;faster&nbsp;=&nbsp;faster.next.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;slower;<br>}<br></code>
```

### 相交链表

👉 【LeetCode 直通车】：160 相交链表（简单）<sup data-darkreader-inline-color="">[7]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;Definition&nbsp;for&nbsp;singly-linked&nbsp;list.<br>&nbsp;*&nbsp;function&nbsp;ListNode(val)&nbsp;{<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.val&nbsp;=&nbsp;val;<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.next&nbsp;=&nbsp;null;<br>&nbsp;*&nbsp;}<br>&nbsp;*/</span><br><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{ListNode}</span>&nbsp;<span data-darkreader-inline-color="">headA</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{ListNode}</span>&nbsp;<span data-darkreader-inline-color="">headB</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{ListNode}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;getIntersectionNode&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>headA,&nbsp;headB</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;lastHeadA&nbsp;=&nbsp;<span data-darkreader-inline-color="">null</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;lastHeadB&nbsp;=&nbsp;<span data-darkreader-inline-color="">null</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;originHeadA&nbsp;=&nbsp;headA;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;originHeadB&nbsp;=&nbsp;headB;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!headA&nbsp;||&nbsp;!headB)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">null</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(<span data-darkreader-inline-color="">true</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(headB&nbsp;==&nbsp;headA)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;headB;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(headA&nbsp;&amp;&amp;&nbsp;headA.next&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastHeadA&nbsp;=&nbsp;headA;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;headA&nbsp;=&nbsp;originHeadB;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;headA&nbsp;=&nbsp;headA.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(headB&nbsp;&amp;&amp;&nbsp;headB.next&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastHeadB&nbsp;=&nbsp;headB<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;headB&nbsp;=&nbsp;originHeadA;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;headB&nbsp;=&nbsp;headB.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(lastHeadA&nbsp;&amp;&amp;&nbsp;lastHeadB&nbsp;&amp;&amp;&nbsp;lastHeadA&nbsp;!=&nbsp;lastHeadB)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">null</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">null</span>;<br>};<br></code>
```

## 【🔥】高频算法题系列：字符串

主要有以下几类高频考题：

-   最长回文子串 【中等】【双指针】【面试真题】
    
-   最长公共前缀 【简单】【双指针】
    
-   无重复字符的最长子串【中等】【双指针】
    
-   最小覆盖子串 【困难】【滑动窗口】【面试真题】
    

### 【面试真题】最长回文子串【双指针】

👉 【LeetCode 直通车】：5 最长回文子串（中等）<sup data-darkreader-inline-color="">[8]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{string}</span>&nbsp;<span data-darkreader-inline-color="">s</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{string}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;longestPalindrome&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>s</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(s.length&nbsp;===&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;s;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;maxRes&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>,&nbsp;maxStr&nbsp;=&nbsp;<span data-darkreader-inline-color="">''</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;s.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;str1&nbsp;=&nbsp;palindrome(s,&nbsp;i,&nbsp;i);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;str2&nbsp;=&nbsp;palindrome(s,&nbsp;i,&nbsp;i&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>);&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(str1.length&nbsp;&gt;&nbsp;maxRes)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxStr&nbsp;=&nbsp;str1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxRes&nbsp;=&nbsp;str1.length;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(str2.length&nbsp;&gt;&nbsp;maxRes)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxStr&nbsp;=&nbsp;str2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxRes&nbsp;=&nbsp;str2.length;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;maxStr;<br>};<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">palindrome</span>(<span>s,&nbsp;l,&nbsp;r</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(l&nbsp;&gt;=&nbsp;<span data-darkreader-inline-color="">0</span>&nbsp;&amp;&amp;&nbsp;r&nbsp;&lt;&nbsp;s.length&nbsp;&amp;&amp;&nbsp;s[l]&nbsp;===&nbsp;s[r])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l--;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r++;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;s.slice(l&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>,&nbsp;r);<br>}<br></code>
```

### 最长公共前缀【双指针】

👉 【LeetCode 直通车】：14 最长公共前缀（简单）<sup data-darkreader-inline-color="">[9]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{string[]}</span>&nbsp;<span data-darkreader-inline-color="">strs</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{string}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;longestCommonPrefix&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>strs</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(strs.length&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">""</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;first&nbsp;=&nbsp;strs[<span data-darkreader-inline-color="">0</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(first&nbsp;===&nbsp;<span data-darkreader-inline-color="">""</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">""</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;minLen&nbsp;=&nbsp;<span data-darkreader-inline-color="">Number</span>.MAX_SAFE_INTEGER;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;i&nbsp;&lt;&nbsp;strs.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;len&nbsp;=&nbsp;twoStrLongestCommonPrefix(first,&nbsp;strs[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minLen&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.min(len,&nbsp;minLen);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;first.slice(<span data-darkreader-inline-color="">0</span>,&nbsp;minLen);<br>};<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">twoStrLongestCommonPrefix</span>&nbsp;(<span>s,&nbsp;t</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>,&nbsp;j&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;cnt&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(i&nbsp;&lt;&nbsp;s.length&nbsp;&amp;&amp;&nbsp;j&nbsp;&lt;&nbsp;t.length)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(s[i],&nbsp;t[j],&nbsp;cnt)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(s[i]&nbsp;===&nbsp;t[j])&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnt++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;cnt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j++;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;cnt;<br>}<br></code>
```

### 无重复字符的最长子串【双指针】

👉 【LeetCode 直通车】：3 无重复字符的最长子串（中等）<sup data-darkreader-inline-color="">[10]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{string}</span>&nbsp;<span data-darkreader-inline-color="">s</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;lengthOfLongestSubstring&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>s</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;<span data-darkreader-inline-color="">window</span>&nbsp;=&nbsp;{};<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;left&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>,&nbsp;right&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;maxLen&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>,&nbsp;maxStr&nbsp;=&nbsp;<span data-darkreader-inline-color="">''</span>;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(right&nbsp;&lt;&nbsp;s.length)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;c&nbsp;=&nbsp;s[right];<br>&nbsp;&nbsp;&nbsp;&nbsp;right++;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">window</span>[c])&nbsp;<span data-darkreader-inline-color="">window</span>[c]++;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">window</span>[c]&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(<span data-darkreader-inline-color="">window</span>[c]&nbsp;&gt;&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;d&nbsp;=&nbsp;s[left];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">window</span>[d]--;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(maxLen&nbsp;&lt;&nbsp;right&nbsp;-&nbsp;left)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxLen&nbsp;=&nbsp;right&nbsp;-&nbsp;left;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;maxLen;<br>};<br></code>
```

### 【面试真题】 最小覆盖子串【滑动窗口】

👉 【LeetCode 直通车】：76 最小覆盖子串（困难）<sup data-darkreader-inline-color="">[11]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{string}</span>&nbsp;<span data-darkreader-inline-color="">s</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{string}</span>&nbsp;<span data-darkreader-inline-color="">t</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{string}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;minWindow&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>s,&nbsp;t</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;need&nbsp;=&nbsp;{},&nbsp;<span data-darkreader-inline-color="">window</span>&nbsp;=&nbsp;{};<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;c&nbsp;<span data-darkreader-inline-color="">of</span>&nbsp;t)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!need[c])&nbsp;need[c]&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;need[c]++;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;left&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>,&nbsp;right&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;valid&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>,&nbsp;len&nbsp;=&nbsp;<span data-darkreader-inline-color="">Object</span>.keys(need).length;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;minLen&nbsp;=&nbsp;s.length&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>,&nbsp;minStr&nbsp;=&nbsp;<span data-darkreader-inline-color="">''</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(right&nbsp;&lt;&nbsp;s.length)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;d&nbsp;=&nbsp;s[right];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!<span data-darkreader-inline-color="">window</span>[d])&nbsp;<span data-darkreader-inline-color="">window</span>[d]&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">window</span>[d]++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(need[d]&nbsp;&amp;&amp;&nbsp;need[d]&nbsp;===&nbsp;<span data-darkreader-inline-color="">window</span>[d])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valid++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">'left&nbsp;-&nbsp;right'</span>,&nbsp;left,&nbsp;right);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(valid&nbsp;===&nbsp;len)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(right&nbsp;-&nbsp;left&nbsp;&lt;&nbsp;minLen)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minLen&nbsp;=&nbsp;right&nbsp;-&nbsp;left;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minStr&nbsp;=&nbsp;s.slice(left,&nbsp;right);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.lo<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;c&nbsp;=&nbsp;s[left];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">window</span>[c]--;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(need[c]&nbsp;&amp;&amp;&nbsp;<span data-darkreader-inline-color="">window</span>[c]&nbsp;&lt;&nbsp;need[c])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valid--;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;minStr;<br>};<br></code>
```

## 【🔥】高频算法题系列：数组问题

主要有几类高频考题：

-   俄罗斯套娃信封问题【困难】【排序+最长上升子序列】【面试真题】
    
-   最长连续递增序列 【简单】【双指针】
    
-   最长连续序列【困难】【哈希表】
    
-   盛最多水的容器【困难】【面试真题】
    
-   寻找两个正序数组的中位数【困难】【双指针】
    
-   删除有序数组中的重复项【简单】【快慢指针】
    
-   和为K的子数组【中等】【哈希表】
    
-   nSum 问题【系列】【简单】【哈希表】
    
-   接雨水【困难】【暴力+备忘录优化】【面试真题】
    
-   跳跃游戏【系列】【中等】【贪心算法】
    

### 【面试真题】俄罗斯套娃信封问题【排序+最长上升子序列】

👉 【LeetCode 直通车】：354 俄罗斯套娃信封问题（困难）<sup data-darkreader-inline-color="">[12]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[][]}</span>&nbsp;<span data-darkreader-inline-color="">envelopes</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;maxEnvelopes&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>envelopes</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(envelopes.length&nbsp;===&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;envelopes.sort(<span>(<span>a,&nbsp;b</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(a[<span data-darkreader-inline-color="">0</span>]&nbsp;!==&nbsp;b[<span data-darkreader-inline-color="">0</span>])&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;a[<span data-darkreader-inline-color="">0</span>]&nbsp;-&nbsp;b[<span data-darkreader-inline-color="">0</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;b[<span data-darkreader-inline-color="">1</span>]&nbsp;-&nbsp;a[<span data-darkreader-inline-color="">1</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;LISArr&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;[key,&nbsp;value]&nbsp;<span data-darkreader-inline-color="">of</span>&nbsp;envelopes)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LISArr.push(value);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(&nbsp;LISArr);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;LIS(LISArr);<br>};<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">LIS</span>(<span>arr</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;dp&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;maxAns&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;arr.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;dp[i]&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;i&nbsp;&lt;&nbsp;arr.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;i;&nbsp;j&nbsp;&gt;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;j--)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(arr[i]&nbsp;&gt;&nbsp;arr[j])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i]&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.max(dp[i],&nbsp;dp[j]&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxAns&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.max(maxAns,&nbsp;dp[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;maxAns;<br>}<br></code>
```

### 最长连续递增序列【快慢指针】

👉 【LeetCode 直通车】：674 最长连续递增序列（简单）<sup data-darkreader-inline-color="">[13]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[]}</span>&nbsp;<span data-darkreader-inline-color="">nums</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;findLengthOfLCIS&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>nums</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(nums.length&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;n&nbsp;=&nbsp;nums.length;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;left&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>,&nbsp;right&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;globalMaxLen&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>,&nbsp;maxLen&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(right&nbsp;&lt;&nbsp;n)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(nums[right]&nbsp;&gt;&nbsp;nums[left])&nbsp;maxLen++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxLen&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;globalMaxLen&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.max(globalMaxLen,&nbsp;maxLen);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;globalMaxLen;<br>};<br></code>
```

### 最长连续序列 【哈希表】

👉 【LeetCode 直通车】：128 最长连续序列（困难）<sup data-darkreader-inline-color="">[14]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[]}</span>&nbsp;<span data-darkreader-inline-color="">nums</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;longestConsecutive&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>nums</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(nums.length&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;<span data-darkreader-inline-color="">set</span>&nbsp;=&nbsp;new&nbsp;Set(nums);<br>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;n&nbsp;=&nbsp;nums.length;<br>&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;globalLongest&nbsp;=&nbsp;1;<br>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(let&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!<span data-darkreader-inline-color="">set</span>.has(nums[i]&nbsp;-&nbsp;1))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;longest&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;currentNum&nbsp;=&nbsp;nums[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(<span data-darkreader-inline-color="">set</span>.has(currentNum&nbsp;+&nbsp;1))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentNum&nbsp;+=&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;longest++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;globalLongest&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.max(globalLongest,&nbsp;longest);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;globalLongest;<br>};<br></code>
```

### 【面试真题】盛最多水的容器【哈希表】

👉 【LeetCode 直通车】：11 盛最多水的容器（中等）<sup data-darkreader-inline-color="">[15]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[]}</span>&nbsp;<span data-darkreader-inline-color="">height</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;maxArea&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>height</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;n&nbsp;=&nbsp;height.length;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;left&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>,&nbsp;right&nbsp;=&nbsp;n&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;maxOpacity&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(left&nbsp;&lt;&nbsp;right)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;res&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.min(height[left],&nbsp;height[right])&nbsp;*&nbsp;(right&nbsp;-&nbsp;left);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxOpacity&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.max(maxOpacity,&nbsp;res);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(height[left]&nbsp;&lt;&nbsp;height[right])&nbsp;left++<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;right--;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;maxOpacity;<br>};<br></code>
```

### 寻找两个正序数组的中位数【双指针】

👉 【LeetCode 直通车】：4 寻找两个正序数组的中位数（困难）<sup data-darkreader-inline-color="">[16]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[]}</span>&nbsp;<span data-darkreader-inline-color="">nums1</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[]}</span>&nbsp;<span data-darkreader-inline-color="">nums2</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;findMedianSortedArrays&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>nums1,&nbsp;nums2</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;m&nbsp;=&nbsp;nums1.length,&nbsp;n&nbsp;=&nbsp;nums2.length;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>,&nbsp;j&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;newArr&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(i&nbsp;&lt;&nbsp;m&nbsp;&amp;&amp;&nbsp;j&nbsp;&lt;&nbsp;n)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(nums1[i]&nbsp;&lt;&nbsp;nums2[j])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newArr.push(nums1[i++]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newArr.push(nums2[j++]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;newArr&nbsp;=&nbsp;newArr.concat(i&nbsp;&lt;&nbsp;m&nbsp;?&nbsp;nums1.slice(i)&nbsp;:&nbsp;nums2.slice(j));<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;len&nbsp;=&nbsp;newArr.length;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(newArr)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(len&nbsp;%&nbsp;<span data-darkreader-inline-color="">2</span>&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;(newArr[len&nbsp;/&nbsp;<span data-darkreader-inline-color="">2</span>]&nbsp;+&nbsp;newArr[len&nbsp;/&nbsp;<span data-darkreader-inline-color="">2</span>&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>])&nbsp;/&nbsp;<span data-darkreader-inline-color="">2</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;newArr[<span data-darkreader-inline-color="">Math</span>.floor(len&nbsp;/&nbsp;<span data-darkreader-inline-color="">2</span>)];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br></code>
```

### 删除有序数组中的重复项【快慢指针】

👉 【LeetCode 直通车】：26 删除有序数组中的重复项（简单）<sup data-darkreader-inline-color="">[17]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[]}</span>&nbsp;<span data-darkreader-inline-color="">nums</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;removeDuplicates&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>nums</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(nums.length&nbsp;&lt;=&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;nums.length;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;lo&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>,&nbsp;hi&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(hi&nbsp;&lt;&nbsp;nums.length)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(nums[lo]&nbsp;===&nbsp;nums[hi]&nbsp;&amp;&amp;&nbsp;hi&nbsp;&lt;&nbsp;nums.length)&nbsp;hi++;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(nums[lo]&nbsp;!==&nbsp;nums[hi]&nbsp;&amp;&amp;&nbsp;hi&nbsp;&lt;&nbsp;nums.length)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lo++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nums[lo]&nbsp;=&nbsp;nums[hi];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;hi++;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;lo&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>;<br>};<br></code>
```

👉 【LeetCode 直通车】：695 岛屿的最大面积（中等）<sup data-darkreader-inline-color="">[18]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[][]}</span>&nbsp;<span data-darkreader-inline-color="">grid</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">let</span>&nbsp;maxX,&nbsp;maxY;<span data-darkreader-inline-color="">let</span>&nbsp;visited;<span data-darkreader-inline-color="">let</span>&nbsp;globalMaxArea;<br><span data-darkreader-inline-color="">var</span>&nbsp;maxAreaOfIsland&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>grid</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;visited&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Set</span>();<br>&nbsp;&nbsp;&nbsp;&nbsp;maxX&nbsp;=&nbsp;grid.length;<br>&nbsp;&nbsp;&nbsp;&nbsp;maxY&nbsp;=&nbsp;grid[<span data-darkreader-inline-color="">0</span>].length;<br>&nbsp;&nbsp;&nbsp;&nbsp;globalMaxArea&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;maxX;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;j&nbsp;&lt;&nbsp;maxY;&nbsp;j++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(grid[i][j]&nbsp;===&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visited.add(<span data-darkreader-inline-color="">`(<span data-darkreader-inline-color="">${i}</span>,&nbsp;<span data-darkreader-inline-color="">${j}</span>)`</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;globalMaxArea&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.max(globalMaxArea,&nbsp;dfs(grid,&nbsp;i,&nbsp;j));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visited.clear();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;globalMaxArea;<br>};<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">dfs</span>(<span>grid,&nbsp;x,&nbsp;y</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;res&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">-1</span>;&nbsp;i&nbsp;&lt;=&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;<span data-darkreader-inline-color="">-1</span>;&nbsp;j&nbsp;&lt;=&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;j++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">Math</span>.abs(i)&nbsp;===&nbsp;<span data-darkreader-inline-color="">Math</span>.abs(j))&nbsp;<span data-darkreader-inline-color="">continue</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;newX&nbsp;=&nbsp;x&nbsp;+&nbsp;i;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;newY&nbsp;=&nbsp;y&nbsp;+&nbsp;j;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(newX&nbsp;&gt;=&nbsp;maxX&nbsp;||&nbsp;newX&nbsp;&lt;&nbsp;<span data-darkreader-inline-color="">0</span>&nbsp;||&nbsp;newY&nbsp;&gt;=&nbsp;maxY&nbsp;||&nbsp;newY&nbsp;&lt;&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;<span data-darkreader-inline-color="">continue</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(visited.has(<span data-darkreader-inline-color="">`(<span data-darkreader-inline-color="">${newX}</span>,&nbsp;<span data-darkreader-inline-color="">${newY}</span>)`</span>))&nbsp;<span data-darkreader-inline-color="">continue</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visited.add(<span data-darkreader-inline-color="">`(<span data-darkreader-inline-color="">${newX}</span>,&nbsp;<span data-darkreader-inline-color="">${newY}</span>)`</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;areaCnt&nbsp;=&nbsp;grid[newX][newY]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(areaCnt&nbsp;===&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;cnt&nbsp;=&nbsp;dfs(grid,&nbsp;newX,&nbsp;newY);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;+=&nbsp;cnt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;res;<br>}<br></code>
```

### 和为K的子数组【哈希表】

👉 【LeetCode 直通车】：560 和为K的子数组（中等）<sup data-darkreader-inline-color="">[19]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[]}</span>&nbsp;<span data-darkreader-inline-color="">nums</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number}</span>&nbsp;<span data-darkreader-inline-color="">k</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;subarraySum&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>nums,&nbsp;k</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;cnt&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;sum0_i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>,&nbsp;sum0_j&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;map&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Map</span>();<br>&nbsp;&nbsp;&nbsp;&nbsp;map.set(<span data-darkreader-inline-color="">0</span>,&nbsp;<span data-darkreader-inline-color="">1</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;=&nbsp;nums.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum0_i&nbsp;+=&nbsp;nums[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum0_j&nbsp;=&nbsp;sum0_i&nbsp;-&nbsp;k;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">'map'</span>,&nbsp;sum0_j,&nbsp;map.get(sum0_j))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(map.has(sum0_j))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnt&nbsp;+=&nbsp;map.get(sum0_j);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;sumCnt&nbsp;=&nbsp;map.get(sum0_i)&nbsp;||&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.set(sum0_i,&nbsp;sumCnt&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;cnt;<br>};<br></code>
```

### nSum问题【哈希表】【系列】

-   👉 【LeetCode 直通车】：1 两数之和（简单）<sup data-darkreader-inline-color="">[20]</sup>
    
-   👉 【LeetCode 直通车】：167 两数之和 II - 输入有序数组（简单）<sup data-darkreader-inline-color="">[21]</sup>
    
-   👉 【LeetCode 直通车】：15 三数之和（中等）<sup data-darkreader-inline-color="">[22]</sup>
    
-   👉 【LeetCode 直通车】：18 四数之和（中等）<sup data-darkreader-inline-color="">[23]</sup>
    

受限于篇幅，这里只给出第一道题的代码模板，也是一面常考真题。

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[]}</span>&nbsp;<span data-darkreader-inline-color="">nums</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number}</span>&nbsp;<span data-darkreader-inline-color="">target</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number[]}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;twoSum&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>nums,&nbsp;target</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;map2&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Map</span>();<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;nums.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;map2.set(nums[i],&nbsp;i);<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;nums.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(map2.has(target&nbsp;-&nbsp;nums[i])&nbsp;&amp;&amp;&nbsp;map2.get(target&nbsp;-&nbsp;nums[i])&nbsp;!==&nbsp;i)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;[i,&nbsp;map2.get(target&nbsp;-&nbsp;nums[i])]<br>&nbsp;&nbsp;}<br>};<br></code>
```

### 接雨水【暴力+备忘录优化】

👉 【LeetCode 直通车】：42 接雨水（困难）<sup data-darkreader-inline-color="">[24]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[]}</span>&nbsp;<span data-darkreader-inline-color="">height</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;trap&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>height</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;l_max&nbsp;=&nbsp;[],&nbsp;r_max&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;len&nbsp;=&nbsp;height.length;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;maxCapacity&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;len;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l_max[i]&nbsp;=&nbsp;height[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r_max[i]&nbsp;=&nbsp;height[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;i&nbsp;&lt;&nbsp;len;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l_max[i]&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.max(l_max[i&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>],&nbsp;height[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;len&nbsp;-&nbsp;<span data-darkreader-inline-color="">2</span>;&nbsp;j&nbsp;&gt;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;j--)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r_max[j]&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.max(r_max[j&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>],&nbsp;height[j]);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;len;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxCapacity&nbsp;+=&nbsp;<span data-darkreader-inline-color="">Math</span>.min(l_max[i],&nbsp;r_max[i])&nbsp;-&nbsp;height[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;maxCapacity;<br>};<br></code>
```

### 跳跃游戏【贪心算法】【系列】

-   👉 【LeetCode 直通车】：55 跳跃游戏（中等）<sup data-darkreader-inline-color="">[25]</sup>
    
-   👉 【LeetCode 直通车】：45 跳跃游戏 II（中等）<sup data-darkreader-inline-color="">[26]</sup>
    

受限于篇幅，这里只给出第一道题的代码模板，也是一面常考真题。

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[]}</span>&nbsp;<span data-darkreader-inline-color="">nums</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{boolean}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;canJump&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>nums</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;faster&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;nums.length&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;faster&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.max(faster,&nbsp;i&nbsp;+&nbsp;nums[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(faster&nbsp;&lt;=&nbsp;i)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;faster&nbsp;&gt;=&nbsp;nums.length&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>;<br>};<br></code>
```

## 高频算法题系列：二叉树

主要有以下几类高频考题：

-   二叉树的最近公共祖先【简单】【二叉树】
    
-   二叉搜索树中的搜索【简单】【二叉树】
    
-   删除二叉搜索树中的节点【中等】【二叉树】
    
-   完全二叉树的节点个数【中等】【二叉树】
    
-   二叉树的锯齿形层序遍历【中等】【二叉树】
    

### 二叉树的最近公共祖先【二叉树】

👉 【LeetCode 直通车】：236 二叉树的最近公共祖先（简单）<sup data-darkreader-inline-color="">[27]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;Definition&nbsp;for&nbsp;a&nbsp;binary&nbsp;tree&nbsp;node.<br>&nbsp;*&nbsp;function&nbsp;TreeNode(val)&nbsp;{<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.val&nbsp;=&nbsp;val;<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.left&nbsp;=&nbsp;this.right&nbsp;=&nbsp;null;<br>&nbsp;*&nbsp;}<br>&nbsp;*/</span><br><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{TreeNode}</span>&nbsp;<span data-darkreader-inline-color="">root</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{TreeNode}</span>&nbsp;<span data-darkreader-inline-color="">p</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{TreeNode}</span>&nbsp;<span data-darkreader-inline-color="">q</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{TreeNode}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">let</span>&nbsp;visited;<span data-darkreader-inline-color="">let</span>&nbsp;parent;<br><span data-darkreader-inline-color="">var</span>&nbsp;lowestCommonAncestor&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>root,&nbsp;p,&nbsp;q</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;visited&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Set</span>();<br>&nbsp;&nbsp;&nbsp;&nbsp;parent&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Map</span>();<br>&nbsp;&nbsp;&nbsp;&nbsp;dfs(root);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(p&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visited.add(p.val);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;parent.get(p.val);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(q&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(visited.has(q.val))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;q;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;=&nbsp;parent.get(q.val);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">null</span>;<br>};<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">dfs</span>(<span>root</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(root.left&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent.set(root.left.val,&nbsp;root);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dfs(root.left);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(root.right&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent.set(root.right.val,&nbsp;root);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dfs(root.right);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code>
```

### 二叉搜索树中的搜索【二叉树】

👉 【LeetCode 直通车】：700 二叉搜索树中的搜索（简单）<sup data-darkreader-inline-color="">[28]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;Definition&nbsp;for&nbsp;a&nbsp;binary&nbsp;tree&nbsp;node.<br>&nbsp;*&nbsp;function&nbsp;TreeNode(val)&nbsp;{<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.val&nbsp;=&nbsp;val;<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.left&nbsp;=&nbsp;this.right&nbsp;=&nbsp;null;<br>&nbsp;*&nbsp;}<br>&nbsp;*/</span><br><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{TreeNode}</span>&nbsp;<span data-darkreader-inline-color="">root</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number}</span>&nbsp;<span data-darkreader-inline-color="">val</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{TreeNode}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;searchBST&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>root,&nbsp;val</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(root&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">null</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(root.val&nbsp;===&nbsp;val)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;root;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(root.val&nbsp;&gt;&nbsp;val)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;searchBST(root.left,&nbsp;val);<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(root.val&nbsp;&lt;&nbsp;val)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;searchBST(root.right,&nbsp;val);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br></code>
```

### 删除二叉搜索树中的节点【二叉树】

👉 【LeetCode 直通车】：450 删除二叉搜索树中的节点（中等）<sup data-darkreader-inline-color="">[29]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;Definition&nbsp;for&nbsp;a&nbsp;binary&nbsp;tree&nbsp;node.<br>&nbsp;*&nbsp;function&nbsp;TreeNode(val)&nbsp;{<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.val&nbsp;=&nbsp;val;<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.left&nbsp;=&nbsp;this.right&nbsp;=&nbsp;null;<br>&nbsp;*&nbsp;}<br>&nbsp;*/</span><br><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{TreeNode}</span>&nbsp;<span data-darkreader-inline-color="">root</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number}</span>&nbsp;<span data-darkreader-inline-color="">key</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{TreeNode}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;deleteNode&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>root,&nbsp;key</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(root&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">null</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(root.val&nbsp;===&nbsp;key)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(root.left&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>&nbsp;&amp;&amp;&nbsp;root.right&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">null</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(root.left&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;root.right;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(root.right&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;root.left;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(root.left&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>&nbsp;&amp;&amp;&nbsp;root.right&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;target&nbsp;=&nbsp;getMinTreeMaxNode(root.left);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root.val&nbsp;=&nbsp;target.val;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root.left&nbsp;=&nbsp;deleteNode(root.left,&nbsp;target.val);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(root.val&nbsp;&lt;&nbsp;key)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root.right&nbsp;=&nbsp;deleteNode(root.right,&nbsp;key);<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(root.val&nbsp;&gt;&nbsp;key)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root.left&nbsp;=&nbsp;deleteNode(root.left,&nbsp;key);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;root;<br>};<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">getMinTreeMaxNode</span>(<span>root</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(root.right&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;root;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;getMinTreeMaxNode(root.right);<br>}<br></code>
```

### 完全二叉树的节点个数【二叉树】

👉 【LeetCode 直通车】：222 完全二叉树的节点个数（中等）<sup data-darkreader-inline-color="">[30]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;Definition&nbsp;for&nbsp;a&nbsp;binary&nbsp;tree&nbsp;node.<br>&nbsp;*&nbsp;function&nbsp;TreeNode(val)&nbsp;{<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.val&nbsp;=&nbsp;val;<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.left&nbsp;=&nbsp;this.right&nbsp;=&nbsp;null;<br>&nbsp;*&nbsp;}<br>&nbsp;*/</span><br><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{TreeNode}</span>&nbsp;<span data-darkreader-inline-color="">root</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;countNodes&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>root</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(root&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;l&nbsp;=&nbsp;root,&nbsp;r&nbsp;=&nbsp;root;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;lh&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>,&nbsp;rh&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(l&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l&nbsp;=&nbsp;l.left;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lh++;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(r&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;r.right;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rh++;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(lh&nbsp;===&nbsp;rh)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">Math</span>.pow(<span data-darkreader-inline-color="">2</span>,&nbsp;lh)&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">1</span>&nbsp;+&nbsp;countNodes(root.left)&nbsp;+&nbsp;countNodes(root.right);<br>};<br></code>
```

### 二叉树的锯齿形层序遍历【二叉树】

👉 【LeetCode 直通车】：103 二叉树的锯齿形层序遍历（中等）<sup data-darkreader-inline-color="">[31]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;Definition&nbsp;for&nbsp;a&nbsp;binary&nbsp;tree&nbsp;node.<br>&nbsp;*&nbsp;function&nbsp;TreeNode(val)&nbsp;{<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.val&nbsp;=&nbsp;val;<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.left&nbsp;=&nbsp;this.right&nbsp;=&nbsp;null;<br>&nbsp;*&nbsp;}<br>&nbsp;*/</span><br><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{TreeNode}</span>&nbsp;<span data-darkreader-inline-color="">root</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number[][]}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">let</span>&nbsp;res;<br><span data-darkreader-inline-color="">var</span>&nbsp;zigzagLevelOrder&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>root</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(root&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;BFS(root,&nbsp;<span data-darkreader-inline-color="">true</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;res;<br>};<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">BFS</span>(<span>root,&nbsp;inOrder</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;arr&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;resItem&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;node;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;stack1&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Stack();<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;stack2&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Stack();<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;判断交换时机</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;flag;<br>&nbsp;&nbsp;&nbsp;&nbsp;stack1.push(root);<br>&nbsp;&nbsp;&nbsp;&nbsp;res.push([root.val]);<br>&nbsp;&nbsp;&nbsp;&nbsp;inOrder&nbsp;=&nbsp;!inOrder;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(!stack1.isEmpty()&nbsp;||&nbsp;!stack2.isEmpty())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(stack1.isEmpty())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag&nbsp;=&nbsp;<span data-darkreader-inline-color="">'stack1'</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(stack2.isEmpty())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag&nbsp;=&nbsp;<span data-darkreader-inline-color="">'stack2'</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;决定取那个栈里面的元素</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(flag&nbsp;===&nbsp;<span data-darkreader-inline-color="">'stack2'</span>&nbsp;&amp;&amp;&nbsp;!stack1.isEmpty())&nbsp;node&nbsp;=&nbsp;stack1.pop();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(flag&nbsp;===&nbsp;<span data-darkreader-inline-color="">'stack1'</span>&nbsp;&amp;&amp;&nbsp;!stack2.isEmpty())&nbsp;node&nbsp;=&nbsp;stack2.pop();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(inOrder)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(node.left)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(flag&nbsp;===&nbsp;<span data-darkreader-inline-color="">'stack1'</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack1.push(node.left);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack2.push(node.left);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resItem.push(node.left.val);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(node.right)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(flag&nbsp;===&nbsp;<span data-darkreader-inline-color="">'stack1'</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack1.push(node.right);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack2.push(node.right);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resItem.push(node.right.val);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(node.right)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(flag&nbsp;===&nbsp;<span data-darkreader-inline-color="">'stack1'</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack1.push(node.right);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack2.push(node.right);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resItem.push(node.right.val);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(node.left)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(flag&nbsp;===&nbsp;<span data-darkreader-inline-color="">'stack1'</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack1.push(node.left);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack2.push(node.left);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resItem.push(node.left.val);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;判断下次翻转的时机</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;((flag&nbsp;===&nbsp;<span data-darkreader-inline-color="">'stack2'</span>&nbsp;&amp;&amp;&nbsp;stack1.isEmpty())&nbsp;||&nbsp;(flag&nbsp;===&nbsp;<span data-darkreader-inline-color="">'stack1'</span>&nbsp;&amp;&amp;&nbsp;stack2.isEmpty()))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inOrder&nbsp;=&nbsp;!inOrder;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;需要翻转了，就加一轮值</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(resItem.length&nbsp;&gt;&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.push(resItem);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resItem&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><span><span data-darkreader-inline-color="">class</span>&nbsp;<span data-darkreader-inline-color="">Stack</span>&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">constructor</span>()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.count&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.items&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;push(element)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.items[<span data-darkreader-inline-color="">this</span>.count]&nbsp;=&nbsp;element;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.count++;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;pop()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">this</span>.isEmpty())&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">undefined</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;element&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span>.items[<span data-darkreader-inline-color="">this</span>.count&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">delete</span>&nbsp;<span data-darkreader-inline-color="">this</span>.items[<span data-darkreader-inline-color="">this</span>.count&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.count--;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;element;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;size()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">this</span>.count;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;isEmpty()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">this</span>.size()&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code>
```

## 【🔥】高频算法题系列：排序算法

主要有以下几类高频考题：

-   用最少数量的箭引爆气球【中等】【排序】
    
-   合并区间【中等】【排序算法+区间问题】【面试真题】
    

### 用最少数量的箭引爆气球【排序算法】

👉 【LeetCode 直通车】：452 用最少数量的箭引爆气球（中等）<sup data-darkreader-inline-color="">[32]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[][]}</span>&nbsp;<span data-darkreader-inline-color="">points</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;findMinArrowShots&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>points</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(points.length&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;points.sort(<span>(<span>a,&nbsp;b</span>)&nbsp;=&gt;</span>&nbsp;a[<span data-darkreader-inline-color="">1</span>]&nbsp;-&nbsp;b[<span data-darkreader-inline-color="">1</span>]);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;cnt&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;resArr&nbsp;=&nbsp;[points[<span data-darkreader-inline-color="">0</span>]];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;curr,&nbsp;last;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;i&nbsp;&lt;&nbsp;points.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curr&nbsp;=&nbsp;points[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last&nbsp;=&nbsp;resArr[resArr.length&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(curr[<span data-darkreader-inline-color="">0</span>]&nbsp;&gt;&nbsp;last[<span data-darkreader-inline-color="">1</span>])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resArr.push(curr);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnt++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;cnt;<br>};<br></code>
```

### 合并区间【排序算法+区间问题】

👉 【LeetCode 直通车】：56 合并区间（中等）<sup data-darkreader-inline-color="">[33]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[][]}</span>&nbsp;<span data-darkreader-inline-color="">intervals</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number[][]}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;merge&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>intervals</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(intervals.length&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;intervals.sort(<span>(<span>a,&nbsp;b</span>)&nbsp;=&gt;</span>&nbsp;a[<span data-darkreader-inline-color="">0</span>]&nbsp;-&nbsp;b[<span data-darkreader-inline-color="">0</span>]);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;mergeArr&nbsp;=&nbsp;[intervals[<span data-darkreader-inline-color="">0</span>]];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;last,&nbsp;curr;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;j&nbsp;&lt;&nbsp;intervals.length;&nbsp;j++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last&nbsp;=&nbsp;mergeArr[mergeArr.length&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curr&nbsp;=&nbsp;intervals[j];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(last[<span data-darkreader-inline-color="">1</span>]&nbsp;&gt;=&nbsp;curr[<span data-darkreader-inline-color="">0</span>])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last[<span data-darkreader-inline-color="">1</span>]&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.max(curr[<span data-darkreader-inline-color="">1</span>],&nbsp;last[<span data-darkreader-inline-color="">1</span>]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mergeArr.push(curr);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;mergeArr;<br>};<br></code>
```

## 高频算法题系列：二分查找

主要有以下几类高频考题：

-   寻找两个正序数组的中位数【困难】【二分查找】
    
-   判断子序列【简单】【二分查找】
    
-   在排序数组中查找元素的第一个和最后一个位置【中等】【二分查找】
    

### 寻找两个正序数组的中位数【二分查找】

👉 【LeetCode 直通车】：4 寻找两个正序数组的中位数（困难）<sup data-darkreader-inline-color="">[34]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[]}</span>&nbsp;<span data-darkreader-inline-color="">nums1</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[]}</span>&nbsp;<span data-darkreader-inline-color="">nums2</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;findMedianSortedArrays&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>nums1,&nbsp;nums2</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;m&nbsp;=&nbsp;nums1.length,&nbsp;n&nbsp;=&nbsp;nums2.length;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>,&nbsp;j&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;newArr&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(i&nbsp;&lt;&nbsp;m&nbsp;&amp;&amp;&nbsp;j&nbsp;&lt;&nbsp;n)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(nums1[i]&nbsp;&lt;&nbsp;nums2[j])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newArr.push(nums1[i++]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newArr.push(nums2[j++]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;newArr&nbsp;=&nbsp;newArr.concat(i&nbsp;&lt;&nbsp;m&nbsp;?&nbsp;nums1.slice(i)&nbsp;:&nbsp;nums2.slice(j));<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;len&nbsp;=&nbsp;newArr.length;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(newArr)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(len&nbsp;%&nbsp;<span data-darkreader-inline-color="">2</span>&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;(newArr[len&nbsp;/&nbsp;<span data-darkreader-inline-color="">2</span>]&nbsp;+&nbsp;newArr[len&nbsp;/&nbsp;<span data-darkreader-inline-color="">2</span>&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>])&nbsp;/&nbsp;<span data-darkreader-inline-color="">2</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;newArr[<span data-darkreader-inline-color="">Math</span>.floor(len&nbsp;/&nbsp;<span data-darkreader-inline-color="">2</span>)];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br></code>
```

### 判断子序列【二分查找】

👉 【LeetCode 直通车】：392 判断子序列（简单）<sup data-darkreader-inline-color="">[35]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{string}</span>&nbsp;<span data-darkreader-inline-color="">s</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{string}</span>&nbsp;<span data-darkreader-inline-color="">t</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{boolean}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;isSubsequence&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>s,&nbsp;t</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;hash&nbsp;=&nbsp;{};<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;t.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!hash[t[i]])&nbsp;hash[t[i]]&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hash[t[i]].push(i);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;lastMaxIndex&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;s.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(hash[s[i]])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;index&nbsp;=&nbsp;binarySearch(hash[s[i]],&nbsp;lastMaxIndex);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">'index'</span>,&nbsp;index,&nbsp;hash[s[i]]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(index&nbsp;===&nbsp;<span data-darkreader-inline-color="">-1</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastMaxIndex&nbsp;=&nbsp;hash[s[i]][index]&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">true</span>;<br>};<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">binarySearch</span>(<span>array,&nbsp;targetIndex</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;left&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>,&nbsp;right&nbsp;=&nbsp;array.length;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(left&nbsp;&lt;&nbsp;right)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;mid&nbsp;=&nbsp;left&nbsp;+&nbsp;<span data-darkreader-inline-color="">Math</span>.floor((right&nbsp;-&nbsp;left)&nbsp;/&nbsp;<span data-darkreader-inline-color="">2</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(array[mid]&nbsp;&gt;=&nbsp;targetIndex)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right&nbsp;=&nbsp;mid;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(array[mid]&nbsp;&lt;&nbsp;targetIndex)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left&nbsp;=&nbsp;mid&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(left&nbsp;&gt;=&nbsp;array.length&nbsp;||&nbsp;array[left]&nbsp;&lt;&nbsp;targetIndex)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">-1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;left;<br>}<br></code>
```

### 💁 在排序数组中查找元素的第一个和最后一个位置【二分搜索】

👉 【LeetCode 直通车】：34 在排序数组中查找元素的第一个和最后一个位置（中等）<sup data-darkreader-inline-color="">[36]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[]}</span>&nbsp;<span data-darkreader-inline-color="">nums</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number}</span>&nbsp;<span data-darkreader-inline-color="">target</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number[]}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;searchRange&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>nums,&nbsp;target</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;left&nbsp;=&nbsp;leftBound(nums,&nbsp;target);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;right&nbsp;=&nbsp;rightBound(nums,&nbsp;target);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;[left,&nbsp;right];<br>};<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">leftBound</span>(<span>nums,&nbsp;target</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;left&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;right&nbsp;=&nbsp;nums.length&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(left&nbsp;&lt;=&nbsp;right)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;mid&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.floor(left&nbsp;+&nbsp;(right&nbsp;-&nbsp;left)&nbsp;/&nbsp;<span data-darkreader-inline-color="">2</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(nums[mid]&nbsp;===&nbsp;target)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right&nbsp;=&nbsp;mid&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(nums[mid]&nbsp;&lt;&nbsp;target)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left&nbsp;=&nbsp;mid&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(nums[mid]&nbsp;&gt;&nbsp;target)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right&nbsp;=&nbsp;mid&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(left&nbsp;&gt;=&nbsp;nums.length&nbsp;||&nbsp;nums[left]&nbsp;!==&nbsp;target)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">-1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;left;<br>}<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">rightBound</span>(<span>nums,&nbsp;target</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;left&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;right&nbsp;=&nbsp;nums.length&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(left&nbsp;&lt;=&nbsp;right)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;mid&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.floor(left&nbsp;+&nbsp;(right&nbsp;-&nbsp;left)&nbsp;/&nbsp;<span data-darkreader-inline-color="">2</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(nums[mid]&nbsp;===&nbsp;target)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left&nbsp;=&nbsp;mid&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(nums[mid]&nbsp;&lt;&nbsp;target)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left&nbsp;=&nbsp;mid&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(nums[mid]&nbsp;&gt;&nbsp;target)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right&nbsp;=&nbsp;mid&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(right&nbsp;&lt;&nbsp;<span data-darkreader-inline-color="">0</span>&nbsp;||&nbsp;nums[right]&nbsp;!==&nbsp;target)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">-1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;right;<br>}<br></code>
```

## 【🔥】高频算法题系列：动态规划

主要有以下几类高频考题：

-   最长递增子序列【中等】【动态规划】
    
-   零钱兑换【中等】【动态规划】【面试真题】
    
-   最长公共子序列 【中等】【动态规划】【面试真题】
    
-   编辑距离 【困难】【动态规划】
    
-   最长回文子序列【中等】【动态规划】【面试真题】
    
-   最大子序和【简单】【动态规划】【面试真题】
    
-   买卖股票的最佳时机系列【系列】【动态规划】【面试真题】
    

### 最长递增子序列【动态规划】

👉 【LeetCode 直通车】：300 最长递增子序列（中等）<sup data-darkreader-inline-color="">[37]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[]}</span>&nbsp;<span data-darkreader-inline-color="">nums</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;lengthOfLIS&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>nums</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;maxLen&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>,&nbsp;n&nbsp;=&nbsp;nums.length;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;dp&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i]&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;j&nbsp;&lt;&nbsp;i;&nbsp;j++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(nums[i]&nbsp;&gt;&nbsp;nums[j])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i]&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.max(dp[i],&nbsp;dp[j]&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxLen&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.max(maxLen,&nbsp;dp[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;maxLen;<br>};<br></code>
```

### 【面试真题】 零钱兑换【动态规划】

👉 【LeetCode 直通车】：322 零钱兑换（中等）<sup data-darkreader-inline-color="">[38]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[]}</span>&nbsp;<span data-darkreader-inline-color="">coins</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number}</span>&nbsp;<span data-darkreader-inline-color="">amount</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;coinChange&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>coins,&nbsp;amount</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(amount&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;dp&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;=&nbsp;amount;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;dp[i]&nbsp;=&nbsp;amount&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;dp[<span data-darkreader-inline-color="">0</span>]&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;=&nbsp;amount;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;j&nbsp;&lt;&nbsp;coins.length;&nbsp;j++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(i&nbsp;&gt;=&nbsp;coins[j])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i]&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.min(dp[i&nbsp;-&nbsp;coins[j]]&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>,&nbsp;dp[i])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;dp[amount]&nbsp;===&nbsp;amount&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>&nbsp;?&nbsp;<span data-darkreader-inline-color="">-1</span>&nbsp;:&nbsp;dp[amount];<br>};<br></code>
```

### 【面试真题】 最长公共子序列【动态规划】

👉 【LeetCode 直通车】：1143 最长公共子序列（中等）<sup data-darkreader-inline-color="">[39]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{string}</span>&nbsp;<span data-darkreader-inline-color="">text1</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{string}</span>&nbsp;<span data-darkreader-inline-color="">text2</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;longestCommonSubsequence&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>text1,&nbsp;text2</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;n1&nbsp;=&nbsp;text1.length,&nbsp;n2&nbsp;=&nbsp;text2.length;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;dp&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">-1</span>;&nbsp;i&nbsp;&lt;&nbsp;n1;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i]&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;<span data-darkreader-inline-color="">-1</span>;&nbsp;j&nbsp;&lt;&nbsp;n2;j++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;n1;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;j&nbsp;&lt;&nbsp;n2;&nbsp;j++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(text1[i]&nbsp;===&nbsp;text2[j])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.max(dp[i][j],&nbsp;dp[i&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>][j&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>]&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.max(dp[i&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>][j],&nbsp;dp[i][j&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;dp[n1&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>][n2&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br>};<br></code>
```

### 编辑距离【动态规划】

👉 【LeetCode 直通车】：72 编辑距离（困难）<sup data-darkreader-inline-color="">[40]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{string}</span>&nbsp;<span data-darkreader-inline-color="">word1</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{string}</span>&nbsp;<span data-darkreader-inline-color="">word2</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;minDistance&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>word1,&nbsp;word2</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;len1&nbsp;=&nbsp;word1.length,&nbsp;len2&nbsp;=&nbsp;word2.length;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;dp&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;=&nbsp;len1;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;dp[i]&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;j&nbsp;&lt;=&nbsp;len2;&nbsp;j++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(i&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]&nbsp;=&nbsp;j;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(j&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]&nbsp;=&nbsp;i;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;i&nbsp;&lt;=&nbsp;len1;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;j&nbsp;&lt;=&nbsp;len2;&nbsp;j++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(word1[i&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>]&nbsp;===&nbsp;word2[j&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]&nbsp;=&nbsp;dp[i&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>][j&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.min(dp[i&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>][j]&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>,&nbsp;dp[i][j&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>]&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>,&nbsp;dp[i&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>][j&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>]&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;dp[len1][len2];<br>};<br></code>
```

### 【面试真题】最长回文子序列【动态规划】

👉 【LeetCode 直通车】：516 最长回文子序列（中等）<sup data-darkreader-inline-color="">[41]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{string}</span>&nbsp;<span data-darkreader-inline-color="">s</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;longestPalindromeSubseq&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>s</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;dp&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;s.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i]&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;j&nbsp;&lt;&nbsp;s.length;&nbsp;j++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][i]&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;s.length&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;i&nbsp;&gt;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i--)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;i&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;j&nbsp;&lt;&nbsp;s.length;&nbsp;j++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(s[i]&nbsp;===&nbsp;s[j])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]&nbsp;=&nbsp;dp[i&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>][j&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>]&nbsp;+&nbsp;<span data-darkreader-inline-color="">2</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.max(dp[i&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>][j],&nbsp;dp[i][j&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;dp[<span data-darkreader-inline-color="">0</span>][s.length&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br>};<br></code>
```

### 【面试真题】💁 最大子序和【动态规划】

👉 【LeetCode 直通车】：53 最大子序和（简单）<sup data-darkreader-inline-color="">[42]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[]}</span>&nbsp;<span data-darkreader-inline-color="">nums</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;maxSubArray&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>nums</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;maxSum&nbsp;=&nbsp;-<span data-darkreader-inline-color="">Infinity</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;dp&nbsp;=&nbsp;[],&nbsp;n&nbsp;=&nbsp;nums.length;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">-1</span>;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i]&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i]&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.max(nums[i],&nbsp;dp[i&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>]&nbsp;+&nbsp;nums[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxSum&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.max(maxSum,&nbsp;dp[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;maxSum;<br>};<br></code>
```

### 【面试真题】💁 买卖股票的最佳时机【动态规划】

-   👉 【LeetCode 直通车】：121 买卖股票的最佳时机（简单）<sup data-darkreader-inline-color="">[43]</sup>【面试真题】
    
-   👉 【LeetCode 直通车】：122 买卖股票的最佳时机 II（简单）<sup data-darkreader-inline-color="">[44]</sup>
    
-   👉 【LeetCode 直通车】：123 买卖股票的最佳时机 III（困难）<sup data-darkreader-inline-color="">[45]</sup>
    
-   👉 【LeetCode 直通车】：188 买卖股票的最佳时机IV（困难）<sup data-darkreader-inline-color="">[46]</sup>
    
-   👉 【LeetCode 直通车】：309 买卖股票的最佳时机含冷冻期（中等）<sup data-darkreader-inline-color="">[47]</sup>
    
-   👉 【LeetCode 直通车】：714 买卖股票的最佳时机含手续费（中等）<sup data-darkreader-inline-color="">[48]</sup>
    

受限于篇幅，这里只给出第一道题的代码模板，也是一面常考真题，笔者在面试字节跳动时就遇到过。

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[]}</span>&nbsp;<span data-darkreader-inline-color="">prices</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;maxProfit&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>prices</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;dp&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">-1</span>;&nbsp;i&nbsp;&lt;&nbsp;prices.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;dp[i]&nbsp;=&nbsp;[]<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;j&nbsp;&lt;=&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;j++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j][<span data-darkreader-inline-color="">0</span>]&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j][<span data-darkreader-inline-color="">1</span>]&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(i&nbsp;===&nbsp;<span data-darkreader-inline-color="">-1</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j][<span data-darkreader-inline-color="">1</span>]&nbsp;=&nbsp;-<span data-darkreader-inline-color="">Infinity</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(j&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j][<span data-darkreader-inline-color="">1</span>]&nbsp;=&nbsp;-<span data-darkreader-inline-color="">Infinity</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(j&nbsp;===&nbsp;<span data-darkreader-inline-color="">-1</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j][<span data-darkreader-inline-color="">1</span>]&nbsp;=&nbsp;-<span data-darkreader-inline-color="">Infinity</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;prices.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;j&nbsp;&lt;=&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;j++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j][<span data-darkreader-inline-color="">0</span>]&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.max(dp[i&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>][j][<span data-darkreader-inline-color="">0</span>],&nbsp;dp[i&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>][j][<span data-darkreader-inline-color="">1</span>]&nbsp;+&nbsp;prices[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j][<span data-darkreader-inline-color="">1</span>]&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.max(dp[i&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>][j][<span data-darkreader-inline-color="">1</span>],&nbsp;dp[i&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>][j&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>][<span data-darkreader-inline-color="">0</span>]&nbsp;-&nbsp;prices[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;dp[prices.length&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>][<span data-darkreader-inline-color="">1</span>][<span data-darkreader-inline-color="">0</span>];<br>};<br></code>
```

## 高频算法题系列：BFS

主要有以下几类高频考题：

-   打开转盘锁【中等】【BFS】
    
-   二叉树的最小深度【简单】【BFS】
    

### 打开转盘锁【BFS】

👉 【LeetCode 直通车】：752 打开转盘锁（中等）<sup data-darkreader-inline-color="">[49]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{string[]}</span>&nbsp;<span data-darkreader-inline-color="">deadends</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{string}</span>&nbsp;<span data-darkreader-inline-color="">target</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;openLock&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>deadends,&nbsp;target</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;queue&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Queue();<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;visited&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Set</span>();<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;step&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;queue.push(<span data-darkreader-inline-color="">'0000'</span>);<br>&nbsp;&nbsp;visited.add(<span data-darkreader-inline-color="">'0000'</span>);<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(!queue.isEmpty())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;size&nbsp;=&nbsp;queue.size();<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;size;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;str&nbsp;=&nbsp;queue.pop();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(deadends.includes(str))&nbsp;<span data-darkreader-inline-color="">continue</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(target&nbsp;===&nbsp;str)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;step;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;j&nbsp;&lt;&nbsp;<span data-darkreader-inline-color="">4</span>;&nbsp;j++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;plusStr&nbsp;=&nbsp;plusOne(str,&nbsp;j);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;minusStr&nbsp;=&nbsp;minusOne(str,&nbsp;j);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!visited.has(plusStr))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.push(plusStr);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visited.add(plusStr)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!visited.has(minusStr))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.push(minusStr);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visited.add(minusStr)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;step++;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">-1</span>;<br>};<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">plusOne</span>(<span>str,&nbsp;index</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;strArr&nbsp;=&nbsp;str.split(<span data-darkreader-inline-color="">''</span>);<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(strArr[index]&nbsp;===&nbsp;<span data-darkreader-inline-color="">'9'</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;strArr[index]&nbsp;=&nbsp;<span data-darkreader-inline-color="">'0'</span><br>&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;strArr[index]&nbsp;=&nbsp;(<span data-darkreader-inline-color="">Number</span>(strArr[index])&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>).toString()<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;strArr.join(<span data-darkreader-inline-color="">''</span>);<br>}<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">minusOne</span>(<span>str,&nbsp;index</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;strArr&nbsp;=&nbsp;str.split(<span data-darkreader-inline-color="">''</span>);<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(strArr[index]&nbsp;===&nbsp;<span data-darkreader-inline-color="">'0'</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;strArr[index]&nbsp;=&nbsp;<span data-darkreader-inline-color="">'9'</span><br>&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;strArr[index]&nbsp;=&nbsp;(<span data-darkreader-inline-color="">Number</span>(strArr[index])&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>).toString()<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;strArr.join(<span data-darkreader-inline-color="">''</span>);<br>}<br><span><span data-darkreader-inline-color="">class</span>&nbsp;<span data-darkreader-inline-color="">Queue</span>&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">constructor</span>()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.items&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.count&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.lowerCount&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;push(elem)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.items[<span data-darkreader-inline-color="">this</span>.count++]&nbsp;=&nbsp;elem;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;pop()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">this</span>.isEmpty())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;elem&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span>.items[<span data-darkreader-inline-color="">this</span>.lowerCount];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">delete</span>&nbsp;<span data-darkreader-inline-color="">this</span>.items[<span data-darkreader-inline-color="">this</span>.lowerCount];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.lowerCount++;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;elem;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;isEmpty()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">this</span>.size()&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">true</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span>;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;size()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">this</span>.count&nbsp;-&nbsp;<span data-darkreader-inline-color="">this</span>.lowerCount;<br>&nbsp;&nbsp;}<br>}<br></code>
```

### 二叉树的最小深度【BFS】

👉 【LeetCode 直通车】：111 二叉树的最小深度（简单）<sup data-darkreader-inline-color="">[50]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;Definition&nbsp;for&nbsp;a&nbsp;binary&nbsp;tree&nbsp;node.<br>&nbsp;*&nbsp;function&nbsp;TreeNode(val)&nbsp;{<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.val&nbsp;=&nbsp;val;<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.left&nbsp;=&nbsp;this.right&nbsp;=&nbsp;null;<br>&nbsp;*&nbsp;}<br>&nbsp;*/</span><br><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{TreeNode}</span>&nbsp;<span data-darkreader-inline-color="">root</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;minDepth&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>root</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(root&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;depth&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;queue&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Queue();<br>&nbsp;&nbsp;queue.push(root);<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(!queue.isEmpty())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;size&nbsp;=&nbsp;queue.size();<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;size;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;node&nbsp;=&nbsp;queue.pop();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(node.left&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>&nbsp;&amp;&amp;&nbsp;node.right&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;depth;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(node.left)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.push(node.left);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(node.right)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.push(node.right);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;depth++;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;depth;<br>};<br><span><span data-darkreader-inline-color="">class</span>&nbsp;<span data-darkreader-inline-color="">Queue</span>&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">constructor</span>()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.items&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.count&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.lowerCount&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;push(elem)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.items[<span data-darkreader-inline-color="">this</span>.count++]&nbsp;=&nbsp;elem;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;pop()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">this</span>.isEmpty())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;elem&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span>.items[<span data-darkreader-inline-color="">this</span>.lowerCount];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">delete</span>&nbsp;<span data-darkreader-inline-color="">this</span>.items[<span data-darkreader-inline-color="">this</span>.lowerCount];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.lowerCount++;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;elem;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;isEmpty()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">this</span>.size()&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">true</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span>;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;size()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">this</span>.count&nbsp;-&nbsp;<span data-darkreader-inline-color="">this</span>.lowerCount;<br>&nbsp;&nbsp;}<br>}<br></code>
```

## 【🔥】高频算法题系列：栈

主要有以下几类高频考题：

-   最小栈【简单】【栈】
    
-   有效的括号【中等】【栈】【面试真题】
    
-   简化路径【中等】【栈】
    
-   下一个更大元素 【系列】【栈】
    

### 最小栈【栈】

👉 【LeetCode 直通车】：155 最小栈（简单）<sup data-darkreader-inline-color="">[51]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;initialize&nbsp;your&nbsp;data&nbsp;structure&nbsp;here.<br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;MinStack&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.stack&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.minArr&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.count&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.min&nbsp;=&nbsp;<span data-darkreader-inline-color="">Number</span>.MAX_SAFE_INTEGER;<br>};<br><span data-darkreader-inline-color="">/**&nbsp;<br>&nbsp;*&nbsp;@param&nbsp;{number}&nbsp;x<br>&nbsp;*&nbsp;@return&nbsp;{void}<br>&nbsp;*/</span><br>MinStack.prototype.push&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>x</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.min&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.min(<span data-darkreader-inline-color="">this</span>.min,&nbsp;x);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.minArr[<span data-darkreader-inline-color="">this</span>.count]&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span>.min;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.stack[<span data-darkreader-inline-color="">this</span>.count]&nbsp;=&nbsp;x;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.count++;<br>};<br><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;@return&nbsp;{void}<br>&nbsp;*/</span><br>MinStack.prototype.pop&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;element&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span>.stack[<span data-darkreader-inline-color="">this</span>.count&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">this</span>.count&nbsp;-&nbsp;<span data-darkreader-inline-color="">2</span>&nbsp;&gt;=&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;<span data-darkreader-inline-color="">this</span>.min&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span>.minArr[<span data-darkreader-inline-color="">this</span>.count&nbsp;-&nbsp;<span data-darkreader-inline-color="">2</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.min&nbsp;=&nbsp;<span data-darkreader-inline-color="">Number</span>.MAX_SAFE_INTEGER;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">delete</span>&nbsp;<span data-darkreader-inline-color="">this</span>.stack[<span data-darkreader-inline-color="">this</span>.count&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">delete</span>&nbsp;<span data-darkreader-inline-color="">this</span>.minArr[<span data-darkreader-inline-color="">this</span>.count&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.count--;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;element;<br>};<br><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;@return&nbsp;{number}<br>&nbsp;*/</span><br>MinStack.prototype.top&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">this</span>.count&nbsp;&gt;=&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">this</span>.stack[<span data-darkreader-inline-color="">this</span>.count&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">null</span>;<br>};<br><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;@return&nbsp;{number}<br>&nbsp;*/</span><br>MinStack.prototype.getMin&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;element&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span>.minArr[<span data-darkreader-inline-color="">this</span>.count&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;element;<br>};<br><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;Your&nbsp;MinStack&nbsp;object&nbsp;will&nbsp;be&nbsp;instantiated&nbsp;and&nbsp;called&nbsp;as&nbsp;such:<br>&nbsp;*&nbsp;var&nbsp;obj&nbsp;=&nbsp;new&nbsp;MinStack()<br>&nbsp;*&nbsp;obj.push(x)<br>&nbsp;*&nbsp;obj.pop()<br>&nbsp;*&nbsp;var&nbsp;param_3&nbsp;=&nbsp;obj.top()<br>&nbsp;*&nbsp;var&nbsp;param_4&nbsp;=&nbsp;obj.getMin()<br>&nbsp;*/</span><br></code>
```

### 【系列】下一个更大元素 【栈】

-   👉 【LeetCode 直通车】：496 下一个更大元素 I（简单）<sup data-darkreader-inline-color="">[52]</sup>
    
-   👉 【LeetCode 直通车】：503 下一个更大元素 II（中等）<sup data-darkreader-inline-color="">[53]</sup>
    

受限于篇幅，这里只给出第一道题的代码模板

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[]}</span>&nbsp;<span data-darkreader-inline-color="">nums</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number[]}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;nextGreaterElements&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>nums</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;ans&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;stack&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Stack();<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;n&nbsp;=&nbsp;nums.length;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">2</span>&nbsp;*&nbsp;n&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;i&nbsp;&gt;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i--)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(!stack.isEmpty()&nbsp;&amp;&amp;&nbsp;stack.top()&nbsp;&lt;=&nbsp;nums[i&nbsp;%&nbsp;n])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.pop();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans[i&nbsp;%&nbsp;n]&nbsp;=&nbsp;stack.isEmpty()&nbsp;?&nbsp;<span data-darkreader-inline-color="">-1</span>&nbsp;:&nbsp;stack.top();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.push(nums[i&nbsp;%&nbsp;n]);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;ans;<br>};<br><span><span data-darkreader-inline-color="">class</span>&nbsp;<span data-darkreader-inline-color="">Stack</span>&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">constructor</span>()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.count&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.items&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;top()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">this</span>.isEmpty())&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">undefined</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">this</span>.items[<span data-darkreader-inline-color="">this</span>.count&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;push(element)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.items[<span data-darkreader-inline-color="">this</span>.count]&nbsp;=&nbsp;element;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.count++;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;pop()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">this</span>.isEmpty())&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">undefined</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;element&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span>.items[<span data-darkreader-inline-color="">this</span>.count&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">delete</span>&nbsp;<span data-darkreader-inline-color="">this</span>.items[<span data-darkreader-inline-color="">this</span>.count&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.count--;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;element;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;isEmpty()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">this</span>.size()&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;size()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">this</span>.count;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code>
```

### 【面试真题】有效的括号【栈】

👉 【LeetCode 直通车】：20 有效的括号（中等）<sup data-darkreader-inline-color="">[54]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{string}</span>&nbsp;<span data-darkreader-inline-color="">s</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{boolean}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;isValid&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>s</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(s.length&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">true</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(s.length&nbsp;%&nbsp;<span data-darkreader-inline-color="">2</span>&nbsp;!==&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;map&nbsp;=&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">')'</span>:&nbsp;<span data-darkreader-inline-color="">'('</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">']'</span>:&nbsp;<span data-darkreader-inline-color="">'['</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">'}'</span>:&nbsp;<span data-darkreader-inline-color="">'{'</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;left&nbsp;=&nbsp;[<span data-darkreader-inline-color="">'('</span>,&nbsp;<span data-darkreader-inline-color="">'['</span>,&nbsp;<span data-darkreader-inline-color="">'{'</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;right&nbsp;=&nbsp;[<span data-darkreader-inline-color="">')'</span>,&nbsp;<span data-darkreader-inline-color="">']'</span>,&nbsp;<span data-darkreader-inline-color="">'}'</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;stack&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Stack();<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;s.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!right.includes(s[i]))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.push(s[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;matchStr&nbsp;=&nbsp;map[s[i]];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(!stack.isEmpty())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;element&nbsp;=&nbsp;stack.pop();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(left.includes(element)&nbsp;&amp;&amp;&nbsp;matchStr&nbsp;!==&nbsp;element)&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(element&nbsp;===&nbsp;matchStr)&nbsp;<span data-darkreader-inline-color="">break</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;stack.isEmpty();<br>};<br><span><span data-darkreader-inline-color="">class</span>&nbsp;<span data-darkreader-inline-color="">Stack</span>&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">constructor</span>()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.count&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.items&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;push(element)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.items[<span data-darkreader-inline-color="">this</span>.count]&nbsp;=&nbsp;element;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.count++;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;pop()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">this</span>.isEmpty())&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">undefined</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;element&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span>.items[<span data-darkreader-inline-color="">this</span>.count&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">delete</span>&nbsp;<span data-darkreader-inline-color="">this</span>.items[<span data-darkreader-inline-color="">this</span>.count&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.count--;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;element;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;isEmpty()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">this</span>.size()&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;size()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">this</span>.count;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code>
```

### 简化路径【栈】

👉 【LeetCode 直通车】：71 简化路径（中等）<sup data-darkreader-inline-color="">[55]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{string}</span>&nbsp;<span data-darkreader-inline-color="">path</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{string}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;simplifyPath&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>path</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;newPath&nbsp;=&nbsp;path.split(<span data-darkreader-inline-color="">'/'</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;newPath&nbsp;=&nbsp;newPath.filter(<span><span>item</span>&nbsp;=&gt;</span>&nbsp;item&nbsp;!==&nbsp;<span data-darkreader-inline-color="">""</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;stack&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Stack();<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;s&nbsp;<span data-darkreader-inline-color="">of</span>&nbsp;newPath)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(s&nbsp;===&nbsp;<span data-darkreader-inline-color="">'..'</span>)&nbsp;stack.pop();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(s&nbsp;!==&nbsp;<span data-darkreader-inline-color="">'.'</span>)&nbsp;stack.push(s);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(stack.isEmpty())&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">'/'</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;str&nbsp;=&nbsp;<span data-darkreader-inline-color="">''</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(!stack.isEmpty())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;element&nbsp;=&nbsp;stack.pop();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str&nbsp;=&nbsp;<span data-darkreader-inline-color="">'/'</span>&nbsp;+&nbsp;element&nbsp;+&nbsp;str;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;str;<br>};<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">handleBack</span>(<span>stack,&nbsp;tag,&nbsp;num</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!stack.isEmpty())&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;num;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;element&nbsp;=&nbsp;stack.pop();<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(element&nbsp;===&nbsp;<span data-darkreader-inline-color="">'..'</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;handleBack(stack,&nbsp;tag,&nbsp;num&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.push(element);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;num;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><span><span data-darkreader-inline-color="">class</span>&nbsp;<span data-darkreader-inline-color="">Stack</span>&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">constructor</span>()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.count&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.items&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;push(element)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.items[<span data-darkreader-inline-color="">this</span>.count]&nbsp;=&nbsp;element;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.count++;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;pop()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">this</span>.isEmpty())&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">undefined</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;element&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span>.items[<span data-darkreader-inline-color="">this</span>.count&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">delete</span>&nbsp;<span data-darkreader-inline-color="">this</span>.items[<span data-darkreader-inline-color="">this</span>.count&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.count--;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;element;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;size()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">this</span>.count;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;isEmpty()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">this</span>.size()&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code>
```

## 【🔥】高频算法题系列：DFS

主要有以下几类高频考题：

-   岛屿的最大面积【中等】【DFS】
    
-   相同的树【简单】【DFS】
    

### 岛屿的最大面积【DFS】

👉 【LeetCode 直通车】：695 岛屿的最大面积（中等）<sup data-darkreader-inline-color="">[56]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[][]}</span>&nbsp;<span data-darkreader-inline-color="">grid</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">let</span>&nbsp;maxX,&nbsp;maxY;<span data-darkreader-inline-color="">let</span>&nbsp;visited;<span data-darkreader-inline-color="">let</span>&nbsp;globalMaxArea;<br><span data-darkreader-inline-color="">var</span>&nbsp;maxAreaOfIsland&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>grid</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;visited&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Set</span>();<br>&nbsp;&nbsp;&nbsp;&nbsp;maxX&nbsp;=&nbsp;grid.length;<br>&nbsp;&nbsp;&nbsp;&nbsp;maxY&nbsp;=&nbsp;grid[<span data-darkreader-inline-color="">0</span>].length;<br>&nbsp;&nbsp;&nbsp;&nbsp;globalMaxArea&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;maxX;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;j&nbsp;&lt;&nbsp;maxY;&nbsp;j++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(grid[i][j]&nbsp;===&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visited.add(<span data-darkreader-inline-color="">`(<span data-darkreader-inline-color="">${i}</span>,&nbsp;<span data-darkreader-inline-color="">${j}</span>)`</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;globalMaxArea&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.max(globalMaxArea,&nbsp;dfs(grid,&nbsp;i,&nbsp;j));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visited.clear();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;globalMaxArea;<br>};<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">dfs</span>(<span>grid,&nbsp;x,&nbsp;y</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;res&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">-1</span>;&nbsp;i&nbsp;&lt;=&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;<span data-darkreader-inline-color="">-1</span>;&nbsp;j&nbsp;&lt;=&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;j++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">Math</span>.abs(i)&nbsp;===&nbsp;<span data-darkreader-inline-color="">Math</span>.abs(j))&nbsp;<span data-darkreader-inline-color="">continue</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;newX&nbsp;=&nbsp;x&nbsp;+&nbsp;i;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;newY&nbsp;=&nbsp;y&nbsp;+&nbsp;j;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(newX&nbsp;&gt;=&nbsp;maxX&nbsp;||&nbsp;newX&nbsp;&lt;&nbsp;<span data-darkreader-inline-color="">0</span>&nbsp;||&nbsp;newY&nbsp;&gt;=&nbsp;maxY&nbsp;||&nbsp;newY&nbsp;&lt;&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;<span data-darkreader-inline-color="">continue</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(visited.has(<span data-darkreader-inline-color="">`(<span data-darkreader-inline-color="">${newX}</span>,&nbsp;<span data-darkreader-inline-color="">${newY}</span>)`</span>))&nbsp;<span data-darkreader-inline-color="">continue</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visited.add(<span data-darkreader-inline-color="">`(<span data-darkreader-inline-color="">${newX}</span>,&nbsp;<span data-darkreader-inline-color="">${newY}</span>)`</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;areaCnt&nbsp;=&nbsp;grid[newX][newY]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(areaCnt&nbsp;===&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;cnt&nbsp;=&nbsp;dfs(grid,&nbsp;newX,&nbsp;newY);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;+=&nbsp;cnt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;res;<br>}<br></code>
```

### 相同的树【DFS】

👉 【LeetCode 直通车】：100 相同的树（简单）<sup data-darkreader-inline-color="">[57]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;Definition&nbsp;for&nbsp;a&nbsp;binary&nbsp;tree&nbsp;node.<br>&nbsp;*&nbsp;function&nbsp;TreeNode(val)&nbsp;{<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.val&nbsp;=&nbsp;val;<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.left&nbsp;=&nbsp;this.right&nbsp;=&nbsp;null;<br>&nbsp;*&nbsp;}<br>&nbsp;*/</span><br><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{TreeNode}</span>&nbsp;<span data-darkreader-inline-color="">p</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{TreeNode}</span>&nbsp;<span data-darkreader-inline-color="">q</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{boolean}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;isSameTree&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>p,&nbsp;q</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(p&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>&nbsp;&amp;&amp;&nbsp;q&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">true</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(p&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>&nbsp;||&nbsp;q&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(p.val&nbsp;!==&nbsp;q.val)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;isSameTree(p.left,&nbsp;q.left)&nbsp;&amp;&amp;&nbsp;isSameTree(p.right,&nbsp;q.right);<br>};<br></code>
```

## 【🔥】高频算法题系列：回溯算法

主要有以下几类高频考题：

-   N皇后【困难】【回溯算法】【面试真题】
    
-   全排列【中等】【回溯算法】
    
-   括号生成【中等】【回溯算法】
    
-   复原 IP 地址【中等】【回溯算法】
    
-   子集 【简单】【回溯算法】
    

### 【面试真题】N皇后【回溯算法】

👉 【LeetCode 直通车】：51 N皇后（困难）<sup data-darkreader-inline-color="">[58]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number}</span>&nbsp;<span data-darkreader-inline-color="">n</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{string[][]}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">let</span>&nbsp;result&nbsp;=&nbsp;[];<span data-darkreader-inline-color="">var</span>&nbsp;solveNQueens&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>n</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;board&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board[i]&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;j&nbsp;&lt;&nbsp;n;&nbsp;j++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board[i][j]&nbsp;=&nbsp;<span data-darkreader-inline-color="">'.'</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;backtrack(<span data-darkreader-inline-color="">0</span>,&nbsp;board,&nbsp;n);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;result;<br>};<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">deepClone</span>(<span>board</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;res&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;board.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;res.push(board[i].join(<span data-darkreader-inline-color="">''</span>));<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;res;<br>}<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">backtrack</span>(<span>row,&nbsp;board,&nbsp;n</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(row&nbsp;===&nbsp;n)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push(deepClone(board));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;j&nbsp;&lt;&nbsp;n;&nbsp;j++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(checkInValid(board,&nbsp;row,&nbsp;j,&nbsp;n))&nbsp;<span data-darkreader-inline-color="">continue</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board[row][j]&nbsp;=&nbsp;<span data-darkreader-inline-color="">'Q'</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backtrack(row&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>,&nbsp;board,&nbsp;n);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board[row][j]&nbsp;=&nbsp;<span data-darkreader-inline-color="">'.'</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">checkInValid</span>(<span>board,&nbsp;row,&nbsp;column,&nbsp;n</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;行</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(board[i][column]&nbsp;===&nbsp;<span data-darkreader-inline-color="">'Q'</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">true</span>;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;row&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>,&nbsp;j&nbsp;=&nbsp;column&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;i&nbsp;&gt;=&nbsp;<span data-darkreader-inline-color="">0</span>&nbsp;&amp;&amp;&nbsp;j&nbsp;&lt;&nbsp;n;&nbsp;i--,&nbsp;j++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(board[i][j]&nbsp;===&nbsp;<span data-darkreader-inline-color="">'Q'</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">true</span>;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;row&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>,&nbsp;j&nbsp;=&nbsp;column&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;i&nbsp;&gt;=&nbsp;<span data-darkreader-inline-color="">0</span>&nbsp;&amp;&amp;&nbsp;j&nbsp;&gt;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i--,&nbsp;j--)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(board[i][j]&nbsp;===&nbsp;<span data-darkreader-inline-color="">'Q'</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">true</span>;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span>;<br>}<br></code>
```

### 全排列【回溯算法】

👉 【LeetCode 直通车】：46 全排列（中等）<sup data-darkreader-inline-color="">[59]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[]}</span>&nbsp;<span data-darkreader-inline-color="">nums</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number[][]}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">let</span>&nbsp;results&nbsp;=&nbsp;[];<span data-darkreader-inline-color="">var</span>&nbsp;permute&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>nums</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;results&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;backtrack(nums,&nbsp;[]);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;results;<br>};<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">backtrack</span>(<span>nums,&nbsp;track</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(nums.length&nbsp;===&nbsp;track.length)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;results.push(track.slice());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;nums.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(track.includes(nums[i]))&nbsp;<span data-darkreader-inline-color="">continue</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;track.push(nums[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backtrack(nums,&nbsp;track);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;track.pop();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code>
```

### 括号生成【回溯算法】

👉 【LeetCode 直通车】：22 括号生成（中等）<sup data-darkreader-inline-color="">[60]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number}</span>&nbsp;<span data-darkreader-inline-color="">n</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{string[]}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;generateParenthesis&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>n</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;validRes&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;backtrack(n&nbsp;*&nbsp;<span data-darkreader-inline-color="">2</span>,&nbsp;validRes,&nbsp;<span data-darkreader-inline-color="">''</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;validRes;<br>};<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">backtrack</span>(<span>len,&nbsp;validRes,&nbsp;bracket</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(bracket.length&nbsp;===&nbsp;len)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(isValidCombination(bracket))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;validRes.push(bracket);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;str&nbsp;<span data-darkreader-inline-color="">of</span>&nbsp;[<span data-darkreader-inline-color="">'('</span>,&nbsp;<span data-darkreader-inline-color="">')'</span>])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bracket&nbsp;+=&nbsp;str;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backtrack(len,&nbsp;validRes,&nbsp;bracket);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bracket&nbsp;=&nbsp;bracket.slice(<span data-darkreader-inline-color="">0</span>,&nbsp;bracket.length&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">isValidCombination</span>(<span>bracket</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;stack&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Stack();<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;bracket.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;str&nbsp;=&nbsp;bracket[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(str&nbsp;===&nbsp;<span data-darkreader-inline-color="">'('</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.push(str);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(str&nbsp;===&nbsp;<span data-darkreader-inline-color="">')'</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;top&nbsp;=&nbsp;stack.pop();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(top&nbsp;!==&nbsp;<span data-darkreader-inline-color="">'('</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;stack.isEmpty();<br>}<br><span><span data-darkreader-inline-color="">class</span>&nbsp;<span data-darkreader-inline-color="">Stack</span>&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">constructor</span>()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.count&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.items&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;push(element)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.items[<span data-darkreader-inline-color="">this</span>.count]&nbsp;=&nbsp;element;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.count++;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;pop()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">this</span>.isEmpty())&nbsp;<span data-darkreader-inline-color="">return</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;element&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span>.items[<span data-darkreader-inline-color="">this</span>.count&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">delete</span>&nbsp;<span data-darkreader-inline-color="">this</span>.items[<span data-darkreader-inline-color="">this</span>.count&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.count--;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;element;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;size()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">this</span>.count;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;isEmpty()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">this</span>.size()&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code>
```

### 复原 IP 地址【回溯算法】

👉 【LeetCode 直通车】：93 复原 IP 地址（中等）<sup data-darkreader-inline-color="">[61]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{string}</span>&nbsp;<span data-darkreader-inline-color="">s</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{string[]}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;restoreIpAddresses&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>s</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(s.length&nbsp;&gt;&nbsp;<span data-darkreader-inline-color="">12</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;res&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;track&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;backtrack(s,&nbsp;track,&nbsp;res);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;res;<br>};<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">backtrack</span>(<span>s,&nbsp;track,&nbsp;res</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(track.length&nbsp;===&nbsp;<span data-darkreader-inline-color="">4</span>&nbsp;&amp;&amp;&nbsp;s.length&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.push(track.join(<span data-darkreader-inline-color="">'.'</span>));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;len&nbsp;=&nbsp;s.length&nbsp;&gt;=&nbsp;<span data-darkreader-inline-color="">3</span>&nbsp;?&nbsp;<span data-darkreader-inline-color="">3</span>&nbsp;:&nbsp;s.length;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;len;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;c&nbsp;=&nbsp;s.slice(<span data-darkreader-inline-color="">0</span>,&nbsp;i&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">parseInt</span>(c)&nbsp;&gt;&nbsp;<span data-darkreader-inline-color="">255</span>)&nbsp;<span data-darkreader-inline-color="">continue</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(i&nbsp;&gt;=&nbsp;<span data-darkreader-inline-color="">1</span>&nbsp;&amp;&amp;&nbsp;&nbsp;<span data-darkreader-inline-color="">parseInt</span>(c)&nbsp;&lt;&nbsp;<span data-darkreader-inline-color="">parseInt</span>((<span data-darkreader-inline-color="">1</span>&nbsp;+&nbsp;<span data-darkreader-inline-color="">'0'</span>.repeat(i))))&nbsp;<span data-darkreader-inline-color="">continue</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;track.push(c);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backtrack(s.slice(i&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>),&nbsp;track,&nbsp;res);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;track.pop();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code>
```

### 子集【回溯算法】

👉 【LeetCode 直通车】：78 子集（中等）<sup data-darkreader-inline-color="">[62]</sup>

#### 题解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">/**<br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@param&nbsp;<span data-darkreader-inline-color="">{number[]}</span>&nbsp;<span data-darkreader-inline-color="">nums</span></span><br>&nbsp;*&nbsp;<span data-darkreader-inline-color="">@return&nbsp;<span data-darkreader-inline-color="">{number[][]}</span></span><br>&nbsp;*/</span><br><span data-darkreader-inline-color="">var</span>&nbsp;subsets&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>nums</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(nums.length&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;[[]];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;resArr&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;backtrack(nums,&nbsp;<span data-darkreader-inline-color="">0</span>,&nbsp;[],&nbsp;resArr);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;resArr;<br>};<br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">backtrack</span>(<span>nums,&nbsp;index,&nbsp;subArr,&nbsp;resArr</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">Array</span>.isArray(subArr))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resArr.push(subArr.slice());<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(index&nbsp;===&nbsp;nums.length)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;index;&nbsp;i&nbsp;&lt;&nbsp;nums.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subArr.push(nums[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backtrack(nums,&nbsp;i&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>,&nbsp;subArr,&nbsp;resArr);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subArr.pop(nums[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code>
```

## 文末福利

推荐一个非常有帮助的刷算法题的网址，labuladong 的算法小抄<sup data-darkreader-inline-color="">[63]</sup>，通过套路，认准高频题目，直通大厂；这本小炒目前已经出版成书，对应的 Github 仓库<sup data-darkreader-inline-color="">[64]</sup>也有 86.2K Star，而且作者还在频繁更新，非常值得学习！

## ❤️谢谢

### **往期精文**

-   字节跳动最爱考的前端面试题:JavaScript 基础<sup data-darkreader-inline-color="">[65]</sup>  2696 👍
    
-   字节跳动最爱考的前端面试题:CSS 基础<sup data-darkreader-inline-color="">[66]</sup> 687 👍
    
-   字节跳动最爱考的前端面试题:计算机网络基础<sup data-darkreader-inline-color="">[67]</sup> 761 👍
    

欢迎关注公众号：[图雀社区](https://mp.weixin.qq.com/s?__biz=MzA5NTcxOTcyMg==&mid=2247491023&idx=1&sn=ee31128669ad3ba59ea50d5eafd0f397&scene=21#wechat_redirect)。 如果你想从零开始以实战的方式学习一门技术，亦或是想动手做一个比较完整的项目以准备面试，相信 **「图雀社区」** 的内容都能够帮助到你，成为初入前端的你成长路上的指南针。

### 原创不易

喜欢的话原创不易，给点鼓励吧 ❤️ 别忘了 分享、点赞、在看 三连哦~。

### 参考资料

\[1\]

【LeetCode 直通车】：234 回文链表（简单）: _https://leetcode-cn.com/problems/palindrome-linked-list/_

\[2\]

【LeetCode 直通车】：206 反转链表（简单）: _https://leetcode-cn.com/problems/reverse-linked-list/_

\[3\]

【LeetCode 直通车】：23 合并K个升序链表（困难）: _https://leetcode-cn.com/problems/merge-k-sorted-lists/_

\[4\]

【LeetCode 直通车】：25 K 个一组翻转链表（困难）: _https://leetcode-cn.com/problems/reverse-nodes-in-k-group/_

\[5\]

【LeetCode 直通车】：141 环形链表（简单）: _https://leetcode-cn.com/problems/linked-list-cycle/_

\[6\]

【LeetCode 直通车】：148 排序链表（中等）: _https://leetcode-cn.com/problems/sort-list/_

\[7\]

【LeetCode 直通车】：160 相交链表（简单）: _https://leetcode-cn.com/problems/intersection-of-two-linked-lists/_

\[8\]

【LeetCode 直通车】：5 最长回文子串（中等）: _https://leetcode-cn.com/problems/longest-palindromic-substring/_

\[9\]

【LeetCode 直通车】：14 最长公共前缀（简单）: _https://leetcode-cn.com/problems/longest-common-prefix/_

\[10\]

【LeetCode 直通车】：3 无重复字符的最长子串（中等）: _https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/_

\[11\]

【LeetCode 直通车】：76 最小覆盖子串（困难）: _https://leetcode-cn.com/problems/minimum-window-substring/_

\[12\]

【LeetCode 直通车】：354 俄罗斯套娃信封问题（困难）: _https://leetcode-cn.com/problems/russian-doll-envelopes/_

\[13\]

【LeetCode 直通车】：674 最长连续递增序列（简单）: _https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/_

\[14\]

【LeetCode 直通车】：128 最长连续序列（困难）: _https://leetcode-cn.com/problems/longest-consecutive-sequence/_

\[15\]

【LeetCode 直通车】：11 盛最多水的容器（中等）: _https://leetcode-cn.com/problems/container-with-most-water/_

\[16\]

【LeetCode 直通车】：4 寻找两个正序数组的中位数（困难）: _https://leetcode-cn.com/problems/median-of-two-sorted-arrays/_

\[17\]

【LeetCode 直通车】：26 删除有序数组中的重复项（简单）: _https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/_

\[18\]

【LeetCode 直通车】：695 岛屿的最大面积（中等）: _https://leetcode-cn.com/problems/max-area-of-island/_

\[19\]

【LeetCode 直通车】：560 和为K的子数组（中等）: _https://leetcode-cn.com/problems/subarray-sum-equals-k/_

\[20\]

【LeetCode 直通车】：1 两数之和（简单）: _https://leetcode-cn.com/problems/two-sum/_

\[21\]

【LeetCode 直通车】：167 两数之和 II - 输入有序数组（简单）: _https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/_

\[22\]

【LeetCode 直通车】：15 三数之和（中等）: _https://leetcode-cn.com/problems/3sum/_

\[23\]

【LeetCode 直通车】：18 四数之和（中等）: _https://leetcode-cn.com/problems/4sum/_

\[24\]

【LeetCode 直通车】：42 接雨水（困难）: _https://leetcode-cn.com/problems/trapping-rain-water/_

\[25\]

【LeetCode 直通车】：55 跳跃游戏（中等）: _https://leetcode-cn.com/problems/jump-game/_

\[26\]

【LeetCode 直通车】：45 跳跃游戏 II（中等）: _https://leetcode-cn.com/problems/jump-game-ii/_

\[27\]

【LeetCode 直通车】：236 二叉树的最近公共祖先（简单）: _https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/_

\[28\]

【LeetCode 直通车】：700 二叉搜索树中的搜索（简单）: _https://leetcode-cn.com/problems/search-in-a-binary-search-tree/_

\[29\]

【LeetCode 直通车】：450 删除二叉搜索树中的节点（中等）: _https://leetcode-cn.com/problems/delete-node-in-a-bst/_

\[30\]

【LeetCode 直通车】：222 完全二叉树的节点个数（中等）: _https://leetcode-cn.com/problems/count-complete-tree-nodes/_

\[31\]

【LeetCode 直通车】：103 二叉树的锯齿形层序遍历（中等）: _https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/_

\[32\]

【LeetCode 直通车】：452 用最少数量的箭引爆气球（中等）: _https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/_

\[33\]

【LeetCode 直通车】：56 合并区间（中等）: _https://leetcode-cn.com/problems/merge-intervals/_

\[34\]

【LeetCode 直通车】：4 寻找两个正序数组的中位数（困难）: _https://leetcode-cn.com/problems/median-of-two-sorted-arrays/_

\[35\]

【LeetCode 直通车】：392 判断子序列（简单）: _https://leetcode-cn.com/problems/is-subsequence/_

\[36\]

【LeetCode 直通车】：34 在排序数组中查找元素的第一个和最后一个位置（中等）: _https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/_

\[37\]

【LeetCode 直通车】：300 最长递增子序列（中等）: _https://leetcode-cn.com/problems/longest-increasing-subsequence/_

\[38\]

【LeetCode 直通车】：322 零钱兑换（中等）: _https://leetcode-cn.com/problems/coin-change/_

\[39\]

【LeetCode 直通车】：1143 最长公共子序列（中等）: _https://leetcode-cn.com/problems/longest-common-subsequence/_

\[40\]

【LeetCode 直通车】：72 编辑距离（困难）: _https://leetcode-cn.com/problems/edit-distance/_

\[41\]

【LeetCode 直通车】：516 最长回文子序列（中等）: _https://leetcode-cn.com/problems/longest-palindromic-subsequence/_

\[42\]

【LeetCode 直通车】：53 最大子序和（简单）: _https://leetcode-cn.com/problems/maximum-subarray/_

\[43\]

【LeetCode 直通车】：121 买卖股票的最佳时机（简单）: _https://leetcode-cn.com/problems/container-with-most-water/_

\[44\]

【LeetCode 直通车】：122 买卖股票的最佳时机 II（简单）: _https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/_

\[45\]

【LeetCode 直通车】：123 买卖股票的最佳时机 III（困难）: _https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/_

\[46\]

【LeetCode 直通车】：188 买卖股票的最佳时机IV（困难）: _https://leetcode-cn.com/problems/container-with-most-water/_

\[47\]

【LeetCode 直通车】：309 买卖股票的最佳时机含冷冻期（中等）: _https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/_

\[48\]

【LeetCode 直通车】：714 买卖股票的最佳时机含手续费（中等）: _https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/_

\[49\]

【LeetCode 直通车】：752 打开转盘锁（中等）: _https://leetcode-cn.com/problems/open-the-lock/_

\[50\]

【LeetCode 直通车】：111 二叉树的最小深度（简单）: _https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/_

\[51\]

【LeetCode 直通车】：155 最小栈（简单）: _https://leetcode-cn.com/problems/min-stack/submissions/_

\[52\]

【LeetCode 直通车】：496 下一个更大元素 I（简单）: _https://leetcode-cn.com/problems/next-greater-element-i/_

\[53\]

【LeetCode 直通车】：503 下一个更大元素 II（中等）: _https://leetcode-cn.com/problems/next-greater-element-ii/_

\[54\]

【LeetCode 直通车】：20 有效的括号（中等）: _https://leetcode-cn.com/problems/valid-parentheses/_

\[55\]

【LeetCode 直通车】：71 简化路径（中等）: _https://leetcode-cn.com/problems/simplify-path/_

\[56\]

【LeetCode 直通车】：695 岛屿的最大面积（中等）: _https://leetcode-cn.com/problems/max-area-of-island/_

\[57\]

【LeetCode 直通车】：100 相同的树（简单）: _https://leetcode-cn.com/problems/same-tree/_

\[58\]

【LeetCode 直通车】：51 N皇后（困难）: _https://leetcode-cn.com/problems/n-queens/_

\[59\]

【LeetCode 直通车】：46 全排列（中等）: _https://leetcode-cn.com/problems/permutations/_

\[60\]

【LeetCode 直通车】：22 括号生成（中等）: _https://leetcode-cn.com/problems/generate-parentheses/_

\[61\]

【LeetCode 直通车】：93 复原 IP 地址（中等）: _https://leetcode-cn.com/problems/restore-ip-addresses/_

\[62\]

【LeetCode 直通车】：78 子集（中等）: _https://leetcode-cn.com/problems/subsets/_

\[63\]

labuladong 的算法小抄: _https://www.yuque.com/tuture/interview/labuladong：https_

\[64\]

Github 仓库: _https://github.com/labuladong/fucking-algorithm_

\[65\]

字节跳动最爱考的前端面试题:JavaScript 基础: _https://juejin.cn/post/6934500357091360781_

\[66\]

字节跳动最爱考的前端面试题:CSS 基础: _https://juejin.cn/post/6936913689115099143_

\[67\]

字节跳动最爱考的前端面试题:计算机网络基础: _https://juejin.cn/post/6939691851746279437_