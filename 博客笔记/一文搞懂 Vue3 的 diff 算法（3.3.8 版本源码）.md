Vue3 已经发布很久很久很久了，今天就来一起了解一下 Vue3 最新的 diff 算法，Vue2 的 diff 算法可以看一下之前发的文章[Vue2源码系列-9张图搞懂diff算法](http://mp.weixin.qq.com/s?__biz=MzkxMjIwMzY3MA==&mid=2247483995&idx=1&sn=0bf839a428d011f59f5bbdf14ec4f07b&chksm=c111c8a2f66641b4f9ecf0f08208da684046df194e5cdc48c743de07743e633dda4e731767c2&scene=21#wechat_redirect)。

今天没有段子

![Image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/jvk5ko4Osp7qibE1DUFgumfNsm8J3LKfkT2vxAuXuBt4fIHVdM1zC0t6vYbbOsAZrfkTEQ1rb3icy9nBC5yvc72Q/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## 准备工作

### 版本

本文使用 Vue3 的 `3.3.8` 版本

### 示例

为了更直观理解与解读，使用以下示例代码配合讲解

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">&lt;<span data-darkreader-inline-color="">div</span>&nbsp;<span data-darkreader-inline-color="">id</span>=<span data-darkreader-inline-color="">"demo"</span>&gt;</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">&lt;<span data-darkreader-inline-color="">ul</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">&lt;<span data-darkreader-inline-color="">li</span>&nbsp;<span data-darkreader-inline-color="">v-for</span>=<span data-darkreader-inline-color="">"item&nbsp;in&nbsp;items"</span>&nbsp;<span data-darkreader-inline-color="">:key</span>=<span data-darkreader-inline-color="">"item"</span>&gt;</span>{{item}}<span data-darkreader-inline-color="">&lt;/<span data-darkreader-inline-color="">li</span>&gt;</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">&lt;/<span data-darkreader-inline-color="">ul</span>&gt;</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">&lt;<span data-darkreader-inline-color="">button</span>&nbsp;@<span data-darkreader-inline-color="">click</span>=<span data-darkreader-inline-color="">"changeOrder"</span>&gt;</span>塔塔开<span data-darkreader-inline-color="">&lt;/<span data-darkreader-inline-color="">button</span>&gt;</span><br><span data-darkreader-inline-color="">&lt;/<span data-darkreader-inline-color="">div</span>&gt;</span><br><span data-darkreader-inline-color="">&lt;<span data-darkreader-inline-color="">script</span>&gt;</span><span><br>&nbsp;&nbsp;Vue.createApp({<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">data</span>:&nbsp;<span><span>()</span>&nbsp;=&gt;</span>&nbsp;({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">items</span>:&nbsp;[<span data-darkreader-inline-color="">"a"</span>,&nbsp;<span data-darkreader-inline-color="">"b"</span>,&nbsp;<span data-darkreader-inline-color="">"c"</span>,&nbsp;<span data-darkreader-inline-color="">"d"</span>],<br>&nbsp;&nbsp;&nbsp;&nbsp;}),<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">methods</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;changeOrder()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.items&nbsp;=&nbsp;[<span data-darkreader-inline-color="">"b"</span>,&nbsp;<span data-darkreader-inline-color="">"d"</span>,&nbsp;<span data-darkreader-inline-color="">"e"</span>,&nbsp;<span data-darkreader-inline-color="">"c"</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;}).mount(<span data-darkreader-inline-color="">"#demo"</span>);<br></span><span data-darkreader-inline-color="">&lt;/<span data-darkreader-inline-color="">script</span>&gt;</span><br></code>
```

### 名词解释

#### 虚拟 DOM

> 虚拟 DOM (Virtual DOM，简称 VDOM) 是一种编程概念，意为将目标所需的 UI 通过数据结构“虚拟”地表示出来，保存在内存中，然后将真实的 DOM 与之保持同步。

> 这里所说的 vnode 即一个纯 JavaScript 的对象 (一个“虚拟节点”)，它代表着一个 `<div>` 元素。

#### 虚拟 DOM 树

顾名思义，也就是一个虚拟 DOM 作为根节点，包含有一个或多个的子虚拟 DOM。

#### diff

在 Vue 中，我们改变原来的数据，例如示例中的数组 items，那么 Vue 中会再生成一份虚拟 DOM 树，现在我们就有了两份虚拟 DOM 树。

这时候渲染器将会找出它们之间的区别，并将其中的变化应用到真实的 DOM 上。这个过程被称为 `更新 (patch)`，又被称为 `比对（diffing）` 或 `协调（reconciliation）`。

## 流程概述

不带 key 的新虚拟 DOM 树

1.  从前往后遍历新旧虚拟 DOM 树，将旧虚拟 DOM 更新为新虚拟 DOM
    
2.  比较新旧虚拟 DOM 树的长度，处理新增与删除的节点
    

带 key 的新虚拟 DOM 树

1.  从前往后遍历新旧虚拟 DOM 树，寻找可复用节点，遇到不可复用节点跳出循环
    
2.  从后往前遍历新旧虚拟 DOM 树，寻找可复用节点，遇到不可复用节点跳出循环
    
3.  对比前两次遍历的索引
    

-   旧节点有 key 值，直接在 Map 中寻找
    
-   旧节点不带 key 值，遍历剩余新节点，判断是否可复用
    
-   找到新节点索引，更新 newIndexToOldIndexMap；没有找到就是不存在，直接卸载
    

-   在 newIndexToOldIndexMap 中的值为 0 的，是新节点
    
-   不为 0 的，进一步判断是否在最长稳定序列中，不在就移动
    
-   识别出两侧与中间的新增与删除的节点
    
-   处理未识别出的节点
    

1.  遍历新节点，生成新节点的 key 与 index 对应的 Map
    
2.  创建将要 patch 的节点数组 newIndexToOldIndexMap（下标为新节点索引，值为旧节点索引+1）
    
3.  遍历剩余节点，寻找新节点 key 值对应的旧节点索引
    
4.  根据 newIndexToOldIndexMap 生成最长稳定序列
    
5.  从后往前遍历需要 patch 的节点
    

不喜欢看源码的，看到这里就可以了

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

___

## 源码详解

还往下翻？看来是觉得只看概述不过瘾？

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

那就一起来扒一下源码，加深一下印象吧

### Patch

一切的一切还要从 `patch` 方法讲起。

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">const</span>&nbsp;patch:&nbsp;PatchFn&nbsp;=&nbsp;<span>(<span>...</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;patch&nbsp;方法首先判断传入的两个虚拟&nbsp;DOM&nbsp;是否完全一致，完全一致直接跳出&nbsp;patch</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(n1&nbsp;===&nbsp;n2)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;进一步判断新旧虚拟节点的&nbsp;type&nbsp;与&nbsp;key&nbsp;值是否一致，不一致将直接卸载旧虚拟节点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(n1&nbsp;&amp;&amp;&nbsp;!isSameVNodeType(n1,&nbsp;n2))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;anchor&nbsp;=&nbsp;getNextHostNode(n1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unmount(n1,&nbsp;parentComponent,&nbsp;parentSuspense,&nbsp;<span data-darkreader-inline-color="">true</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n1&nbsp;=&nbsp;<span data-darkreader-inline-color="">null</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;非编译器生成，不走&nbsp;optimized&nbsp;模式</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(n2.patchFlag&nbsp;===&nbsp;PatchFlags.BAIL)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;optimized&nbsp;=&nbsp;<span data-darkreader-inline-color="">false</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n2.dynamicChildren&nbsp;=&nbsp;<span data-darkreader-inline-color="">null</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;{&nbsp;<span data-darkreader-inline-color="">type</span>,&nbsp;ref,&nbsp;shapeFlag&nbsp;}&nbsp;=&nbsp;n2<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;根据&nbsp;新虚拟节点&nbsp;的不同类型（type）使用不同的处理函数</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">switch</span>&nbsp;(<span data-darkreader-inline-color="">type</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">// 1. 文本：处理方式简单粗暴，直接往容器追加文本节点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">case</span>&nbsp;Text:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processText(n1,&nbsp;n2,&nbsp;container,&nbsp;anchor)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">break</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">// 2. 组件节点：处理方式是先创建该组件，再往容器内追加</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">case</span>&nbsp;Comment:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processCommentNode(n1,&nbsp;n2,&nbsp;container,&nbsp;anchor)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">break</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">// 3. 静态节点：处理方式直接挂载节点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">case</span>&nbsp;Static:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(n1&nbsp;==&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mountStaticNode(n2,&nbsp;container,&nbsp;anchor,&nbsp;isSVG)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(__DEV__)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patchStaticNode(n1,&nbsp;n2,&nbsp;container,&nbsp;isSVG)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">break</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">// 4. Fragment：Vue3 新组件，走&nbsp;`processFragment`&nbsp;处理函数</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">case</span>&nbsp;Fragment:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processFragment(...)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">break</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">default</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果都不是上述的类型，那就需要再分，这一次不根据 type（Symbol 标记），而是 shapeFlag（位运算）继续细分类型：</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(shapeFlag&nbsp;&amp;&nbsp;ShapeFlags.ELEMENT)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;对应真实&nbsp;DOM&nbsp;节点，处理方式挂载节点（初始化）或走&nbsp;patchElement&nbsp;函数（处理&nbsp;hook，若存在子节点也将走到&nbsp;`patchChildren`）</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processElement(...)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(shapeFlag&nbsp;&amp;&nbsp;ShapeFlags.COMPONENT)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;vue&nbsp;组件，处理方式就是挂载或更新组件</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processComponent(...)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(shapeFlag&nbsp;&amp;&nbsp;ShapeFlags.TELEPORT)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;vue3&nbsp;新组件，可自行了解&nbsp;☞&nbsp;https://cn.vuejs.org/guide/built-ins/teleport.html</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;(<span data-darkreader-inline-color="">type</span>&nbsp;<span data-darkreader-inline-color="">as</span>&nbsp;<span data-darkreader-inline-color="">typeof</span>&nbsp;TeleportImpl).process(...)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(__FEATURE_SUSPENSE__&nbsp;&amp;&amp;&nbsp;shapeFlag&nbsp;&amp;&nbsp;ShapeFlags.SUSPENSE)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;vue3&nbsp;新组件，可自行了解&nbsp;☞&nbsp;https://cn.vuejs.org/guide/built-ins/suspense.html</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;(<span data-darkreader-inline-color="">type</span>&nbsp;<span data-darkreader-inline-color="">as</span>&nbsp;<span data-darkreader-inline-color="">typeof</span>&nbsp;SuspenseImpl).process(...)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(__DEV__)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;warn(<span data-darkreader-inline-color="">'Invalid&nbsp;VNode&nbsp;type:'</span>,&nbsp;<span data-darkreader-inline-color="">type</span>,&nbsp;<span data-darkreader-inline-color="">`(<span data-darkreader-inline-color="">${<span data-darkreader-inline-color="">typeof</span>&nbsp;<span data-darkreader-inline-color="">type</span>}</span>)`</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;挂&nbsp;ref</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(ref&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>&nbsp;&amp;&amp;&nbsp;parentComponent)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setRef(ref,&nbsp;n1&nbsp;&amp;&amp;&nbsp;n1.ref,&nbsp;parentSuspense,&nbsp;n2&nbsp;||&nbsp;n1,&nbsp;!n2)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br></code>
```

以我们的示例代码为例，在我们按下按钮后，发生变化的是节点 li；在 Vue3 中一个组件如果有多个子节点会为其创建一个包裹，也即 Fragment 组件

同样的，`v-for` 也会为其创建一个包裹；因此，这里的 patch 类型会是 Fragment，将走到 processFragment 函数。

还是以我们的示例代码为例，processFragment 函数在节点更新时会走到 `patchChildren` 函数，这里就不贴代码了。

### patchChildren

处理新旧两份虚拟子节点

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">const</span>&nbsp;patchChildren:&nbsp;PatchChildrenFn&nbsp;=&nbsp;<span>(<span>...</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;取一哈新旧虚拟节点的子节点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;c1&nbsp;=&nbsp;n1&nbsp;&amp;&amp;&nbsp;n1.children<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;prevShapeFlag&nbsp;=&nbsp;n1&nbsp;?&nbsp;n1.shapeFlag&nbsp;:&nbsp;<span data-darkreader-inline-color="">0</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;c2&nbsp;=&nbsp;n2.children<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;{&nbsp;patchFlag,&nbsp;shapeFlag&nbsp;}&nbsp;=&nbsp;n2<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(patchFlag&nbsp;&gt;&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">// patchFlag &gt;&nbsp;0&nbsp;就表示子节点含有动态属性，如：动态style、动态class、动态文案等</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(patchFlag&nbsp;&amp;&nbsp;PatchFlags.KEYED_FRAGMENT)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;子节点带&nbsp;key</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patchKeyedChildren(...)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(patchFlag&nbsp;&amp;&nbsp;PatchFlags.UNKEYED_FRAGMENT)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;子节点不带&nbsp;key</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patchUnkeyedChildren(...)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;子节点存在3种可能的情况：文本、数组、没有子节点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(shapeFlag&nbsp;&amp;&nbsp;ShapeFlags.TEXT_CHILDREN)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;新虚拟节点的子节点是文本</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(prevShapeFlag&nbsp;&amp;&nbsp;ShapeFlags.ARRAY_CHILDREN)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;对应的旧虚拟节点的子节点是数组</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;卸载旧虚拟节点的数组子节点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unmountChildren(c1&nbsp;<span data-darkreader-inline-color="">as</span>&nbsp;VNode[],&nbsp;parentComponent,&nbsp;parentSuspense)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;再挂载新虚拟节点的文本子节点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(c2&nbsp;!==&nbsp;c1)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hostSetElementText(container,&nbsp;c2&nbsp;<span data-darkreader-inline-color="">as</span>&nbsp;<span data-darkreader-inline-color="">string</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(prevShapeFlag&nbsp;&amp;&nbsp;ShapeFlags.ARRAY_CHILDREN)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;旧虚拟节点的子节点是数组</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(shapeFlag&nbsp;&amp;&nbsp;ShapeFlags.ARRAY_CHILDREN)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;新虚拟节点的子节点也是数组，做全量diff</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patchKeyedChildren(...)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;能走到这就说明新虚拟节点没有子节点，这里只需要卸载久虚拟节点的子节点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unmountChildren(c1&nbsp;<span data-darkreader-inline-color="">as</span>&nbsp;VNode[],&nbsp;parentComponent,&nbsp;parentSuspense,&nbsp;<span data-darkreader-inline-color="">true</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;走到这就说明</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;旧虚拟节点的子节点要么是文本要么也没有子节点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;新虚拟节点的子节点要么是数组要么就没有子节点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(prevShapeFlag&nbsp;&amp;&nbsp;ShapeFlags.TEXT_CHILDREN)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;旧虚拟节点的子节点是文本，更新</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hostSetElementText(container,&nbsp;<span data-darkreader-inline-color="">''</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(shapeFlag&nbsp;&amp;&nbsp;ShapeFlags.ARRAY_CHILDREN)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;新虚拟节点的子节点是数组，挂载</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mountChildren(...)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br></code>
```

### patchUnkeyedChildren

这里我们先看一下不带 key 是怎么处理的

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">const</span>&nbsp;patchUnkeyedChildren&nbsp;=&nbsp;<span>(<span>...</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;c1&nbsp;=&nbsp;c1&nbsp;||&nbsp;EMPTY_ARR;<br>&nbsp;&nbsp;c2&nbsp;=&nbsp;c2&nbsp;||&nbsp;EMPTY_ARR;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;oldLength&nbsp;=&nbsp;c1.length;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;newLength&nbsp;=&nbsp;c2.length;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;commonLength&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.min(oldLength,&nbsp;newLength);<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;i;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;依次从头遍历，将旧的虚拟节点更新为新节点</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;commonLength;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;nextChild&nbsp;=&nbsp;(c2[i]&nbsp;=&nbsp;optimized<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;cloneIfMounted(c2[i]&nbsp;<span data-darkreader-inline-color="">as</span>&nbsp;VNode)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;normalizeVNode(c2[i]));<br>&nbsp;&nbsp;&nbsp;&nbsp;patch(...);<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(oldLength&nbsp;&gt;&nbsp;newLength)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;旧虚拟节点的子节点长度更大，说明被删除了</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;卸载多余的旧虚拟节点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;unmountChildren(...);<br>&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;反之，存在新增的节点，挂载</span><br>&nbsp;&nbsp;&nbsp;&nbsp;mountChildren(...);<br>&nbsp;&nbsp;}<br>};<br></code>
```

### patchKeyedChildren

我们示例中的 li 都带了 key，因此下一步直接走到 `patchKeyedChildren` 函数，也是 diff 算法优化的重点

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">const</span>&nbsp;patchKeyedChildren&nbsp;=&nbsp;<span>(<span>...</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;l2&nbsp;=&nbsp;c2.length;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;e1&nbsp;=&nbsp;c1.length&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;<span data-darkreader-inline-color="">//&nbsp;旧虚拟&nbsp;DOM&nbsp;树的末尾节点索引</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;e2&nbsp;=&nbsp;l2&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;<span data-darkreader-inline-color="">//&nbsp;新虚拟&nbsp;DOM&nbsp;树的末尾节点索引</span><br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;*&nbsp;第一步<br>&nbsp;&nbsp;&nbsp;*&nbsp;从前往后遍历<br>&nbsp;&nbsp;&nbsp;*&nbsp;索引&nbsp;i&nbsp;递增<br>&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(i&nbsp;&lt;=&nbsp;e1&nbsp;&amp;&amp;&nbsp;i&nbsp;&lt;=&nbsp;e2)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;新旧虚拟节点同时遍历</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;n1&nbsp;=&nbsp;c1[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;n2&nbsp;=&nbsp;(c2[i]&nbsp;=&nbsp;optimized<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;cloneIfMounted(c2[i]&nbsp;<span data-darkreader-inline-color="">as</span>&nbsp;VNode)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;normalizeVNode(c2[i]));<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(isSameVNodeType(n1,&nbsp;n2))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;存在类型相同，且key值相同的节点就&nbsp;patch</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch(...);<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;存在不一致的节点，立即退出循环</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">break</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;i++;<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;*&nbsp;第二步<br>&nbsp;&nbsp;&nbsp;*&nbsp;从后往前遍历<br>&nbsp;&nbsp;&nbsp;*&nbsp;索引&nbsp;e1、e2&nbsp;递减少<br>&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(i&nbsp;&lt;=&nbsp;e1&nbsp;&amp;&amp;&nbsp;i&nbsp;&lt;=&nbsp;e2)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;新旧虚拟节点同时遍历</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;n1&nbsp;=&nbsp;c1[e1];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;n2&nbsp;=&nbsp;(c2[e2]&nbsp;=&nbsp;optimized<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;cloneIfMounted(c2[e2]&nbsp;<span data-darkreader-inline-color="">as</span>&nbsp;VNode)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;normalizeVNode(c2[e2]));<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(isSameVNodeType(n1,&nbsp;n2))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;存在类型相同，且key值相同的节点就patch</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch(...);<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;存在不一致的节点，立即退出循环</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">break</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;e1--;<br>&nbsp;&nbsp;&nbsp;&nbsp;e2--;<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;*&nbsp;第三步<br>&nbsp;&nbsp;&nbsp;*&nbsp;对比索引大小<br>&nbsp;&nbsp;&nbsp;*&nbsp;处理新增或被删除节点<br>&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(i&nbsp;&gt;&nbsp;e1)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(i&nbsp;&lt;=&nbsp;e2)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;存在新增节点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;1.&nbsp;左侧新增<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;(a&nbsp;b)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;c&nbsp;(a&nbsp;b)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;i&nbsp;=&nbsp;0,&nbsp;e1&nbsp;=&nbsp;-1,&nbsp;e2&nbsp;=&nbsp;0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;2.&nbsp;中间新增<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;(a&nbsp;b)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;(a)&nbsp;c&nbsp;d&nbsp;(b)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;i&nbsp;=&nbsp;1,&nbsp;e1&nbsp;=&nbsp;0,&nbsp;e2&nbsp;=&nbsp;2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;3.&nbsp;右侧新增<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;(a&nbsp;b)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;(a&nbsp;b)&nbsp;c<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;i&nbsp;=&nbsp;2,&nbsp;e1&nbsp;=&nbsp;1,&nbsp;e2&nbsp;=&nbsp;2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;nextPos&nbsp;作为新节点的后一位节点的索引，当作插入锚点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;nextPos&nbsp;=&nbsp;e2&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;anchor&nbsp;=&nbsp;nextPos&nbsp;&lt;&nbsp;l2&nbsp;?&nbsp;(c2[nextPos]&nbsp;<span data-darkreader-inline-color="">as</span>&nbsp;VNode).el&nbsp;:&nbsp;parentAnchor;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(i&nbsp;&lt;=&nbsp;e2)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;i&nbsp;到&nbsp;e2&nbsp;之间的节点即为新增节点<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;直接挂载<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;oldvnode&nbsp;置为&nbsp;null，复用&nbsp;path&nbsp;函数进行挂载<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">null</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(c2[i]&nbsp;=&nbsp;optimized<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;cloneIfMounted(c2[i]&nbsp;<span data-darkreader-inline-color="">as</span>&nbsp;VNode)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;normalizeVNode(c2[i])),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(i&nbsp;&gt;&nbsp;e2)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;存在被删除节点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;1.&nbsp;左侧被删除<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;a&nbsp;(b&nbsp;c)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;(b&nbsp;c)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;i&nbsp;=&nbsp;0,&nbsp;e1&nbsp;=&nbsp;0,&nbsp;e2&nbsp;=&nbsp;-1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;2.&nbsp;中间被删除<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;(a)&nbsp;c&nbsp;d&nbsp;(b)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;(a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(b)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;i&nbsp;=&nbsp;1,&nbsp;e1&nbsp;=&nbsp;2,&nbsp;e2&nbsp;=&nbsp;0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;3.&nbsp;右侧被删除<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;(a&nbsp;b)&nbsp;c<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;(a&nbsp;b)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;i&nbsp;=&nbsp;2,&nbsp;e1&nbsp;=&nbsp;2,&nbsp;e2&nbsp;=&nbsp;1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(i&nbsp;&lt;=&nbsp;e1)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;i&nbsp;到&nbsp;e1&nbsp;之间的节点即为被删除节点<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;直接卸载<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unmount(c1[i],&nbsp;parentComponent,&nbsp;parentSuspense,&nbsp;<span data-darkreader-inline-color="">true</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;*&nbsp;第四步<br>&nbsp;&nbsp;&nbsp;*&nbsp;处理其它特殊情况<br>&nbsp;&nbsp;&nbsp;*&nbsp;我们的示例也将走到这里<br>&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;新旧虚拟&nbsp;DOM&nbsp;树不一致的节点起始索引</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;s1&nbsp;=&nbsp;i;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;s2&nbsp;=&nbsp;i;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;遍历新节点<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;生成map，键值即新节点的key值，值为节点的索引<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;伪代码：keyToNewIndexMap&lt;key, index&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;keyToNewIndexMap:&nbsp;Map&lt;<span data-darkreader-inline-color="">string</span>&nbsp;|&nbsp;<span data-darkreader-inline-color="">number</span>&nbsp;|&nbsp;symbol,&nbsp;<span data-darkreader-inline-color="">number</span>&gt;&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Map();<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(i&nbsp;=&nbsp;s2;&nbsp;i&nbsp;&lt;=&nbsp;e2;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;nextChild&nbsp;=&nbsp;(c2[i]&nbsp;=&nbsp;optimized<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;cloneIfMounted(c2[i]&nbsp;<span data-darkreader-inline-color="">as</span>&nbsp;VNode)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;normalizeVNode(c2[i]));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(nextChild.key&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyToNewIndexMap.set(nextChild.key,&nbsp;i);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;j;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;记录已经&nbsp;patch&nbsp;的节点数</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;patched&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;计算新节点中还有多少节点需要被&nbsp;patch</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;toBePatched&nbsp;=&nbsp;e2&nbsp;-&nbsp;s2&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;标记是否需要移动</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;moved&nbsp;=&nbsp;<span data-darkreader-inline-color="">false</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;记录这次对比的旧节点到新节点最长可复用的索引</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;maxNewIndexSoFar&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;创建将要patch的节点数组<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;新节点对应旧节点的数组<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;数组下标为新节点的索引，值为旧节点的索引+1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;newIndexToOldIndexMap&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Array</span>(toBePatched);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;默认置为&nbsp;0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;表示新增节点<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;这也是为什么值是&nbsp;旧节点索引+1&nbsp;而不直接存索引的原因了<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;后续判断是否存在可复用的旧节点再重新赋值<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;toBePatched;&nbsp;i++)&nbsp;newIndexToOldIndexMap[i]&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;遍历&nbsp;i&nbsp;到&nbsp;e2&nbsp;之间需要处理的节点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(i&nbsp;=&nbsp;s1;&nbsp;i&nbsp;&lt;=&nbsp;e1;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;获取一下旧虚拟节点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;prevChild&nbsp;=&nbsp;c1[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(patched&nbsp;&gt;=&nbsp;toBePatched)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;已经patch的节点数量大于或等于需要被patch的节点数</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;说明当前节点是需要被删除的</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unmount(prevChild,&nbsp;parentComponent,&nbsp;parentSuspense,&nbsp;<span data-darkreader-inline-color="">true</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">continue</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;获取当前旧节点对应的新节点索引</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;newIndex;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(prevChild.key&nbsp;!=&nbsp;<span data-darkreader-inline-color="">null</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;旧节点存在key值<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;直接在&nbsp;keyToNewIndexMap&nbsp;查找<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;获取新节点的索引（newIndex）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newIndex&nbsp;=&nbsp;keyToNewIndexMap.get(prevChild.key);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;旧节点不存在&nbsp;key&nbsp;值</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(j&nbsp;=&nbsp;s2;&nbsp;j&nbsp;&lt;=&nbsp;e2;&nbsp;j++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;遍历新节点剩余索引（s2&nbsp;即新旧虚拟DOM树存在不同节点的位置）</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newIndexToOldIndexMap[j&nbsp;-&nbsp;s2]&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>&nbsp;&amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isSameVNodeType(prevChild,&nbsp;c2[j]&nbsp;<span data-darkreader-inline-color="">as</span>&nbsp;VNode)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;判断当前索引是不是还没&nbsp;patch（newIndexToOldIndexMap[j&nbsp;-&nbsp;s2]&nbsp;===&nbsp;0）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;同时判断当前新旧节点是否&nbsp;key、type&nbsp;都一致<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;一致就获取当前新节点索引（newIndex&nbsp;=&nbsp;j）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;跳出当前循环<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newIndex&nbsp;=&nbsp;j;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">break</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(newIndex&nbsp;===&nbsp;<span data-darkreader-inline-color="">undefined</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;newIndex&nbsp;为&nbsp;undefined<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;说明当前旧节点在新的虚拟&nbsp;DOM&nbsp;树中被删了<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;直接卸载<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unmount(prevChild,&nbsp;parentComponent,&nbsp;parentSuspense,&nbsp;<span data-darkreader-inline-color="">true</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;newIndex有值<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;说明当前旧节点在新节点数组中还存在，可能只是挪了位置<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;记录一下&nbsp;newIndexToOldIndexMap<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;表明当前新旧节点需要&nbsp;patch<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newIndexToOldIndexMap[newIndex&nbsp;-&nbsp;s2]&nbsp;=&nbsp;i&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(newIndex&nbsp;&gt;=&nbsp;maxNewIndexSoFar)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;新节点索引大于或等于最长可复用索引，重新赋值</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxNewIndexSoFar&nbsp;=&nbsp;newIndex;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;反之<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;说明新节点在最长可复用节点的左侧<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;需要移动（左移）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moved&nbsp;=&nbsp;<span data-darkreader-inline-color="">true</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;直接复用，patch（处理可能存在的孙子节点、更新一下属性等）</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prevChild,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c2[newIndex]&nbsp;<span data-darkreader-inline-color="">as</span>&nbsp;VNode,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patched++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;根据&nbsp;newIndexToOldIndexMap&nbsp;数组<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;生成最长稳定序列<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;最长稳定序列在这里存的就是不需要移动的节点索引<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;increasingNewIndexSequence&nbsp;=&nbsp;moved<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;getSequence(newIndexToOldIndexMap)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;EMPTY_ARR;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;最长稳定序列末尾节点索引</span><br>&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;increasingNewIndexSequence.length&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;从后往前遍历需要&nbsp;patch&nbsp;的节点数</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(i&nbsp;=&nbsp;toBePatched&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;i&nbsp;&gt;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i--)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;新虚拟节点索引</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;nextIndex&nbsp;=&nbsp;s2&nbsp;+&nbsp;i;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;新虚拟节点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;nextChild&nbsp;=&nbsp;c2[nextIndex]&nbsp;<span data-darkreader-inline-color="">as</span>&nbsp;VNode;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;将新节点的真实&nbsp;DOM&nbsp;作为后续插入的锚点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;anchor&nbsp;=<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextIndex&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>&nbsp;&lt;&nbsp;l2&nbsp;?&nbsp;(c2[nextIndex&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>]&nbsp;<span data-darkreader-inline-color="">as</span>&nbsp;VNode).el&nbsp;:&nbsp;parentAnchor;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(newIndexToOldIndexMap[i]&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;为&nbsp;0&nbsp;的话就是新增的节点<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;直接挂载新节点<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">null</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextChild,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;container,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;anchor,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(moved)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;需要移动</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(j&nbsp;&lt;&nbsp;<span data-darkreader-inline-color="">0</span>&nbsp;||&nbsp;i&nbsp;!==&nbsp;increasingNewIndexSequence[j])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;当前索引不在最长递增序列中<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;移动当前索引对应的新节点<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;移动到锚点节点之前<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move(nextChild,&nbsp;container,&nbsp;anchor,&nbsp;MoveType.REORDER);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j--;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>};<br></code>
```

再补充一点，在 Vue 中，节点移动通常是左移，也就是通过 `insertBefore` 这个 API 实现

到这里，这个 diff 流程就走完了；还有很多针对不同节点类型的特殊处理，因为与 diff 的主流程没有太大关系也就没有列出。

### 小试牛刀

你学费了吗？

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

在我们的示例中

-   旧虚拟 DOM 树对应的就是：`['a', 'b', 'c', 'd']`
    
-   新虚拟 DOM 树对应的就是：`['b', 'd', 'e', 'c']`
    

可以先自己试着梳理一下 diff 过程

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

可以直观地看出，无论是从前往后遍历，还是从后往前遍历，都找不到可复用的节点，也无法通过对比前两次索引得到新增或被删除的节点是谁；直接进入核心算法。

整棵树都是无法处理的节点，因此生成的 `keyToNewIndexMap` 长这样：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">{<span data-darkreader-inline-color="">'b'</span>&nbsp;=&gt;&nbsp;<span data-darkreader-inline-color="">0</span>,&nbsp;<span data-darkreader-inline-color="">'d'</span>&nbsp;=&gt;&nbsp;<span data-darkreader-inline-color="">1</span>,&nbsp;<span data-darkreader-inline-color="">'e'</span>&nbsp;=&gt;&nbsp;<span data-darkreader-inline-color="">2</span>,&nbsp;<span data-darkreader-inline-color="">'c'</span>&nbsp;=&gt;&nbsp;<span data-darkreader-inline-color="">3</span>}<br></code>
```

旧虚拟 DOM 树都是带 key 的，所以可以轻松地从 keyToNewIndexMap 中得到新节点的索引，得到的 `newIndexToOldIndexMap` 如下：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">[<span data-darkreader-inline-color="">2</span>,&nbsp;<span data-darkreader-inline-color="">4</span>,&nbsp;<span data-darkreader-inline-color="">0</span>,&nbsp;<span data-darkreader-inline-color="">3</span>];<br></code>
```

注意，数组内的值对应的旧节点的索引+1的值，数组的下标才是新节点的索引

从 newIndexToOldIndexMap 就可以看出，下标是 2 的新节点是新增的（值为 0）

这时候还有最后一不，判断旧节点的顺序是不是对的，这里就要生成`最长稳定序列了`，结果如下：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">[<span data-darkreader-inline-color="">0</span>,&nbsp;<span data-darkreader-inline-color="">3</span>]<br></code>
```

因此，稳定的是索引为 0 与索引为 3 的新节点；需要移动的便是索引为 1 的新节点，对应的就是索引为 3（4 - 1）的旧节点，直接将新节点插入到索引为 2 的新节点前面。

### 小结

来个思维导图解解闷儿

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

## 与 Vue2 对比

Vue2 的 diff 算法，在一个大循环中处理所有可复用情况，最后再判断是否还有新增或被删除的节点；相比之下，Vue3 将大循环拆开了，更加细化节点的类型，针对不同类型做优化。

Vue2 在一开始就直接在大循环中，对比新旧虚拟 DOM 树的首尾节点，发现可复用节点但位置不对，直接移动（操作真实节点）；而在 Vue3 中，移动节点的操作放到了最后，同时借助最长稳定序列减少节点操作次数。

在 Vue2 同样也生成了个 Map，不过这个 Map 是旧节点的 key 与索引的对应关系；而 Vue3 中的 Map 则是新节点的 key 与索引的对应关系。

## 参考

-   https://github.com/vuejs/core