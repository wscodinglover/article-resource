前端算法题，我们使用的是JavaScript进行解题。如果直接看答案无法理解里面解题思路，可以联系号主获取账户密码登录网址www.aimath.top，里面有详细的内容解释喔：

![Image](https://mmbiz.qpic.cn/mmbiz_png/YW2phdXC1XVCRu3tDgCDJUEM4GSFJUIicI9rPLSIQF3fCTDcFEQakFQbFDMH4j4UIlIcUqRanHA585GiahibHibZ1Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## **一、学完这篇，你可以收获什么？**

-   链表概念
    
-   链表基础算法题
    
-   使用链表实现instanceof原理  
    

## **二、链表概念**

**1、链表是什么？**

链表，指的是多个元素组成的列表。特点是元素存储不连续，用next指针连在一起。如图所示：  

![Image](https://mmbiz.qpic.cn/mmbiz_png/YW2phdXC1XVCRu3tDgCDJUEM4GSFJUIicZxreOw4fZONnG8YUUen1FfI620AVnqoCUffDSM8U9lh9ibQndwQrkvA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

同学们可能有个疑问，既然他是多个元素组成的列表，那为什么要把链表设计那么复杂呢？

我们对比数组和链表是如何管理元素的：

(2) 链表，增删非首尾元素，不需要移动元素，只需要更改next指向即可。

可见，对于大型数据，链表更加方便管理元素。接下来我们看看链表常见基础操作。

**2、通过js实现链表操作**

```
<span>const&nbsp;a&nbsp;=&nbsp;{&nbsp;val:&nbsp;'1'&nbsp;};</span>
```

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

从代码，我们可以发现每个节点都有一个值val，和一个next指向。通常，我们以val值来称呼节点，比如a我们成为1节点。

**2、遍历、插入、删除链表操作**

```
<span>const a = { val: 'a' };</span>
```

了解链表的基本操作后，就可以开始玩各种算法题了。

## **三、链表基础算法题**

我们先看一道简单链表算法题  

**1、删除链表指定节点**

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

我们无法从链表中直接删除节点，但我们可以将被删除节点转变为下个节点的值，并转变next指向，这就变相地删除节点了。以此为思路，我们得到算法如下：

```
<span><span>var</span> deleteNode = function(head, <span>val</span>) {</span>
```

**2、反转链表**

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

看图像，我们先将需要反转的链表切成fragment，接着我们将fragment反转；最后，我们拼接链表即可。

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

```
<span><span>// Definition for singly-linked list.</span></span>
```

**3、JavaScript原型链**

我们经常使用的js原型链是怎么样的呢？

-   obj → Object.prototype → null
    
-   func → Function.prototype → Object.prototype → null
    
-   arr → Array.prototype → Object.prototype → null
    

我们发现，除了对象自己，其他对象都是先指向自己原型链对象，然后再指向object原型对象。

对于object对象：obj.\_\_proto\_\_ === Object.prototype 返回的是 true。其中，obj是Object的实例化对象。

现在我们通过代码实现instanceof原理  

```
<span><span><span>function</span> <span>instanceOf</span>(<span>A, B</span>)</span>{</span>
```

下期预告：你知道 Map 和 Object 频繁增删操作的性能区别吗？到谁高谁低呢？下期为你揭晓：集合~