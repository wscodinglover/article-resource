开篇

你说，万一接口挂了会怎么样？

还能咋样，白屏呗。

有没有不白屏的方案？

有啊，还挺简单的。

容我细细细细分析。

原因就是接口挂了，拿不到数据了。那把数据储存起来就可以解决问题。

## 思考

## 存哪里?

第一时间反应浏览器本地存储，想起了四兄弟。

### **选型对比**

| 特性 | cookie | localStorage | sessionStorage | indexDB |
| --- | --- | --- | --- | --- |
| 数据生命周期 | 服务器或者客户端都可以设置、有过期时间 | 一直存在 | 关闭页面就清空 | 一直存在 |
| 数据储存大小 | 4KB | 5MB | 5MB | 动态，很大  
大于250MB |
| 与服务器通信 | 每次都带在header中 | 不带 | 不带 | 不带 |
| 兼容性 | 都支持 | 都支持 | 都支持 | IE不支持，其他主流都支持 |

考虑到需要存储的数据量，5MB 一定不够的，所以选择了 IndexDB。

考虑新用户或者长时间未访问老用户，会取不到缓存数据与陈旧的数据。

因此准备上云，用阿里云存储，用 CDN 来保障。

总结下：线上 CDN、线下 IndexDB。

## 整体方案

## 整体流程图

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

## CDN

先讲讲线上 CDN。

通常情况下可以让后端支撑，本质就是更新策略问题，这里不细说。

我们讲讲另外一种方案，单独启个 Node 服务更新 CDN 数据。

## 流程图

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

## 劫持逻辑

劫持所有接口，判断接口状态与缓存标识。从而进行更新数据、获取数据、缓存策略三种操作

通过配置白名单来控制接口存与取

```
axios.interceptors.response.use(<br>      async (resp) =&gt; {<br>        const { config } = resp<br>        const { url } = config<br>        // 是否有缓存tag，用于更新CDN数据。目前是定时服务在跑，访问页面带上tag<br>        if (this.hasCdnTag() &amp;&amp; this.isWhiteApi(url)) {<br>          this.updateCDN(config, resp)<br>        }<br>        return resp;<br>      },<br>      async (err) =&gt; {<br>        const { config } = err<br>        const { url } = config<br>        // 是否命中缓存策略<br>        if (this.isWhiteApi(url) &amp;&amp; this.useCache()) {<br>          return this.fetchCDN(config).then(res =&gt; {<br>            pushLog(`cdn缓存数据已命中，请处理`, SentryTypeEnum.error)<br>            return res<br>          }).catch(()=&gt;{<br>           pushLog(`cdn缓存数据未同步，请处理`, SentryTypeEnum.error)<br>          })<br>        }<br>      }<br>    );<br>
```

## 缓存策略

累计接口异常发生 `maxCount` 次，打开缓存开关，`expiresSeconds` 秒后关闭。

缓存开关用避免网络波动导致命中缓存，设置了阀值。

```
/*<br>* 缓存策略<br>*/<br>useCache = () =&gt; {<br>  if (this.expiresStamp &gt; +new Date()) {<br>    const d = new Date(this.expiresStamp)<br>    console.warn(`<br>    ---------------------------------------<br>    ---------------------------------------<br>    启用缓存中<br>    关闭时间：${d.getHours()}:${d.getMinutes()}:${d.getSeconds()}<br>    ---------------------------------------<br>    ---------------------------------------<br>    `)<br>    return true<br>  }<br>  this.errorCount += 1<br>  localStorage.setItem(CACHE_ERROR_COUNT_KEY, `${this.errorCount}`)<br>  if (this.errorCount &gt; this.maxCount) {<br>    this.expiresStamp = +new Date() + this.expiresSeconds * 1000<br>    this.errorCount = 0<br>    localStorage.setItem(CACHE_EXPIRES_KEY, `${this.expiresStamp}`)<br>    localStorage.removeItem(CACHE_ERROR_COUNT_KEY)<br>    return true<br>  }<br>  return false<br>}<br>
```

## 唯一标识

根据 `method`、`url`、`data` 三者来标识接口，保证接口的唯一性

带动态标识，譬如时间戳等可以手动过滤

```
<br>/**<br> * 生成接口唯一键值<br>*/<br>generateCacheKey = (config) =&gt; {<br>  // 请求方式，参数，请求地址，<br>  const { method, url, data, params } = config;<br>  let rawData = ''<br>  if (method === 'get') {<br>    rawData = params<br>  }<br>  if (method === 'post') {<br>    rawData = JSON.parse(data)<br>  }<br>  // 返回拼接key<br>  return `${encodeURIComponent([method, url, stringify(rawData)].join('_'))}.json`;<br>};<br>
```

## 更新数据

```
/**<br> * 更新cdn缓存数据<br>*/<br>updateCDN = (config, data) =&gt; {<br>  const fileName = this.generateCacheKey(config)<br>  const cdnUrl = `${this.prefix}/${fileName}`<br>  axios.post(`${this.nodeDomain}/cdn/update`, {<br>    cdnUrl,<br>    data<br>  })<br>}<br>
```

## Node定时任务

构建定时任务，用 `puppeteer` 去访问、带上缓存标识，去更新 CDN 数据

```
import schedule from 'node-schedule';<br><br>const scheduleJob = {};<br><br>export const xxxJob = (ctx) =&gt; {<br>  const { xxx } = ctx.config;<br>  ctx.logger.info(xxx, 'xxx');<br>  const { key, url, rule } = xxx;<br>  if (scheduleJob[key]) {<br>    scheduleJob[key].cancel();<br>  }<br>  scheduleJob[key] = schedule.scheduleJob(rule, async () =&gt; {<br>    ctx.logger.info(url, new Date());<br>    await browserIndex(ctx, url);<br>  });<br>};<br><br>export const browserIndex = async (ctx, domain) =&gt; {<br>  ctx.logger.info('browser --start', domain);<br>  if (!domain) {<br>    ctx.logger.error('domain为空');<br>    return false;<br>  }<br>  const browser = await puppeteer.launch({<br>    args: [<br>      '--use-gl=egl',<br>      '--disable-gpu',<br>      '--no-sandbox',<br>      '--disable-setuid-sandbox',<br>    ],<br>    executablePath: process.env.CHROMIUM_PATH,<br>    headless: true,<br>    timeout: 0,<br>  });<br>  const page = await browser.newPage();<br>  await page.goto(`${domain}?${URL_CACHE_KEY}`);<br>  await sleep(10000);<br>  // 访问首页所有查询接口<br>  const list = await page.$$('.po-tabs__item');<br>  if (list?.length) {<br>    for (let i = 0; i &lt; list.length; i++) {<br>      await list[i].click();<br>    }<br>  }<br>  await browser.close();<br>  ctx.logger.info('browser --finish', domain);<br>  return true;<br>};<br>
```

## 效果

手动 `block` 整个 `domain`，整个页面正常展示

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

## IndexDB

线上有 CDN 保证了，线下就轮到 IndexDB 了，基于业务简单的增删改查，选用 **localForage** 三方库足矣。

```
axios.interceptors.response.use(<br>      async (resp) =&gt; {<br>        const { config } = resp<br>        const { url } = config<br>        // 是否有缓存tag，用于更新CDN数据。目前是定时服务在跑，访问页面带上tag<br>        if (this.hasCdnTag() &amp;&amp; this.isWhiteApi(url)) {<br>          this.updateCDN(config, resp)<br>        }<br>        if(this.isIndexDBWhiteApi(url)){<br>          this.updateIndexDB(config, resp)<br>        }<br>        return resp;<br>      },<br>      async (err) =&gt; {<br>        const { config } = err<br>        const { url } = config<br>        // 是否命中缓存策略<br>        if (this.isWhiteApi(url) &amp;&amp; this.useCache()) {<br>          return this.fetchCDN(config).then(res =&gt; {<br>            pushLog(`cdn缓存数据已命中，请处理`, SentryTypeEnum.error)<br>            return res<br>          }).catch(()=&gt;{<br>           pushLog(`cdn缓存数据未同步，请处理`, SentryTypeEnum.error)<br>           if(this.isIndexDBWhiteApi(url)){<br>             return this.fetchIndexDB(config).then(res =&gt; {<br>              pushLog(`IndexDB缓存数据已命中，请处理`, SentryTypeEnum.error)<br>              return res<br>            }).catch(()=&gt;{<br>             pushLog(`IndexDB缓存数据未同步，请处理`, SentryTypeEnum.error)<br>            })<br>           }<br>          })<br>        }<br>      }<br>    );<br>
```

## 总结

总结下，优点包括不入侵业务代码，不影响现有业务，随上随用，尽可能避免前端纯白屏的场景，成本低。劣势包括使用局限，不适合对数据实效性比较高的业务场景，不支持 IE 浏览器。

接口容灾我们也是刚弄不久，有许多细节与不足，欢迎沟通交流。

接口容灾本意是预防发生接口服务挂了的场景，我们不会很被动。原来是P0的故障，能被它降低为 P2、P3，甚至在某些场景下都不会有用户反馈。