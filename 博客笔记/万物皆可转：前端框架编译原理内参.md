![Image](https://mmbiz.qpic.cn/mmbiz_png/lCQLg02gtibukplhk1r16xOTuSccSKJXasPGM9sor182HrOtwK0fO1bO3uTYBt8XI9EPCs4uNplQibGxlmDbdYkA/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  

**「Rax2Taro」**：点击查看Github地址（https://github.com/Trade-Offf/Rax2Taro?tab=readme-ov-file）

## 一、前置背景

笔者日常使用 Rax 框架开发前端需求。但随着业务扩展，我面临一个头痛的需求：将现有的 Rax 组件适配为 Taro 组件，以实现一些特定商业场景的跨平台功能。

这一需求可以概括为：

-   **「新功能开发」** - 在 Taro 框架中实现，确保多端兼容性。
    
-   **「旧功能复用」** - 将现有 Rax 组件转换为 Taro，避免重写。
    

重写组件成本高昂，特别是对于缺乏文档和原开发者不在的旧组件。因此我需要一种自动化工具，能够轻松地**「一键式」**将 Rax 组件转化为 Taro 组件，减少工作量，加快开发进程。

本篇博客内容，将探讨构建一个从 Rax 转换到 Taro 的编译器，从零开始实现组件级转换。

> ❝
> 
> 「 恐惧通常源自未知，你恐惧的不是造轮子，你恐惧的是你从来没造过轮子 」
> 
> ❞

作为前端同学，如果遇到这种工作可能会汗流浃背。

但不要担心，只要我们把目标拆解到足够清晰、足够细化，一切困难都是纸老虎。

## 二、编译器

编译器是个宽泛的概念，最初是指将**「高级语言」**转换为计算机能识别的**「汇编/机器语言」**的工具。

个人理解：编译器本质是个从 A 转换的 B 的翻译工具 （如有不妥，还原评论区指正 🤝）

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

但是编译器的翻译过程不是简单的翻译，通常涉及到多个步骤（词法、语法、语义分析、中间代码生成等）。详细知识点不赘述了，感兴趣的朋友请翻阅《编译原理》（https://book.douban.com/subject/3296317/）。

## 01 | Babel：JavaScript 编译器

我们以日常开发中，接触最多的 JavaScript 编译器 Babel 为例，了解编译器工作逻辑，这里只介绍 Babel 基本流程。更多详细内容可以看以下Github官方文档：Babel 插件手册（https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md）

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

Babel 工作流程

## 02 | 基本用法

这里以将 `const a = 1` 转换成 `var a = 1` 为例，看下 Babel 是如何工作的

### i. 解析（parse）成抽象语法树 AST

> ❝
> 
> **「抽象语法树（Abstract Syntax Tree）」**：本质是一种数据结构，它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。
> 
> ❞

Babel 提供了 @babel/parser 将代码解析成 AST。这一步主要做两件事：

-   **「词法分析」**：把代码转换为令牌流（tokens flow：解析的中间产物，不用管）
    
-   **「语法分析」**：再把每个 token 转换为 AST 结构
    

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">const</span>&nbsp;parse&nbsp;=&nbsp;<span data-darkreader-inline-color="">require</span>(<span data-darkreader-inline-color="">'@babel/parser'</span>).parse;<br><br><span data-darkreader-inline-color="">const</span>&nbsp;ast&nbsp;=&nbsp;parse(<span data-darkreader-inline-color="">'const&nbsp;a&nbsp;=&nbsp;1'</span>);<br></code>
```

### ii. 转换（transform）AST

Babel 提供了 @babel/traverse 对解析后的 AST 进行处理。

转换接收 AST 并对其遍历，在此过程中对节点进行增删改查，是 Babel 编译器最核心的过程。

`traverse()`能够接收 ast 以及 visitor 两个参数：

-   **「ast」** 是上一步解析得到的抽象语法树。
    
-   **「visitor」** 提供访问不同节点的能力，当遍历到一个匹配的节点时，能够调用具体方法对节点进行处理。
    

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">const</span>&nbsp;t&nbsp;=&nbsp;<span data-darkreader-inline-color="">require</span>(<span data-darkreader-inline-color="">'@babel/types'</span>);<br><span data-darkreader-inline-color="">const</span>&nbsp;traverse&nbsp;=&nbsp;<span data-darkreader-inline-color="">require</span>(<span data-darkreader-inline-color="">'@babel/traverse'</span>).default;<br><br>traverse(ast,&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">VariableDeclaration</span>:&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span>path</span>)&nbsp;</span>{&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(path.node.kind&nbsp;===&nbsp;<span data-darkreader-inline-color="">'const'</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path.replaceWith(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.variableDeclaration(<span data-darkreader-inline-color="">'var'</span>,&nbsp;path.node.declarations)&nbsp;<span data-darkreader-inline-color="">//替换成&nbsp;var</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;path.skip();<br>&nbsp;&nbsp;}<br>});<br></code>
```

Babel 提供了@babel/types 用于定义 AST 节点，在 visitor 处理节点的时候用于新增/替换等操作。

这个例子中，我们遍历上一步得到的 AST，在匹配到变量声明 `VariableDeclaration` 时，判断值是否为 const，并操作替换成 var。

### iii. 生成（generate）代码

Babel 提供了 @babel/generator 把转换后的最终 AST 还原为字符串形式的代码，同时创建源码映射。

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">const</span>&nbsp;generate&nbsp;=&nbsp;<span data-darkreader-inline-color="">require</span>(<span data-darkreader-inline-color="">'@babel/generator'</span>).default;<br><br><span data-darkreader-inline-color="">let</span>&nbsp;code&nbsp;=&nbsp;generate(ast).code;<br></code>
```

以上就是 Babel 在编译时的流程，这里涉及到了几个关键的包：

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

-   **「@babel/types」** ：用于构建、验证和修改 AST 节点
    
-   **「@babel/parser」**：提供默认的 parse 方法用于解析
    
-   **「@babel/traverse」**: 封装了对 AST 树的遍历和节点的增删改查操作
    
-   **「@babel/generator」**: 提供给默认的 generate 方法用于代码生成
    

我们接下来写的编译器，就是基于上述介绍的 Babel 包来实现。

## 三、Rax2Taro

除了转换工具，我们还需要了解被转换和生产的对象。

因此需要了解 Rax 和 Taro 框架，比较两者的差异和相似之处，注意转换过程中需要抹平的部分：

-   **「Rax」** 是阿里巴巴的的跨端解决方案，它的设计理念与 React 类似，提供了类似的组件化开发体验，能够运行在 Web、Node.js、阿里小程序、Weex 等多个平台。
    
-   **「Taro」** 是京东的跨端跨框架解决方案，支持使用 React 语法开发一次，然后将代码编译成不同平台的小程序（微信/百度/支付宝/字节跳动/京东小程序等）和 H5 应用，甚至可以编译成 React Native 应用。
    

通过阅读对比二者官方文档，寻找到接下来开发的关键破局点：**「Rax 和 Taro 均支持组件化开发」**

由于Rax 和 Taro 都受到 React 的影响，并且都使用 JSX 语法，导致它们的许多基础组件在概念上是类似的，这意味着有一些组件和属性是可以在两者之间直接映射的。

## 01 | 本期目标

从组件化下手，本期编译器能力计划将左侧 Rax 文档中（除 Link 外）的 7 个组件一键转换 Taro 组件

-   在 Taro 中优先寻找平替组件，若能找到则增加转换逻辑抹平差异，实现转换器。
    
-   如果找不到对应组件就标红，等后续对特例地统一处理。
    

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

  

## 02 | 编译器设计

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

  

编译器结构设计

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">/Rax2Taro<br>|--&nbsp;/node_modules&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">#&nbsp;项目依赖库安装文件夹</span><br>|--&nbsp;/src<br>|&nbsp;&nbsp;&nbsp;|--&nbsp;index.js&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">#&nbsp;主入口文件，协调整个转换过程</span><br>|&nbsp;&nbsp;&nbsp;|--&nbsp;parser.js&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">#&nbsp;用于解析源代码生成&nbsp;AST</span><br>|&nbsp;&nbsp;&nbsp;|--&nbsp;generator.js&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">#&nbsp;用于从修改后的&nbsp;AST&nbsp;生成新的源代码</span><br>|--&nbsp;/Transformers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">#&nbsp;存放转换逻辑的模块文件夹</span><br>|&nbsp;&nbsp;&nbsp;|--&nbsp;index.js&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">#&nbsp;整合各种转换规则的主要转换器</span><br>|&nbsp;&nbsp;&nbsp;|--&nbsp;FunctionTransformer.js&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">#&nbsp;函数转换逻辑</span><br>|&nbsp;&nbsp;&nbsp;|--&nbsp;/JSXElementsTransformer&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">#&nbsp;存放&nbsp;JSX&nbsp;元素的特定转换器</span><br>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|--&nbsp;index.js&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">#&nbsp;整合&nbsp;JSX&nbsp;元素转换规则</span><br>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|--&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">#&nbsp;其他&nbsp;JSX&nbsp;元素转换模块</span><br>|&nbsp;&nbsp;&nbsp;|--&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">#&nbsp;其他转换逻辑模块</span><br>|--&nbsp;/Input&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">#&nbsp;存放待转化的&nbsp;Rax.js&nbsp;的文件夹</span><br>|--&nbsp;/Output&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">#&nbsp;存放转化后的&nbsp;Taro.js&nbsp;的文件夹</span><br>|--&nbsp;package.json&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">#&nbsp;定义项目依赖和脚本</span><br>|--&nbsp;README.md&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">#&nbsp;项目说明文档</span><br></code>
```

编译器代码结构设计

## 03 | 转换 View 组件

> ❝
> 
> 「 写一个编译器可能很难，但是转换一个小组件很简单 」
> 
> ❞

我们的目标是转换 N 个基本组件。

一旦我们知道了如何转换 View 组件，我们只需重复相同的步骤六次即可完成目标。因此，我们将以 View 组件为案例，探讨如何制定单个组件的转换规则。

**「转换，本质就是找不同，并让不同变相同」**

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

  

通过对比二者代码之间的差异，我们发现需要做这三件事：

1.  Rax 需要引入 `createElement` 不然会报错，Taro 除了组件外没其他引入行为；
    
2.  Import 引入写法不同，Rax 用单文件引入单组件，Taro 是在 `@tarojs/components` 集中引入；
    
3.  同样都是`<View />`组件，两个框架间的组件 API 属性可能不同，或者属性名相同功能不同。需要抹平差异，或者特异处理；
    

接下来让我们一步步实现，至于读取文件和转换 SourceCode 得到 AST 部分不讲，具体细节可以在 Github 里看，就两行代码。**「下述一切操作均默认为转换器获取到 AST 之后」**。

### i. 删除 createElement

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">//&nbsp;主入口文件</span><br><span data-darkreader-inline-color="">const</span>&nbsp;traverse&nbsp;=&nbsp;<span data-darkreader-inline-color="">require</span>(<span data-darkreader-inline-color="">"@babel/traverse"</span>).default;<br><span data-darkreader-inline-color="">const</span>&nbsp;importsTransformer&nbsp;=&nbsp;<span data-darkreader-inline-color="">require</span>(<span data-darkreader-inline-color="">"./ImportsTransformer"</span>);<br><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span>transform</span>(<span>ast</span>)&nbsp;</span>{<br>&nbsp;&nbsp;traverse(ast,&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;ImportDeclaration(path)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;importsTransformer.transformImportDeclaration(path);<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;...&nbsp;添加其他节点类型的转换规则</span><br>&nbsp;&nbsp;});<br>}<br><br><span data-darkreader-inline-color="">module</span>.exports&nbsp;=&nbsp;{<br>&nbsp;&nbsp;transform,<br>};<br></code>
```

开始之前，首先了解一下转换器主入口结构。

主入口文件引入了`@babel/traverse`，还引入我们新增用来删除 createElement 的方法。

其中使用了`traverse()`函数，它用于遍历抽象语法树（AST），访问树中的每个节点，并对这些节点进行修改、添加或删除。

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">//&nbsp;功能函数</span><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span>transformImportDeclaration</span>(<span>path</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;importSource&nbsp;=&nbsp;path.node.source.value;<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;删除&nbsp;"rax"&nbsp;模块里的&nbsp;createElement</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(importSource&nbsp;===&nbsp;<span data-darkreader-inline-color="">"rax"</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;过滤&nbsp;createElement&nbsp;引入</span><br>&nbsp;&nbsp;&nbsp;&nbsp;path.node.specifiers&nbsp;=&nbsp;path.node.specifiers.filter(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>(<span>specifier</span>)&nbsp;=&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.isImportSpecifier(specifier)&nbsp;&amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;specifier.imported.name&nbsp;===&nbsp;<span data-darkreader-inline-color="">"createElement"</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>&nbsp;&nbsp;&nbsp;&nbsp;);<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;删除空引用</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(path.node.specifiers.length&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path.remove();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>}<br></code>
```

接下来看功能函数，因为会遍历节点，所以

1.  我们首先通过 `path.node.source.value=== "rax"` 定位，找到我们要增删改的目标节点；
    
2.  然后过滤这个语句中的所有导入说明符 specifiers ，检查值是否为 createElement
    

-   `path.node.specifiers` 是 AST 中的一个部分，表示一个模块导入语句中的所有导入说明符。
    
-   `t.isImportSpecifier` 是 Babel 类型检查器的一部分。
    

4.  如果是，就被过滤掉。
    
5.  最后加一步空引用清除，删除 `import { } from 'rax'`
    

### ii. 改变组件引入写法

引入写法的修改方式，类似上面的处理方法：

1.  先定位找到 `import View from "rax-view"`，删除这句引入；
    
2.  声明一个对象，存 Taro 引入组件，把上面删掉的组件再以 `import { View } from "@tarojs/components"`的形式声明；
    

但是考虑到可扩展性，之后还会遇到 Text、Image 等组件，所以这里我写了一张映射表，批量重复上面操作。

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">const</span>&nbsp;componentImportMap&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">"rax-view"</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">source</span>:&nbsp;<span data-darkreader-inline-color="">"@tarojs/components"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">importName</span>:&nbsp;<span data-darkreader-inline-color="">"View"</span>,<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">"rax-text"</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">source</span>:&nbsp;<span data-darkreader-inline-color="">"@tarojs/components"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">importName</span>:&nbsp;<span data-darkreader-inline-color="">"Text"</span>,<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;...&nbsp;添加更多组件及其转换规则</span><br>};<br><br><span data-darkreader-inline-color="">const</span>&nbsp;taroComponentsToImport&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Set</span>();&nbsp;<span data-darkreader-inline-color="">//&nbsp;声明去重&nbsp;Taro&nbsp;对象</span><br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;基础组件映射转换</span><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span>transformImportDeclaration</span>(<span>path</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;importSource&nbsp;=&nbsp;path.node.source.value;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;...&nbsp;createElement&nbsp;删除逻辑</span><br>&nbsp;&nbsp;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;newImportInfo&nbsp;=&nbsp;componentImportMap[importSource];<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(newImportInfo)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果映射表里有，就存这个值到&nbsp;Taro&nbsp;对象中</span><br>&nbsp;&nbsp;&nbsp;&nbsp;taroComponentsToImport.add(newImportInfo.importName);<br>&nbsp;&nbsp;&nbsp;&nbsp;path.remove();&nbsp;<span data-darkreader-inline-color="">//&nbsp;并移除原&nbsp;rax-xxx&nbsp;导入声明</span><br>&nbsp;&nbsp;}<br>}<br></code>
```

由于功能类似，所以这两个功能（删除 createElement、改变组件引入写法）我都写在 `transformImportDeclaration` 函数里。

### iii. 转换 View 组件

转换View组件听上去很复杂，其实拆解下，本质就是把两套属性差异抹平，用的也是上面对 AST 节点的增删改操作。

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

  

从二者官方文档里展示的组件 API 可以明显看到 Rax 比 Taro 的 View 少了很多属性，但由于我们实现的是 **「Rax -> Taro」** 的单向转换。

所以**「一切编译行为以 Rax API 为转换基准」**。

至于 Taro 多出来的 API ，编译器不用管，如果后续开发需要用到Taro属性，则开发者根据 Taro 官方文档自行配置使用即可(反正 Rax 没有 🐒)

对比 View API 差异，我整理出下面的表格内容：

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)可以看到有 5 条 API 属性有不同，其中 3 条是使用方法不同，2 条是需要编译器处理的属性。

1.  onClick -> onTap
    
2.  onLongpress -> onLongTap
    

View 转换器的逻辑如下：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">const</span>&nbsp;t&nbsp;=&nbsp;<span data-darkreader-inline-color="">require</span>(<span data-darkreader-inline-color="">"@babel/types"</span>);<br><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span>transformViewElement</span>(<span>path</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;确保我们只处理具有&nbsp;name&nbsp;属性的&nbsp;JSXElement</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(path.node.openingElement&nbsp;&amp;&amp;&nbsp;path.node.openingElement.name)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;openingElementName&nbsp;=&nbsp;path.node.openingElement.name;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.isJSXIdentifier(openingElementName)&nbsp;&amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;openingElementName.name&nbsp;===&nbsp;<span data-darkreader-inline-color="">"View"</span><br>&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path.node.openingElement.attributes.forEach(<span>(<span>attribute</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(t.isJSXAttribute(attribute)&nbsp;&amp;&amp;&nbsp;attribute.name)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;attributeName&nbsp;=&nbsp;attribute.name.name;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">switch</span>&nbsp;(attributeName)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">case</span>&nbsp;<span data-darkreader-inline-color="">"onClick"</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attribute.name.name&nbsp;=&nbsp;<span data-darkreader-inline-color="">"onTap"</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">break</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">case</span>&nbsp;<span data-darkreader-inline-color="">"onLongpress"</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attribute.name.name&nbsp;=&nbsp;<span data-darkreader-inline-color="">"onLongTap"</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">break</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>}<br><br><span data-darkreader-inline-color="">module</span>.exports&nbsp;=&nbsp;{<br>&nbsp;&nbsp;transformViewElement,<br>};<br></code>
```

跟之前操作差不多，还是遍历找节点，找到要处理的 API 属性，将属性重命名。

至此，我们实现了 Rax -> Taro View 组件的编译转换。接下来需要对剩下的 6 个基础组件做同样操作，即可完成本期目标：

重复流程如下：

1.  列表格，整理 API 差异，标明处理方式
    
2.  遍历 AST 找对应节点、找到需要处理的 API 属性
    
3.  执行重命名 or 删除动作
    

机械性动作 \* n ...

为了保证转换器的拓展性，这里新增了一个主入口 `index.js` 文件用来批量管理各个独立组建的小转换器。

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

其他组件的对应表请在语雀文档查看：

https://www.yuque.com/cascading/bwnowo/uwp3s510g0im9ue9?singleDoc# 《基础组件 API 差异》

## 四、自动化测试

由于在本地转换各个 API 需要反复调试，并且需要实时查看组件编译后的情况。为了开发提效，我本地还需要运行 Rax 和 Taro 两个用脚手架生成的项目，加一个小自动化测试脚本进行一键编译调试。

具体步骤如下，在`e2e.test.js` 中：

-   设定 Rax 项目路径：本项目从 Rax 应用的源文件夹`rax-test-demo/src/index.js`读取待转换组件代码。
    
-   设定 Taro 项目路径：将转换后的 Taro 组件代码写入 Taro 应用的目标文件夹 `TaroTestDemo/src/app.js`
    
-   转换代码：命令行执行：`npm run test:e2e` 转换器将源代码解析为 AST，并进行转换。
    
-   监测转换结果：在 Taro 测试环境中检查转换后的代码，确保没有报错且符合预期。
    

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">const</span>&nbsp;fs&nbsp;=&nbsp;<span data-darkreader-inline-color="">require</span>(<span data-darkreader-inline-color="">"fs"</span>);<br><span data-darkreader-inline-color="">const</span>&nbsp;path&nbsp;=&nbsp;<span data-darkreader-inline-color="">require</span>(<span data-darkreader-inline-color="">"path"</span>);<br><span data-darkreader-inline-color="">const</span>&nbsp;{&nbsp;transform&nbsp;}&nbsp;=&nbsp;<span data-darkreader-inline-color="">require</span>(<span data-darkreader-inline-color="">"../src/Transformers"</span>);<br><span data-darkreader-inline-color="">const</span>&nbsp;parser&nbsp;=&nbsp;<span data-darkreader-inline-color="">require</span>(<span data-darkreader-inline-color="">"@babel/parser"</span>);<br><span data-darkreader-inline-color="">const</span>&nbsp;generator&nbsp;=&nbsp;<span data-darkreader-inline-color="">require</span>(<span data-darkreader-inline-color="">"@babel/generator"</span>).default;<br><br><span data-darkreader-inline-color="">//&nbsp;基于你&nbsp;Rax&nbsp;源文件和&nbsp;Taro&nbsp;输出的路径</span><br><span data-darkreader-inline-color="">const</span>&nbsp;raxSourcePath&nbsp;=&nbsp;path.join(__dirname,&nbsp;<span data-darkreader-inline-color="">"../../rax-test-demo/src/index.js"</span>);<br><span data-darkreader-inline-color="">const</span>&nbsp;taroOutputPath&nbsp;=&nbsp;path.join(<br>&nbsp;&nbsp;__dirname,<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">"../../TaroTestDemo/src/pages/index/index.jsx"</span><br>);<br><br>describe(<span data-darkreader-inline-color="">"End-to-End&nbsp;Transformation"</span>,&nbsp;()&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;it(<span data-darkreader-inline-color="">"从Rax组件中读取源码，转换为Taro组件"</span>,&nbsp;()&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;raxSourceCode&nbsp;=&nbsp;fs.readFileSync(raxSourcePath,&nbsp;<span data-darkreader-inline-color="">"utf8"</span>);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;1.解析&nbsp;Rax&nbsp;源代码为&nbsp;AST</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;raxAst&nbsp;=&nbsp;parser.parse(raxSourceCode,&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">sourceType</span>:&nbsp;<span data-darkreader-inline-color="">"module"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">plugins</span>:&nbsp;[<span data-darkreader-inline-color="">"jsx"</span>],<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;2.转换&nbsp;AST</span><br>&nbsp;&nbsp;&nbsp;&nbsp;transform(raxAst);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;3.生成转换后的&nbsp;Taro&nbsp;源代码</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;taroOutput&nbsp;=&nbsp;generator(raxAst,&nbsp;{});<br><br>&nbsp;&nbsp;&nbsp;&nbsp;fs.writeFileSync(taroOutputPath,&nbsp;taroOutput.code);<br>&nbsp;&nbsp;});<br>});<br></code>
```

## 01 | 准备 Rax 测试环境

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">npm&nbsp;install&nbsp;-g&nbsp;rax-cli&nbsp;<span data-darkreader-inline-color="">#&nbsp;安装&nbsp;Rax&nbsp;脚手架（如果尚未安装）</span><br><br><span data-darkreader-inline-color="">cd</span>&nbsp;Desktop&nbsp;<span data-darkreader-inline-color="">#&nbsp;进入桌面</span><br>rax&nbsp;init&nbsp;RaxTestDemo&nbsp;<span data-darkreader-inline-color="">#&nbsp;初始化&nbsp;Rax&nbsp;项目</span><br><br><span data-darkreader-inline-color="">cd</span>&nbsp;rax-test-demo&nbsp;<span data-darkreader-inline-color="">#&nbsp;进入文件夹</span><br>npm&nbsp;install&nbsp;<span data-darkreader-inline-color="">#&nbsp;安装依赖</span><br>npm&nbsp;start&nbsp;<span data-darkreader-inline-color="">#&nbsp;运行</span><br></code>
```

脚手架选项如下：

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

## 02 | 准备 Taro 测试环境

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">npm&nbsp;install&nbsp;-g&nbsp;@tarojs/cli&nbsp;<span data-darkreader-inline-color="">#&nbsp;安装&nbsp;Taro&nbsp;脚手架（如果尚未安装）</span><br><br><span data-darkreader-inline-color="">cd</span>&nbsp;Desktop&nbsp;<span data-darkreader-inline-color="">#&nbsp;进入桌面</span><br>taro&nbsp;init&nbsp;TaroTestDemo&nbsp;<span data-darkreader-inline-color="">#&nbsp;初始化&nbsp;Taro&nbsp;项目</span><br><br><span data-darkreader-inline-color="">cd</span>&nbsp;TaroTestDemo&nbsp;<span data-darkreader-inline-color="">#&nbsp;进入文件夹</span><br>npm&nbsp;install&nbsp;<span data-darkreader-inline-color="">#&nbsp;安装依赖</span><br>npm&nbsp;run&nbsp;dev:h5&nbsp;<span data-darkreader-inline-color="">#&nbsp;运行</span><br></code>
```

脚手架选项如下：

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

确保遵循上述步骤来准备 Rax 和 Taro 的测试环境。在双方都构建完成后，您可以执行 Jest 测试来验证转换过程。

## 03 | 执行自动化测试

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

1.  安装 Jest 命令行执行：`npm install --save-dev jest`
    
2.  package.json 配置：`"test:e2e": "jest tests/e2e.test.js"`
    
3.  命令行执行：`npm run test:e2e`
    

此时，你就可以在本地同时运行 Rax 与 Taro 项目，一边写 Rax 一边可实时通过此条命令进行编译转换 Taro。

## 五、总结

本篇文章从零开始构造了一个略具复杂度的 Rax 转 Taro 编译器。

初始目标挺吓人，但经过合理拆解发现大目标也不过只是走通 MVP（最小可行产品）后的重复累加。工作如此，生活亦如此。专注你的目标，不要被纷繁的信息流影响，脚踏实地一步步完成你的小Step，一切总能完成的。

后续对这个编译器，我计划如下内容，欢迎持续关注：

-   新增自定义脚手架功能
    
-   抹平转换过程中的 CSS 样式差异
    
-   新增 README\_EN 完善中英文使用文档
    

写作不易，如果觉得本文对你有启发有帮助的话，请在 GitHub 帮我点个 Star ⭐

交个朋友，愿我们更高处相见️，比心感谢 ❤ ~~~