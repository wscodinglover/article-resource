## 写在前面

最近在进行移动端h5开发，首页需要加载的资源很多，一个lottie动效需要请求70多张图片，但是遇到安卓webview限制请求并发数，导致部分图片请求失败破图。当然图片资源可以做闲时加载和预加载，可以减轻播放动效时资源未加载的问题。

![Image](https://mmbiz.qpic.cn/sz_mmbiz_png/83d3vL8fIicaVIVtBCvciaCvFAXiaOAWSlvuCEhKROBGoXzZibb5ibv5f14IXLP7LsuWhVibjHN0fNdiaAl6ATcNwxP1Q/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

同样的，业务开发也会遇到需要异步请求几十个接口，如果同时并发请求浏览器会进行限制请求数，也会给后端造成请求压力。

## 场景说明

现在有个场景：

请你实现一个并发请求函数concurrencyRequest(urls, maxNum)，要求如下：

-   要求最大并发数 maxNum
    
-   每当有一个请求返回，就留下一个空位，可以增加新的请求
    
-   所有请求完成后，结果按照 urls 里面的顺序依次打出（发送请求的函数可以直接使用fetch即可）
    

初始实现：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;preloadManger&nbsp;=&nbsp;<span>(<span>urls,&nbsp;maxCount&nbsp;=&nbsp;<span>5</span></span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;count&nbsp;=&nbsp;<span>0</span>;&nbsp;<span data-darkreader-inline-color="">//&nbsp;计数&nbsp;--&nbsp;用于控制并发数</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;createTask&nbsp;=&nbsp;<span><span>()</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(count&nbsp;&lt;&nbsp;maxCount)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;url&nbsp;=&nbsp;urls.pop();&nbsp;<span data-darkreader-inline-color="">//&nbsp;从请求数组中取值</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(url)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;无论请求是否成功，都要执行taskFinish</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loader(url).finally(taskFinish);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;添加下一个请求</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;createTask();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;};<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;taskFinish&nbsp;=&nbsp;<span><span>()</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;count--;<br>&nbsp;&nbsp;&nbsp;&nbsp;createTask();<br>&nbsp;&nbsp;};<br><br>&nbsp;&nbsp;createTask();<br>};<br><br><span data-darkreader-inline-color="">//&nbsp;进行异步请求</span><br><span data-darkreader-inline-color="">const</span>&nbsp;loader&nbsp;=&nbsp;<span data-darkreader-inline-color="">async</span>&nbsp;(url)&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;res&nbsp;=&nbsp;<span data-darkreader-inline-color="">await</span>&nbsp;fetch(url).then(<span><span>res</span>=&gt;</span>res.json());<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">"res"</span>,res);<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;res<br>}<br><br><span data-darkreader-inline-color="">const</span>&nbsp;urls&nbsp;=&nbsp;[];<br><span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span>1</span>;&nbsp;i&nbsp;&lt;=&nbsp;<span>20</span>;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;urls.push(<span data-darkreader-inline-color="">`https://jsonplaceholder.typicode.com/todos/<span>${i}</span>`</span>);<br>}<br><br>preloadManger(urls,&nbsp;<span>5</span>)<br></code>
```

请求状态：

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

可以看到上面的请求是每五个一组进行请求，当一个请求无论返回成功或是失败，都会从请求数组中再取一个请求进行补充。

## 设计思路

那么，我们可以考虑使用队列去请求大量接口。

思路如下：

假定最大并发数是maxNum=5，图中对接口进行了定义编号，当请求队列池中有一个请求返回后，就向池子中新增一个接口进行请求，依次直到最后一个请求执行完毕。

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

当然，要保证程序的健壮性，需要考虑一些边界情况，如下：

-   当初始请求数组urls的长度为0时，此时请求结果数组results是个空数组
    
-   最大并发数maxNums>urls的长度时，请求数为urls的长度
    
-   需要定义计数器count去判断是否全部请求完毕
    
-   无论请求成功与否，都应该将结果存在结果数组results中
    
-   结果数组results和urls数组的顺序保持一致，方便存取
    

## 代码实现

在前面的初始实现的代码中，虽然都能满足基本需求，但是并没有考虑一些边界条件，对此需要根据上面设计思路重新实现得到：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;并发请求函数</span><br><span data-darkreader-inline-color="">const</span>&nbsp;concurrencyRequest&nbsp;=&nbsp;<span>(<span>urls,&nbsp;maxNum</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Promise</span>(<span>(<span>resolve</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(urls.length&nbsp;===&nbsp;<span>0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve([]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;results&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;index&nbsp;=&nbsp;<span>0</span>;&nbsp;<span data-darkreader-inline-color="">//&nbsp;下一个请求的下标</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;count&nbsp;=&nbsp;<span>0</span>;&nbsp;<span data-darkreader-inline-color="">//&nbsp;当前请求完成的数量</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;发送请求</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">async</span>&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">request</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(index&nbsp;===&nbsp;urls.length)&nbsp;<span data-darkreader-inline-color="">return</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;i&nbsp;=&nbsp;index;&nbsp;<span data-darkreader-inline-color="">//&nbsp;保存序号，使result和urls相对应</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;url&nbsp;=&nbsp;urls[index];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(url);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">try</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;resp&nbsp;=&nbsp;<span data-darkreader-inline-color="">await</span>&nbsp;fetch(url);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;resp&nbsp;加入到results</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;results[i]&nbsp;=&nbsp;resp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">catch</span>&nbsp;(err)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;err&nbsp;加入到results</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;results[i]&nbsp;=&nbsp;err;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">finally</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;判断是否所有的请求都已完成</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(count&nbsp;===&nbsp;urls.length)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">'完成了'</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(results);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;maxNum和urls.length取最小进行调用</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;times&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.min(maxNum,&nbsp;urls.length);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span>0</span>;&nbsp;i&nbsp;&lt;&nbsp;times;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;})<br>}<br></code>
```

测试代码：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">const</span>&nbsp;urls&nbsp;=&nbsp;[];<br><span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span>1</span>;&nbsp;i&nbsp;&lt;=&nbsp;<span>20</span>;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;urls.push(<span data-darkreader-inline-color="">`https://jsonplaceholder.typicode.com/todos/<span>${i}</span>`</span>);<br>}<br>concurrencyRequest(urls,&nbsp;<span>5</span>).then(<span><span>res</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(res);<br>})<br><br></code>
```

请求结果：

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

上面代码基本实现了前端并发请求的需求，也基本满足需求，在生产中其实有很多已经封装好的库可以直接使用。比如：p-limit【https://github.com/sindresorhus/p-limit】

## 阅读p-limit源码

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">import</span>&nbsp;Queue&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">'yocto-queue'</span>;<br><span data-darkreader-inline-color="">import</span>&nbsp;{AsyncResource}&nbsp;<span data-darkreader-inline-color="">from</span>&nbsp;<span data-darkreader-inline-color="">'#async_hooks'</span>;<br><br><span data-darkreader-inline-color="">export</span>&nbsp;<span data-darkreader-inline-color="">default</span>&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">pLimit</span>(<span>concurrency</span>)&nbsp;</span>{<br>&nbsp;<span data-darkreader-inline-color="">//&nbsp;判断这个参数是否是一个大于0的整数，如果不是就抛出一个错误</span><br>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<br>&nbsp;&nbsp;!((<span data-darkreader-inline-color="">Number</span>.isInteger(concurrency)<br>&nbsp;&nbsp;||&nbsp;concurrency&nbsp;===&nbsp;<span data-darkreader-inline-color="">Number</span>.POSITIVE_INFINITY)<br>&nbsp;&nbsp;&amp;&amp;&nbsp;concurrency&nbsp;&gt;&nbsp;<span>0</span>)<br>&nbsp;)&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">throw</span>&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">TypeError</span>(<span data-darkreader-inline-color="">'Expected&nbsp;`concurrency`&nbsp;to&nbsp;be&nbsp;a&nbsp;number&nbsp;from&nbsp;1&nbsp;and&nbsp;up'</span>);<br>&nbsp;}<br><br>&nbsp;<span data-darkreader-inline-color="">//&nbsp;创建队列&nbsp;--&nbsp;用于存取请求</span><br>&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;queue&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Queue();<br>&nbsp;<span data-darkreader-inline-color="">//&nbsp;计数</span><br>&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;activeCount&nbsp;=&nbsp;<span>0</span>;<br><br>&nbsp;<span data-darkreader-inline-color="">//&nbsp;用来处理并发数的函数</span><br>&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;next&nbsp;=&nbsp;<span><span>()</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;activeCount--;<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(queue.size&nbsp;&gt;&nbsp;<span>0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">// queue.dequeue()可以理解为[].shift()，取出队列中的第一个任务，由于确定里面是一个函数，所以直接执行就可以了；</span><br>&nbsp;&nbsp;&nbsp;queue.dequeue()();<br>&nbsp;&nbsp;}<br>&nbsp;};<br><br>&nbsp;<span data-darkreader-inline-color="">//&nbsp;run函数就是用来执行异步并发任务</span><br>&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;run&nbsp;=&nbsp;<span data-darkreader-inline-color="">async</span>&nbsp;(function_,&nbsp;resolve,&nbsp;arguments_)&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;activeCount加1，表示当前并发数加1</span><br>&nbsp;&nbsp;activeCount++;<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;执行传入的异步函数，将结果赋值给result，注意：现在的result是一个处在pending状态的Promise</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;result&nbsp;=&nbsp;<span>(<span><span data-darkreader-inline-color="">async</span>&nbsp;(</span>)&nbsp;=&gt;</span>&nbsp;function_(...arguments_))();<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;resolve函数就是enqueue函数中返回的Promise的resolve函数</span><br>&nbsp;&nbsp;resolve(result);<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;等待result的状态发生改变，这里使用了try...catch，因为result可能会出现异常，所以需要捕获异常；</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">try</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">await</span>&nbsp;result;<br>&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">catch</span>&nbsp;{}<br><br>&nbsp;&nbsp;next();<br>&nbsp;};<br><br>&nbsp;<span data-darkreader-inline-color="">//&nbsp;将run函数添加到请求队列中</span><br>&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;enqueue&nbsp;=&nbsp;<span>(<span>function_,&nbsp;resolve,&nbsp;arguments_</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;queue.enqueue(<br>&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;将run函数绑定到AsyncResource上，不需要立即执行，对此添加了一个bind方法</span><br>&nbsp;&nbsp;&nbsp;AsyncResource.bind(run.bind(<span data-darkreader-inline-color="">undefined</span>,&nbsp;function_,&nbsp;resolve,&nbsp;arguments_)),<br>&nbsp;&nbsp;);<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;立即执行一个异步函数，等待下一个微任务（注意：因为activeCount是异步更新的，所以需要等待下一个微任务执行才能获取新的值）</span><br>&nbsp;&nbsp;<span>(<span><span data-darkreader-inline-color="">async</span>&nbsp;(</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;This&nbsp;function&nbsp;needs&nbsp;to&nbsp;wait&nbsp;until&nbsp;the&nbsp;next&nbsp;microtask&nbsp;before&nbsp;comparing</span><br>&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;`activeCount`&nbsp;to&nbsp;`concurrency`,&nbsp;because&nbsp;`activeCount`&nbsp;is&nbsp;updated&nbsp;asynchronously</span><br>&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;when&nbsp;the&nbsp;run&nbsp;function&nbsp;is&nbsp;dequeued&nbsp;and&nbsp;called.&nbsp;The&nbsp;comparison&nbsp;in&nbsp;the&nbsp;if-statement</span><br>&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;needs&nbsp;to&nbsp;happen&nbsp;asynchronously&nbsp;as&nbsp;well&nbsp;to&nbsp;get&nbsp;an&nbsp;up-to-date&nbsp;value&nbsp;for&nbsp;`activeCount`.</span><br>&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">await</span>&nbsp;<span data-darkreader-inline-color="">Promise</span>.resolve();<br><br>&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;判断activeCount是否小于concurrency，并且队列中有任务，如果满足条件就会将队列中的任务取出来执行</span><br>&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(activeCount&nbsp;&lt;&nbsp;concurrency&nbsp;&amp;&amp;&nbsp;queue.size&nbsp;&gt;&nbsp;<span>0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;注意：queue.dequeue()()执行的是run函数</span><br>&nbsp;&nbsp;&nbsp;&nbsp;queue.dequeue()();<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;})();<br>&nbsp;};<br><br>&nbsp;<span data-darkreader-inline-color="">//&nbsp;接收一个函数fn和参数args，然后返回一个Promise，执行出队操作</span><br>&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;generator&nbsp;=&nbsp;<span>(<span>function_,&nbsp;...arguments_</span>)&nbsp;=&gt;</span>&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Promise</span>(<span><span>resolve</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;enqueue(function_,&nbsp;resolve,&nbsp;arguments_);<br>&nbsp;});<br><br>&nbsp;<span data-darkreader-inline-color="">//&nbsp;向外暴露当前的并发数和队列中的任务数，并且手动清空队列</span><br>&nbsp;<span data-darkreader-inline-color="">Object</span>.defineProperties(generator,&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;当前并发数</span><br>&nbsp;&nbsp;<span>activeCount</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span>get</span>:&nbsp;<span><span>()</span>&nbsp;=&gt;</span>&nbsp;activeCount,<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;队列中的任务数</span><br>&nbsp;&nbsp;<span>pendingCount</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span>get</span>:&nbsp;<span><span>()</span>&nbsp;=&gt;</span>&nbsp;queue.size,<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;清空队列</span><br>&nbsp;&nbsp;<span>clearQueue</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;value()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;queue.clear();<br>&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;},<br>&nbsp;});<br><br>&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;generator;<br>}<br><br></code>
```

整个库只有短短71行代码，在代码中导入了yocto-queue库，它是一个微型的队列数据结构。

## 手写源码

在进行手撕源码时，可以借助数组进行简易的实现：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span><span data-darkreader-inline-color="">class</span>&nbsp;<span data-darkreader-inline-color="">PLimit</span>&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">constructor</span>(concurrency)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.concurrency&nbsp;=&nbsp;concurrency;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.activeCount&nbsp;=&nbsp;<span>0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.queue&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span>(<span>fn,&nbsp;...args</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Promise</span>(<span><span>resolve</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.enqueue(fn,&nbsp;resolve,&nbsp;args);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;enqueue(fn,&nbsp;resolve,&nbsp;args)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.queue.push(<span data-darkreader-inline-color="">this</span>.run.bind(<span data-darkreader-inline-color="">this</span>,&nbsp;fn,&nbsp;resolve,&nbsp;args));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>(<span><span data-darkreader-inline-color="">async</span>&nbsp;(</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">await</span>&nbsp;<span data-darkreader-inline-color="">Promise</span>.resolve();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">this</span>.activeCount&nbsp;&lt;&nbsp;<span data-darkreader-inline-color="">this</span>.concurrency&nbsp;&amp;&amp;&nbsp;<span data-darkreader-inline-color="">this</span>.queue.length&nbsp;&gt;&nbsp;<span>0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.queue.shift()();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">async</span>&nbsp;run(fn,&nbsp;resolve,&nbsp;args)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.activeCount++;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;result&nbsp;=&nbsp;<span>(<span><span data-darkreader-inline-color="">async</span>&nbsp;(</span>)&nbsp;=&gt;</span>&nbsp;fn(...args))();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(result);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">try</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">await</span>&nbsp;result;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">catch</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.next();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;next()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.activeCount--;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">this</span>.queue.length&nbsp;&gt;&nbsp;<span>0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.queue.shift()();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br></code>
```

## 小结

在这篇文章中，简要介绍了为什么要进行并发请求，阐述了使用请求池队列实现并发请求的设计思路，简要实现代码。

此外，还阅读分析了p-limit的源码，并使用数组进行简要的源码编写，以实现要求。

## 参考文章

-   【源码共读】大并发量如何控制并发数https://juejin.cn/post/7179220832575717435?searchId=20240430092814392DC2208C545E691A26
    
-   前端实现并发控制网络请求[https://mp.weixin.qq.com/s/9uq2SqkcMSSWjks0x7RQJg](https://mp.weixin.qq.com/s?__biz=Mzg4NTk4MjI3NA==&mid=2247488566&idx=1&sn=cf614a69dd851ac69f62493cb17db595&scene=21#wechat_redirect)
    
-   关于前端：如何实现并发请求数量控制？https://juejin.cn/post/7163522138698153997