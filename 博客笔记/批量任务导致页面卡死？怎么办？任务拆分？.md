```
<section><mp-common-profile data-pluginname="mpprofile" data-id="MzAxMTMyOTk3MA==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/e93fo6YQKNmP3YCibFqeuFenfGuV6cesicX6UicG1VZwLlibogEJmbSRNoSwx8JxuQ06WKJXgz5xyv20jicbGTUbwxw/300?wx_fmt=png&amp;wxfrom=19" data-nickname="React" data-alias="react_native" data-signature="互联网从业者，专注于 React系列精彩内容推荐。关注大前端、Node技术全栈、Flutter、WebAssembly、鸿蒙（harmonyOS）、小程序等互联网科技领域最前沿技术，定期分享个人创业经验。" data-from="0" data-is_biz_ban="0" data-origin_num="50" data-isban="0" data-biz_account_status="0" data-index="0"></mp-common-profile></section><p data-style="outline: 0px; color: rgb(0, 0, 0); font-size: 16px; white-space: normal; font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; letter-spacing: 0.544px; text-align: center; visibility: visible;" data-darkreader-inline-outline="" data-darkreader-inline-color=""><span data-darkreader-inline-outline="" data-darkreader-inline-color="">点击上方&nbsp;</span><span data-darkreader-inline-outline=""><span data-darkreader-inline-outline="" data-darkreader-inline-color="">React</span></span><span data-darkreader-inline-outline="" data-darkreader-inline-color="">，关注公众号</span><span data-darkreader-inline-outline="" data-darkreader-inline-color=""></span></p><p data-style="outline: 0px; color: rgb(34, 34, 34); font-size: 16px; white-space: normal; font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; letter-spacing: 0.544px; text-align: center; word-spacing: 0.8px; visibility: visible;" data-darkreader-inline-outline="" data-darkreader-inline-color=""><span data-darkreader-inline-outline="" data-darkreader-inline-color="">回复</span><span data-style="outline: 0px; color: rgb(0, 0, 0); caret-color: rgb(51, 51, 51); font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &quot;PingFang SC&quot;, Cambria, Cochin, Georgia, Times, &quot;Times New Roman&quot;, serif; font-size: 14px; letter-spacing: 0.544px; word-spacing: 2px; visibility: visible;" data-darkreader-inline-outline="" data-darkreader-inline-color=""><span data-darkreader-inline-outline="" data-darkreader-inline-color="">加群</span></span><span data-darkreader-inline-outline="" data-darkreader-inline-color="">，加入技术交流群交流</span></p>
```

需求背景

需要基于高德地图展示海量点位（大概几万个），点位样式要自定义（创建DOM），虽然使用了聚合点，但初始化时仍需要将几万个点位的DOM结构都创建出来。

这里补充一句，高德地图在2.0版本对这种方式进行了优化，但同时少了某些功能，我的需求要使用1.4版本的这种方式渲染。

## 问题及定位分析

功能实现后，发现从开始加载点位，到点位出现的过程中，页面会卡死，无法响应用户交互，可以点击Demo的常规模式查看效果（实际业务下有更多逻辑，阻塞时间会更久）。

![Image](https://mmbiz.qpic.cn/mmbiz_png/FaeDdIfeuq7l3fHIjFQqG7jzLG1bk7PglPuXsu49jkEHcyZ8tHSEEGh7DbLEQY9AKuYKzPibRAD5ibWSJiaGRFIhA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

可以看到，当我开始渲染点位后，点击输入框进行输入，是没有立即响应的，点位加载完后才会对之前的交互做响应。

## 问题分析

其实从上面高德地图的点位渲染逻辑很容易想到主要是批量创建点位的DOM结构占用了主线程

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

可以看到，批量的genMarker任务占用了大量时间，genMarker会在每次创建点位时执行一次，一次创建4w个点位，就会连续执行4w次。

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">//&nbsp;生成点位，创建DOM自定义样式</span><br>genMarker(device)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;innerHTML&nbsp;=&nbsp;<span data-darkreader-inline-color="">`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class="camera"&gt;&lt;/div&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;`</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;size&nbsp;=&nbsp;[<span data-darkreader-inline-color="">48</span>,&nbsp;<span data-darkreader-inline-color="">49</span>]<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;markerOffset&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;AMap.Pixel(-size[<span data-darkreader-inline-color="">0</span>]&nbsp;/&nbsp;<span data-darkreader-inline-color="">2</span>,&nbsp;-size[<span data-darkreader-inline-color="">1</span>]&nbsp;/&nbsp;<span data-darkreader-inline-color="">2</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;marker&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;AMap.Marker({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">position</span>:&nbsp;device.lnglat,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">extData</span>:&nbsp;device,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size,<br>&nbsp;&nbsp;&nbsp;&nbsp;})<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;container&nbsp;=&nbsp;<span data-darkreader-inline-color="">document</span>.createElement(<span data-darkreader-inline-color="">'div'</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;container.className&nbsp;=&nbsp;<span data-darkreader-inline-color="">'map-marker'</span><br>&nbsp;&nbsp;&nbsp;&nbsp;container.innerHTML&nbsp;=&nbsp;innerHTML<br>&nbsp;&nbsp;&nbsp;&nbsp;marker.setContent(container)<br>&nbsp;&nbsp;&nbsp;&nbsp;marker.setOffset(markerOffset)<br>&nbsp;&nbsp;&nbsp;&nbsp;marker.selected&nbsp;=&nbsp;<span data-darkreader-inline-color="">false</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;marker<br>}<br></code>
```

## 页面显示机制

动的画面其实是由一帧一帧的静态图快速切换组成的，人眼的反应速度有限，当画面切换的够快，人眼看着就是连续的动画了。

对于人眼来说，当每秒切换60张图片时，就会认为是连贯的。所以主流的显示器是60hz的，1s刷新60次，那么每16.7ms需要刷新一次，浏览器会自动适配这个频率，这时对应我们前端页面就是每16.7ms需要渲染一次。

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

页面每隔16.7ms才会渲染一次，那么在两次渲染的中间时间，就是浏览器的空闲时间，在这段空闲时间执行的任务，是不会阻塞到页面渲染的流畅性的。反之，对于上面的案例，数万个genMarker在一个帧区间内连续的执行，下一帧一直不能渲染，页面看起来就被卡住了。

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

## 任务拆分

对于大量的计算或许首先考虑的是Web Worker使其不占用主线程，但是由于要操作DOM，不适合当前场景。

对于页面的流畅性来说，这些点位的创建属于「低优先级任务」。既然卡顿的原因是这些genMarker任务一个接一个的「连续」的在执行，一直占用着主线程，那么我们可以将这些批量的任务进行拆分，保证这些任务只在空闲时间执行。每次执行下一个任务的时候，先检查一下当前页面是否该渲染下一帧了，这时需要「把主线程让出来」，让页面进行渲染（了解react的人应该感觉很熟悉，思路来自react的Fiber）

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

## requestIdleCallback

「让出主线程」，关键的一点在于我们如何知道什么时候是空闲时间，什么时候空闲时间结束，该进行渲染了。requestIdleCallback就是浏览器提供给我们用来判断这个时机的api，它会在浏览器的空闲时间来执行传给它的回调函数。另外如果指定了超时时间，会在超时后的下一帧强制执行

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">const</span>&nbsp;id&nbsp;=&nbsp;<span data-darkreader-inline-color="">window</span>.requestIdleCallback(<span>(<span data-darkreader-inline-color="">deadline</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;当前帧剩余时间大于0，或任务已超时</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>(deadline.timeRemaining()&nbsp;&gt;&nbsp;<span data-darkreader-inline-color="">0</span>&nbsp;||&nbsp;deadline.didTimeout)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;do&nbsp;something</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">1</span>)<br>&nbsp;&nbsp;}<br>},&nbsp;{&nbsp;<span data-darkreader-inline-color="">timeout</span>:&nbsp;<span data-darkreader-inline-color="">2000</span>&nbsp;})&nbsp;<span data-darkreader-inline-color="">//&nbsp;指定超时时间</span><br><br><span data-darkreader-inline-color="">//&nbsp;window.cancelIdleCallback(id)&nbsp;与定时器类似，支持取消</span><br><br></code>
```

requestIdleCallback在Event Loop的执行时机如下图所示，蓝色区域代表一帧内的渲染任务，当这些任务执行完后，剩余的时间被认为是空闲时间

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

以一个简单的任务(singlTask)为例，以常规模式连续执行2w次，全部执行完需要大概2s时间（依赖机器性能变化），这期间主线程被一直被占用，页面会被卡住。

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">singleTask</span>(<span data-darkreader-inline-color=""></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;now&nbsp;=&nbsp;performance.now()<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(performance.now()&nbsp;-&nbsp;now&nbsp;&lt;&nbsp;<span data-darkreader-inline-color="">0.001</span>)&nbsp;{&nbsp;}&nbsp;<span data-darkreader-inline-color="">//&nbsp;模拟耗时操作，每次任务耗时约0.001ms</span><br>}<br><br><span data-darkreader-inline-color="">const</span>&nbsp;data&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Array</span>(<span data-darkreader-inline-color="">20000</span>).fill(<span data-darkreader-inline-color="">1</span>)<br><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">normarlRun</span>(<span data-darkreader-inline-color=""></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;data.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;2w个任务连续执行</span><br>&nbsp;&nbsp;&nbsp;&nbsp;singleTask(data[i])<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;result(<span data-darkreader-inline-color="">'done'</span>)<br>}<br></code>
```

对其使用requestIdleCallback进行拆分，只在空闲时间执行部分任务，若当前帧的空闲时间结束，则暂停批量任务，让出主线程：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">ridRun</span>(<span data-darkreader-inline-color=""></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;option&nbsp;=&nbsp;{&nbsp;<span data-darkreader-inline-color="">timeout</span>:&nbsp;<span data-darkreader-inline-color="">200</span>&nbsp;}&nbsp;<span data-darkreader-inline-color="">//&nbsp;任务超时时间</span><br><br>&nbsp;&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">handler</span>(<span data-darkreader-inline-color="">idleDeadline</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;((idleDeadline.timeRemaining()&nbsp;&gt;&nbsp;<span data-darkreader-inline-color="">0</span>&nbsp;||&nbsp;idleDeadline.didTimeout)&nbsp;&amp;&amp;&nbsp;i&nbsp;&lt;&nbsp;data.length)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;当前帧有剩余时间，或任务已等待超时强制执行</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;singleTask(data[i++])<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;idleDeadline.timeRemaining()&nbsp;===&nbsp;0&nbsp;当前帧已没有空闲时间，让出主线程</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(i&nbsp;&lt;&nbsp;data.length)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">window</span>.requestIdleCallback(handler,&nbsp;option)&nbsp;<span data-darkreader-inline-color="">//&nbsp;任务未执行完，继续等待下次空闲时间执行</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result(<span data-darkreader-inline-color="">'done'</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">window</span>.requestIdleCallback(handler,&nbsp;option)<br>}<br></code>
```

## 模拟requestIdleCallback

不幸的是requestIdleCallback兼容性不够好，Safari完全不支持：

参考react的实现，我们可以使用requestAnimationFrame和MessageChannel来模拟实现一个requestIdleCallback requestAnimationFrame在每一帧开始渲染前执行（见上面的Event Loopt图），当帧开始渲染前，我们标记开始时间(start)，并使用MessageChannel创建一个宏任务，根据上面的Event Loop流程，渲染完毕后，会执行刚才创建出的宏任务，这时在宏任务中对比标记的开始时间，是否超出了一帧的渲染时间(current - start > 16.7)，来判断当前是否是空闲时间。

setTimeout即使指定时间为0 浏览器实际也会延时几毫秒后才执行（chrome大概为4ms），因此使用MessageChannel而不是setTimeout来创建宏任务

模拟requestIdleCallback的具体实现：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">const</span>&nbsp;genId&nbsp;=&nbsp;(<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color=""></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;id&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color=""></span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;++id<br>&nbsp;&nbsp;}<br>})()<br><br><span data-darkreader-inline-color="">const</span>&nbsp;idMap:&nbsp;{<br>&nbsp;&nbsp;[key:&nbsp;number]:&nbsp;number<br>}&nbsp;=&nbsp;{}<br><br><span data-darkreader-inline-color="">const</span>&nbsp;_requestIdleCallback:&nbsp;(<br>&nbsp;&nbsp;cb:&nbsp;<span>(<span data-darkreader-inline-color="">idleDeadline:&nbsp;IdleDeadline</span>)&nbsp;=&gt;</span>&nbsp;<span data-darkreader-inline-color="">void</span>,<br>&nbsp;&nbsp;options?:&nbsp;{&nbsp;<span data-darkreader-inline-color="">timeout</span>:&nbsp;number&nbsp;}<br>)&nbsp;=&gt;&nbsp;number&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">cb,&nbsp;options</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;channel&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;MessageChannel()<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;port1&nbsp;=&nbsp;channel.port1<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;port2&nbsp;=&nbsp;channel.port2<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;deadlineTime:&nbsp;number&nbsp;<span data-darkreader-inline-color="">//&nbsp;超时时间</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;frameDeadlineTime:&nbsp;number&nbsp;<span data-darkreader-inline-color="">//&nbsp;当前帧的截止时间</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;callback:&nbsp;<span>(<span data-darkreader-inline-color="">idleDeadline:&nbsp;IdleDeadline</span>)&nbsp;=&gt;</span>&nbsp;<span data-darkreader-inline-color="">void</span><br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;id&nbsp;=&nbsp;genId()<br><br>&nbsp;&nbsp;port2.onmessage&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">()</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;frameTimeRemaining&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">()</span>&nbsp;=&gt;</span>&nbsp;frameDeadlineTime&nbsp;-&nbsp;performance.now()&nbsp;<span data-darkreader-inline-color="">//&nbsp;获取当前帧剩余时间</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;didTimeout&nbsp;=&nbsp;performance.now()&nbsp;&gt;=&nbsp;deadlineTime&nbsp;<span data-darkreader-inline-color="">//&nbsp;是否超时</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(didTimeout&nbsp;||&nbsp;frameTimeRemaining()&nbsp;&gt;&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;idleDeadline&nbsp;=&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">timeRemaining</span>:&nbsp;frameTimeRemaining,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;didTimeout<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback&nbsp;&amp;&amp;&nbsp;callback(idleDeadline)<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idMap[id]&nbsp;=&nbsp;requestAnimationFrame(<span>(<span data-darkreader-inline-color="">timeStamp</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frameDeadlineTime&nbsp;=&nbsp;timeStamp&nbsp;+&nbsp;<span data-darkreader-inline-color="">16.7</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port1.postMessage(<span data-darkreader-inline-color="">null</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;idMap[id]&nbsp;=&nbsp;<span data-darkreader-inline-color="">window</span>.requestAnimationFrame(<span>(<span data-darkreader-inline-color="">timeStamp</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;frameDeadlineTime&nbsp;=&nbsp;timeStamp&nbsp;+&nbsp;<span data-darkreader-inline-color="">16.7</span>&nbsp;<span data-darkreader-inline-color="">//&nbsp;当前帧截止时间，按照&nbsp;60fps&nbsp;计算</span><br>&nbsp;&nbsp;&nbsp;&nbsp;deadlineTime&nbsp;=&nbsp;options?.timeout&nbsp;?&nbsp;timeStamp&nbsp;+&nbsp;options.timeout&nbsp;:&nbsp;<span data-darkreader-inline-color="">Infinity</span>&nbsp;<span data-darkreader-inline-color="">//&nbsp;超时时间</span><br>&nbsp;&nbsp;&nbsp;&nbsp;callback&nbsp;=&nbsp;cb<br>&nbsp;&nbsp;&nbsp;&nbsp;port1.postMessage(<span data-darkreader-inline-color="">null</span>)<br>&nbsp;&nbsp;})<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;id<br>}<br><br><span data-darkreader-inline-color="">const</span>&nbsp;_cancelIdleCallback&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">id:&nbsp;number</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!idMap[id])&nbsp;<span data-darkreader-inline-color="">return</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">window</span>.cancelAnimationFrame(idMap[id])<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">delete</span>&nbsp;idMap[id]<br>}<br><br><span data-darkreader-inline-color="">export</span>&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;requestIdleCallback&nbsp;=&nbsp;<span data-darkreader-inline-color="">window</span>.requestIdleCallback&nbsp;||&nbsp;_requestIdleCallback<br><span data-darkreader-inline-color="">export</span>&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;cancelIdleCallback&nbsp;=&nbsp;<span data-darkreader-inline-color="">window</span>.cancelIdleCallback&nbsp;||&nbsp;_cancelIdleCallback<br></code>
```

## 使用requestIdleCallback拆分点位生成

将genMarker批量任务进行拆分，只在空闲时间时间进行拆分：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">addMarkersByRid()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;cancelIdleCallback(<span data-darkreader-inline-color="">this</span>.ridId)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;{&nbsp;markerList,&nbsp;points,&nbsp;genMarker,&nbsp;genCluster&nbsp;}&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;index&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;ridOption&nbsp;=&nbsp;{&nbsp;<span data-darkreader-inline-color="">timeout</span>:&nbsp;<span data-darkreader-inline-color="">20</span>&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;handler&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">idleDeadline</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;{&nbsp;timeRemaining&nbsp;}&nbsp;=&nbsp;idleDeadline<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;只在空闲时间生成点位</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(timeRemaining()&nbsp;&gt;&nbsp;<span data-darkreader-inline-color="">0</span>&nbsp;&amp;&amp;&nbsp;index&nbsp;&lt;&nbsp;points.length)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;device&nbsp;=&nbsp;points[index]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;marker&nbsp;=&nbsp;genMarker(device)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;markerList.push(marker)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index++<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(index&nbsp;&lt;&nbsp;points.length)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.ridId&nbsp;=&nbsp;requestIdleCallback(handler,&nbsp;ridOption)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">'done'</span>)&nbsp;<span data-darkreader-inline-color="">//&nbsp;全部点位生成完毕</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.ridId&nbsp;=&nbsp;requestIdleCallback(handler,&nbsp;ridOption)<br>}<br></code>
```

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

可以看到，点位的渲染并没有再影响到页面的响应了

> 作者：rasck 链接：https://juejin.cn/post/7221793823705268284
> 
> 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```
<section mp-original-font-size="16" mp-original-line-height="28.799999237060547" data-style="margin-bottom: 20px; padding-right: 0.5em; padding-left: 0.5em; outline: 0px; color: rgb(58, 58, 58); letter-spacing: 2px; word-spacing: 2px; white-space: normal; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &quot;PingFang SC&quot;, Cambria, Cochin, Georgia, Times, &quot;Times New Roman&quot;, serif; font-size: 16px; text-size-adjust: inherit; line-height: 28.8px;" data-darkreader-inline-outline="" data-darkreader-inline-color=""><span data-darkreader-inline-outline=""><span data-darkreader-inline-outline="">欢迎关注「</span><span data-darkreader-inline-outline="" data-darkreader-inline-color="">React</span><span data-darkreader-inline-outline="">」</span></span></section><section data-style="margin-bottom: 0px; outline: 0px; background-color: rgb(255, 255, 255); font-size: 16px; text-align: left; white-space: normal; letter-spacing: 0.544px; color: rgb(102, 102, 102); font-family: Lato, &quot;Helvetica Neue&quot;, Helvetica, sans-serif; font-variant-ligatures: common-ligatures;" data-darkreader-inline-outline="" data-darkreader-inline-color=""><mp-common-profile data-pluginname="mpprofile" data-id="MzAxMTMyOTk3MA==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/e93fo6YQKNmP3YCibFqeuFenfGuV6cesicX6UicG1VZwLlibogEJmbSRNoSwx8JxuQ06WKJXgz5xyv20jicbGTUbwxw/300?wx_fmt=png&amp;wxfrom=19" data-nickname="React" data-alias="react_native" data-signature="互联网从业者，专注于 React系列精彩内容推荐。关注大前端、Node技术全栈、Flutter、WebAssembly、鸿蒙（harmonyOS）、小程序等互联网科技领域最前沿技术，定期分享个人创业经验。" data-from="2" data-is_biz_ban="0" has-insert-preloading="1" data-index="1" data-origin_num="50" data-isban="0" data-weui-theme="light" data-biz_account_status="0"></mp-common-profile></section><section mp-original-font-size="16" mp-original-line-height="28.799999237060547" data-style="margin-bottom: 20px; padding-right: 0.5em; padding-left: 0.5em; outline: 0px; color: rgb(58, 58, 58); letter-spacing: 2px; word-spacing: 2px; white-space: normal; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &quot;PingFang SC&quot;, Cambria, Cochin, Georgia, Times, &quot;Times New Roman&quot;, serif; font-size: 16px; text-size-adjust: inherit; line-height: 28.8px;" data-darkreader-inline-outline="" data-darkreader-inline-color=""><span data-darkreader-inline-outline=""><span data-darkreader-inline-outline="">号内回复</span></span></section><section mp-original-font-size="16" mp-original-line-height="28.799999237060547" data-style="margin-bottom: 5px; outline: 0px; color: rgb(58, 58, 58); letter-spacing: 0.544px; word-spacing: 0.8px; white-space: normal; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &quot;PingFang SC&quot;, Cambria, Cochin, Georgia, Times, &quot;Times New Roman&quot;, serif; font-size: 16px; text-size-adjust: inherit; line-height: 28.8px; word-break: break-word;" data-darkreader-inline-outline="" data-darkreader-inline-color="">&nbsp;"<span data-darkreader-inline-outline="">精选</span>" ，将为您推送 历史精选文章"<span data-darkreader-inline-outline="">react"</span>&nbsp;，将为您推送 React.js 相关的学习资料&nbsp;"<span data-darkreader-inline-outline="">学习指南</span>" ，将为您推送 React-Native学习指南&nbsp;"<span data-darkreader-inline-outline="">vue</span>" ，将为您推送vue.js 相关文章&nbsp;"<span data-darkreader-inline-outline="">小程序</span>" ，将为您推送小程序相关文章&nbsp;"<span data-darkreader-inline-outline="">微信小商店</span>"，将为您推送小程序相关文章&nbsp;"<span data-darkreader-inline-outline="">加群</span>" ，添加群主好友拉你进群</section><section mp-original-font-size="16" mp-original-line-height="28.799999237060547" data-style="margin-bottom: 5px; outline: 0px; color: rgb(58, 58, 58); letter-spacing: 0.544px; word-spacing: 0.8px; white-space: normal; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &quot;PingFang SC&quot;, Cambria, Cochin, Georgia, Times, &quot;Times New Roman&quot;, serif; font-size: 16px; text-size-adjust: inherit; line-height: 28.8px; word-break: break-word;" data-darkreader-inline-outline="" data-darkreader-inline-color="">加我私人微信，拉你进 React进阶、面试交流群，互相监督学习进步等！</section><p data-style="margin-bottom: 0em; outline: 0px; color: rgb(0, 0, 0); letter-spacing: 0.544px; word-spacing: 0.8px; white-space: normal; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &quot;PingFang SC&quot;, Cambria, Cochin, Georgia, Times, &quot;Times New Roman&quot;, serif; font-size: 16px; text-align: center;" data-darkreader-inline-outline="" data-darkreader-inline-color=""><img data-galleryid="" data-imgfileid="308971297" data-ratio="1.261480787253983" data-s="300,640" data-type="jpeg" data-w="1067" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/e93fo6YQKNlJReqfJKqeft8SuT9o4DliaoUIJqmbtBw72F7nYumlpJ5dxIvLfbNv5W0Nf1ZtIltr9bFsL4qd6fg/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" data-darkreader-inline-outline="" data-original-style="outline: 0px; border-style: none; border-radius: 3px; display: initial; background-size: 16px !important; visibility: visible !important; width: 343.977px !important; --darkreader-inline-outline: initial;" data-index="9" src="data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E" _width="343.977px" crossorigin="anonymous" alt="Image"><span data-style="outline: 0px; color: rgb(51, 51, 51); font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; word-spacing: 0.8px;" data-darkreader-inline-outline="" data-darkreader-inline-color=""></span></p><section data-brushtype="text" mp-original-font-size="16" mp-original-line-height="25.600000381469727" data-darkreader-inline-outline="" data-style="margin-bottom: 0em; padding-right: 0.5em; padding-left: 0.5em; outline: 0px; background-color: rgb(255, 255, 255); color: rgb(89, 89, 89); font-size: 16px; white-space: normal; letter-spacing: 2px; font-variant-ligatures: common-ligatures; text-size-adjust: inherit; widows: 1; word-spacing: 2px; font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; border-width: 0px; border-style: none; border-color: initial; text-align: right; line-height: 25.6px;" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpplm16ibb8iaib7RoGQ5iaHEdy66AHd7QqL7A2s5icSBE0aw4iaKOKPnXGYxQPhG7VMpbbYV6VJprSh7w/640?wx_fmt=png" data-darkreader-inline-color="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left=""><span data-darkreader-inline-outline="" data-darkreader-inline-color="">“在看和转发”</span><span data-darkreader-inline-outline="" data-darkreader-inline-color="">就是最大的支持</span></section>
```