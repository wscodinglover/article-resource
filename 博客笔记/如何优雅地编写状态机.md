![Image](https://mmbiz.qpic.cn/mmbiz_gif/icHoerKO3NjIfkxreTDrMPvNKtmPDYHVHsVDUk6PgZv9ucUMdYgiaXcByF56r656hicMjUd1Pgib33c8UbTPT1rbGg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)

状态机，又名有限状态机，自动机。

指的是在限定环境中，根据规律抽象成的数学模型。具体的模型可以作为一种状态产生不同的作用，并且状态间可以进行转换。

在许多算法中，尤其是很多字符串相关算法，如 KMP，AC 自动机等，都会使用该思路。并且在各种实际项目的底层逻辑中也是使用的状态机这一模型进行管理。

![Image](https://mmbiz.qpic.cn/mmbiz_png/icHoerKO3NjIfkxreTDrMPvNKtmPDYHVHPbRQdwXMs6M6JicEYlvkn0jic5EIBcjjkWX3iat62hPBKNBkQD9plgiarw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**问题引入**

此处，引入一道比较简单与典型的字符串处理的题目。

👉 [8\. 字符串转换整数 (atoi)](https://leetcode.cn/problems/string-to-integer-atoi/description/?utm_campign=lcsocial&utm_source=wechat_lc01&utm_medium=article&utm_content=20240307&utm_term=expertise)

> 题意简述：给定一个字符串，将该字符串解析成一个 32 位的整数。规定，可以有前导空格，存在±号的表示，此后读到首个非数字字符表示结束。并将结果收缩到 间。
> 
> 类似 C/C++ 中的 atoi 函数，具体的细节描述可以查看上面的链接。

注意：本文对一些细节，如怎么判断数字是否越界等问题不会着重介绍，主要是为了展示状态的表示与转移。

**普通流程化写法**

整体的处理顺序也比较明朗，用一张流程图来说是这样的：

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

其实根据题意可以将其分为三大步骤：

1.处理前导空格

处理完毕后，开始真正的数据处理

2.处理正负号

处理完毕后，开始真正的数值处理

3.处理数值

处理完毕后，整体处理完毕。作用上正负号标记，就可以获得最终的答案。

```
<span><span><span>class</span> <span>Solution</span> {</span></span>
```

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

**状态机制表**

普通的流程化解法其实并不困难，但是对于思路不是很清晰的初学者朋友来说，一遍写出无错的代码并不简单。

很大一部分原因在于在顺序遍历整个串时缺乏对每种状态的逻辑关系和转移关系的真正思考。

**状态种类分析**

下面我们来仔细分析这串序列存在多少正确的状态。

首先对于任意状态机我们都可以设置一个起始状态标志 StateStart 和终止状态标志 StateEnd。

-   StateStart 表示等待遍历的序列进入有效的合法判断，或者直接终止。
    
-   StateEnd 表示序列进入了终止状态，后续遍历的操作全部无效，一般遇到该标志可以直接输出结果。
    

再根据上方的流程图，可以再抽象出两个状态分别为：符号处理状态 StateSign 和数值处理状态 StateDigit。

-   StateSign 表示处理字符串转为数字的正负号，并且该状态只会出现在 StateStart 状态后和 StateDigit 状态前，且只最多只出现一次。
    
-   StateDigit 表示处理数字字符，该状态最终将通向 StateEnd 结束标志。
    

如果将这些标志制成一张表，则可以有如下表示：

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

**注意**：由于该序列可能存在非法状态，主要体现在两点

1.出现非法字符；

2.是合法字符，但是前后逻辑错误；

并且一些字符会出现让状态保留的情况，如连续出现两个前导空格，则还是保留在起始状态。

用一张图表示可以绘制如下关系：

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

**代码细节**

实际编码可以用枚举等方式来标记状态。

而状态的切换可以提前进行制表。实际运行过程中可以直接查表进行转移。

```
<span><span><span>class</span> <span>Solution</span> {</span></span>
```

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

**状态模式**

到上面的状态机制表，其实已经非常优雅地解决了本题。

而如果从本题进行泛化或者拓展的思考，如：现在要处理小数存在小数点的字符点号“.”，需要使用 E 或 e 表示科学计数法，等等。

随着需求的不断拓展，上面的制表将越来越大。每加一个状态，状态表将进行指数级别的复杂度的扩充。一方面随着状态的增加，频繁的修改表容易写错；另一方面，增加的状态可能只影响小部分的其余状态，对于其他状态可能都是无用功。比如，无论是加小数点还是加 E，StateEnd 状态的下一步永远都是 StateEnd 状态。

再看看具体的处理函数，里面是一个 switch case 当然也可以改写成 if else 的形式。如果你是一个有经验的开发者。一下子就会发现这段处理代码是一个非常糟糕的 Bad Smell。因为随着状态的增加，逻辑调整的修改，这里的分支判断将不断地反复修改，无法保证代码的健壮性。

**解决方案：状态模式**

在经典的 23 种设计模式中，状态模式有如下定义：**允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的状态**。

具体的实现可以使用面向对象的多态的形式来处理。

我们定义一个状态的基类 StateBase，并规定两个接口：

-   StateBase\* nextState(char ch)
    

-   解析出下一个状态
    

-   void handle(char ch)
    

-   处理该状态下的逻辑操作
    

在 C++ 中最常用的使用多态的方式就是虚函数和基类的多态指针。

在具体的迭代过程中，不断根据当前字符转换状态，并根据具体状态做具体的逻辑处理。

**代码细节**

由于我们目的是使用多态的指针，需要指向具体的每个状态类的实例。防止内存膨胀的考虑，可以使用类似单例模式的方式，来获取具体的实例。

由于在处理具体逻辑中需要使用一些辅助变量，比如符号标志 sign，和数值记录 ans。可以作为基类的静态变量或者直接写成可供子类都访问到的类似全局变量的效果。

对于一些状态，没有什么状态逻辑需要处理，因此可以不重载 void handle(char ch) 方法。

```
<span><span>// 状态模式的基类</span></span>
```

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

**小结**

状态的抽象和表示是对程序员对实际场景分析和抽象能力的考验。

常见的思考模式就是先从流程化的方式进行思考。在确定状态后考虑如何写的更加优雅。

在状态较少的情况下，可以通过简单的制表进行处理，但随着场景的变化与需求的变更，会使得代码越来越臃肿。

因此我们就需要使用状态模式。在状态模式中，通过将每个状态单独作为一个类来处理，很好地隔离了每个状态切换间的强耦合。并在对于需求增加的情况下可以用通过添加子类，使得对其他模块达到最小程度的影响程度，这一定程度上也体现了软件开发中的开闭原则。

**BY/**  

本文作者：天赐细莲

编辑&版式：执盈  

声明：本文归 “力扣” 版权所有，如需转载请联系。

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

点个在看，少个 Bug