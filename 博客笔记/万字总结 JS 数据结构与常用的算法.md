> 作者：Ali2333
> 
> https://juejin.cn/post/7094056264283471908

## **一、前言**

首先，为什么我会学习数据结构与算法呢，其实主要是有两方面

-   第一，是我在今年的flag里明确说到我会学这个东西
    
-   第二，学了这些，对自己以后在工作或者面试也会带来许多好处
    

然后，本文是最近学习的一个`总结文章`，文中的算法题，**大部分都是leetcode中**的，如不太理解题意，可直接去leetcode中找到对应的题。

## **二、基本概念**

常常听到算法的时候，就会有人说到 **时间复杂度**， **空间复杂度**。那么这俩玩意是啥呢，下面我们就来一一解释

## 1\. 时间复杂度

其实就是一个函数，用大 O 表示， 比如 O(1)、 O(n)...

它的作用就是用来`定义描述算法的运行时间`

-   **O(1)**
    

```
&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span><br>&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;+=&nbsp;<span data-darkreader-inline-color="">1</span><br>
```

-   **O(n)：** 如果是 O(1) + O(n) 则还是 O(n)
    

```
&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i&nbsp;+=&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(i)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>
```

-   **O(n^2)：** O(n) \* O(n), 也就是双层循环，自此类推：O(n^3)...
    

```
&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i&nbsp;+=&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;j&nbsp;&lt;&nbsp;n;&nbsp;j&nbsp;+=&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(i,&nbsp;j)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>
```

-   **O(logn)：** 就是求 log 以 2 为底的多少次方等于 n
    

```
&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;这个例子就是求2的多少次方会大于i，然后就会结束循环。&nbsp;这就是一个典型的 O(logn)</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(i&nbsp;&lt;&nbsp;n)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(i)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;*=&nbsp;<span data-darkreader-inline-color="">2</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>
```

## 2\. 空间复杂度

和时间复杂度一样，空间复杂度也是用大 O 表示，比如 O(1)、 O(n)...

它用来`定义描述算法运行过程中临时占用的存储空间大小`

> 占用越少 代码写的就越好

-   **O(1)：** 单个变量，所以占用永远是 O(1)
    

```
&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span><br>&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;+=&nbsp;<span data-darkreader-inline-color="">1</span><br>
```

-   **O(n)：** 声明一个数组， 添加 n 个值， 相当于占用了 n 个空间单元
    

```
&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;arr&nbsp;=&nbsp;[]<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i&nbsp;+=&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr.push(i)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>
```

-   **O(n^2)：** 类似一个矩阵的概念，就是二维数组的意思
    

```
&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;arr&nbsp;=&nbsp;[]<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i&nbsp;+=&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr.push([])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;j&nbsp;&lt;&nbsp;n;&nbsp;j&nbsp;+=&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i].push(j)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>
```

## **三、数据结构**

## 1\. 栈

一个`后进先出`的数据结构

按照常识理解就是有序的挤公交，**最后上车**的人会在门口，然后门口的人会**最先下车**

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

> js中没有栈的数据类型，但我们可以通过**Array来模拟一个**

```
<span data-darkreader-inline-color="">const</span>&nbsp;stack&nbsp;=&nbsp;[];<br><br>stack.push(<span data-darkreader-inline-color="">1</span>);&nbsp;<span data-darkreader-inline-color="">//&nbsp;入栈</span><br>stack.push(<span data-darkreader-inline-color="">2</span>);&nbsp;<span data-darkreader-inline-color="">//&nbsp;入栈</span><br><br><span data-darkreader-inline-color="">const</span>&nbsp;item1&nbsp;=&nbsp;stack.pop();&nbsp;&nbsp;<span data-darkreader-inline-color="">//出栈的元素</span><br>
```

### 1）十进制转二进制

```
<span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(n)&nbsp;n为二进制的长度</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(n)&nbsp;n为二进制的长度</span><br><span data-darkreader-inline-color="">const</span>&nbsp;dec2bin&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">dec</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;创建一个字符串</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;res&nbsp;=&nbsp;<span data-darkreader-inline-color="">""</span>;<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;创建一个栈</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;stack&nbsp;=&nbsp;[]<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;遍历数字&nbsp;如果大于0&nbsp;就可以继续转换2进制</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(dec&nbsp;&gt;&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;将数字的余数入栈</span><br>&nbsp;&nbsp;&nbsp;&nbsp;stack.push(dec&nbsp;%&nbsp;<span data-darkreader-inline-color="">2</span>);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;除以2</span><br>&nbsp;&nbsp;&nbsp;&nbsp;dec&nbsp;=&nbsp;dec&nbsp;&gt;&gt;&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;取出栈中的数字</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(stack.length)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;+=&nbsp;stack.pop();<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;返回这个字符串</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;res;<br>};<br>
```

### 2）判断字符串的有效括号

```
<span data-darkreader-inline-color="">//&nbsp;时间复杂度O(n)&nbsp;n为s的length</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度O(n)</span><br><span data-darkreader-inline-color="">const</span>&nbsp;isValid&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">s</span>)&nbsp;=&gt;</span>&nbsp;{<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果长度不等于2的倍数肯定不是一个有效的括号</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(s.length&nbsp;%&nbsp;<span data-darkreader-inline-color="">2</span>&nbsp;===&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span>;<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;创建一个栈</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;stack&nbsp;=&nbsp;[];<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;遍历字符串</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;s.length;&nbsp;i++)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;c&nbsp;=&nbsp;s[i];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果是左括号就入栈</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(c&nbsp;===&nbsp;<span data-darkreader-inline-color="">'('</span>&nbsp;||&nbsp;c&nbsp;===&nbsp;<span data-darkreader-inline-color="">"{"</span>&nbsp;||&nbsp;c&nbsp;===&nbsp;<span data-darkreader-inline-color="">"["</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.push(c);<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果不是左括号&nbsp;且栈为空&nbsp;肯定不是一个有效的括号&nbsp;返回false</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!stack.length)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;拿到最后一个左括号</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;top&nbsp;=&nbsp;stack[stack.length&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果是右括号和左括号能匹配就出栈</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;((top&nbsp;===&nbsp;<span data-darkreader-inline-color="">"("</span>&nbsp;&amp;&amp;&nbsp;c&nbsp;===&nbsp;<span data-darkreader-inline-color="">")"</span>)&nbsp;||&nbsp;(top&nbsp;===&nbsp;<span data-darkreader-inline-color="">"{"</span>&nbsp;&amp;&amp;&nbsp;c&nbsp;===&nbsp;<span data-darkreader-inline-color="">"}"</span>)&nbsp;||&nbsp;(top&nbsp;===&nbsp;<span data-darkreader-inline-color="">"["</span>&nbsp;&amp;&amp;&nbsp;c&nbsp;===&nbsp;<span data-darkreader-inline-color="">"]"</span>))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.pop();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;否则就不是一个有效的括号</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;stack.length&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>;<br>};<br>
```

## 2\. 队列

和栈相反 `先进先出`的一个数据结构

按照常识理解就是银行排号办理业务, **先去**领号排队的人, **先办理**业务

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

> 同样 js中没有栈的数据类型，但我们可以通过 **Array来模拟一个**

```
<span data-darkreader-inline-color="">const</span>&nbsp;queue&nbsp;=&nbsp;[];<br><br><span data-darkreader-inline-color="">//&nbsp;入队</span><br>queue.push(<span data-darkreader-inline-color="">1</span>);<br>queue.push(<span data-darkreader-inline-color="">2</span>);<br><br><span data-darkreader-inline-color="">//&nbsp;出队</span><br><span data-darkreader-inline-color="">const</span>&nbsp;first&nbsp;=&nbsp;queue.shift();<br><span data-darkreader-inline-color="">const</span>&nbsp;end&nbsp;=&nbsp;queue.shift();<br>
```

### 1）最近的请求次数

```
<span data-darkreader-inline-color="">var</span>&nbsp;RecentCounter&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;()&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;初始化队列</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.q&nbsp;=&nbsp;[];<br>};<br><br><span data-darkreader-inline-color="">//&nbsp;输入&nbsp;inputs&nbsp;=&nbsp;[[],[1],[100],[3001],[3002]]&nbsp;请求间隔为&nbsp;3000ms</span><br><span data-darkreader-inline-color="">//&nbsp;输出&nbsp;outputs&nbsp;=&nbsp;[null,1,2,3,3]&nbsp;&nbsp;&nbsp;</span><br><br><span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(n)&nbsp;n为剔出老请求的长度</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(n)&nbsp;n为最近请求的次数</span><br>RecentCounter.prototype.ping&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">t</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果传入的时间小于等于最近请求的时间，则直接返回0</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!t)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">null</span><br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;将传入的时间放入队列</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.q.push(t);<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果队头小于&nbsp;t&nbsp;-&nbsp;3000&nbsp;则剔除队头</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(<span data-darkreader-inline-color="">this</span>.q[<span data-darkreader-inline-color="">0</span>]&nbsp;&lt;&nbsp;t&nbsp;-&nbsp;<span data-darkreader-inline-color="">3000</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.q.shift();<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;返回最近请求的次数</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">this</span>.q.length;<br>};<br>
```

## 3\. 链表

多个元素组成的列表，元素存储不连续，`通过 next 指针来链接`, 最底层为 null

就类似于 **父辈链接关系** 吧， 比如：你爷爷的儿子是你爸爸，你爸爸的儿子是你，而你假如目前还没有结婚生子，那你就暂时木有儿子

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

> js中类似于链表的典型就是原型链, 但是js中没有链表这种数据结构，我们可以通过一个**object来模拟链表**

```
<span data-darkreader-inline-color="">const</span>&nbsp;a&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">val</span>:&nbsp;<span data-darkreader-inline-color="">"a"</span><br>}<br><br><span data-darkreader-inline-color="">const</span>&nbsp;b&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">val</span>:&nbsp;<span data-darkreader-inline-color="">"b"</span><br>}<br><br><span data-darkreader-inline-color="">const</span>&nbsp;c&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">val</span>:&nbsp;<span data-darkreader-inline-color="">"c"</span><br>}<br><br><span data-darkreader-inline-color="">const</span>&nbsp;d&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">val</span>:&nbsp;<span data-darkreader-inline-color="">"d"</span><br>}<br><br>a.next&nbsp;=&nbsp;b;<br>b.next&nbsp;=&nbsp;c;<br>c.next&nbsp;=&nbsp;d;<br><br><span data-darkreader-inline-color="">//&nbsp;const&nbsp;linkList&nbsp;=&nbsp;{</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;&nbsp;val:&nbsp;"a",</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;&nbsp;next:&nbsp;{</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val:&nbsp;"b",</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next:&nbsp;{</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val:&nbsp;"c",</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next:&nbsp;{</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val:&nbsp;"d",</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next:&nbsp;null</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;&nbsp;}</span><br><span data-darkreader-inline-color="">//&nbsp;}</span><br><br><span data-darkreader-inline-color="">//&nbsp;遍历链表</span><br><span data-darkreader-inline-color="">let</span>&nbsp;p&nbsp;=&nbsp;a;<br><span data-darkreader-inline-color="">while</span>&nbsp;(p)&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(p.val);<br>&nbsp;&nbsp;p&nbsp;=&nbsp;p.next;<br>}<br><br><span data-darkreader-inline-color="">//&nbsp;插入</span><br><span data-darkreader-inline-color="">const</span>&nbsp;e&nbsp;=&nbsp;{&nbsp;<span data-darkreader-inline-color="">val</span>:&nbsp;<span data-darkreader-inline-color="">'e'</span>&nbsp;};<br>c.next&nbsp;=&nbsp;e;<br>e.next&nbsp;=&nbsp;d;<br><br><br><span data-darkreader-inline-color="">//&nbsp;删除</span><br>c.next&nbsp;=&nbsp;d;<br>
```

### 1）手写instanceOf

```
<span data-darkreader-inline-color="">const</span>&nbsp;myInstanceOf&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">A,&nbsp;B</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;声明一个指针</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;p&nbsp;=&nbsp;A;<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;遍历这个链表</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(p)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(p&nbsp;===&nbsp;B.prototype)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">true</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;p.__proto__;<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span><br>}<br><br>myInstanceOf([],&nbsp;<span data-darkreader-inline-color="">Object</span>)<br>
```

### 2）删除链表中的节点

```
<span data-darkreader-inline-color="">//&nbsp;时间复杂和空间复杂度都是&nbsp;O(1)</span><br><span data-darkreader-inline-color="">const</span>&nbsp;deleteNode&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">node</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;把当前链表的指针指向下下个链表的值就可以了</span><br>&nbsp;&nbsp;node.val&nbsp;=&nbsp;node.next.val;<br>&nbsp;&nbsp;node.next&nbsp;=&nbsp;node.next.next<br>}<br>
```

### 3）删除排序链表中的重复元素

```
<span data-darkreader-inline-color="">//&nbsp;1&nbsp;-&gt;&nbsp;1&nbsp;-&gt;&nbsp;2&nbsp;-&gt;&nbsp;3&nbsp;-&gt;&nbsp;3&nbsp;</span><br><span data-darkreader-inline-color="">//&nbsp;1&nbsp;-&gt;&nbsp;2&nbsp;-&gt;&nbsp;3&nbsp;-&gt;&nbsp;null</span><br><br><span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(n)&nbsp;n为链表的长度</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(1)</span><br><span data-darkreader-inline-color="">const</span>&nbsp;deleteDuplicates&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">head</span>)&nbsp;=&gt;</span>&nbsp;{<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;创建一个指针</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;p&nbsp;=&nbsp;head;<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;遍历链表</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(p&nbsp;&amp;&amp;&nbsp;p.next)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果当前节点的值等于下一个节点的值</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(p.val&nbsp;===&nbsp;p.next.val)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;删除下一个节点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.next&nbsp;=&nbsp;p.next.next<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;否则继续遍历</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;p.next<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;&nbsp;最后返回原来链表</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;head<br>}<br>
```

### 4）反转链表

```
<span data-darkreader-inline-color="">//&nbsp;1&nbsp;-&gt;&nbsp;2&nbsp;-&gt;&nbsp;3&nbsp;-&gt;&nbsp;4&nbsp;-&gt;&nbsp;5&nbsp;-&gt;&nbsp;null</span><br><span data-darkreader-inline-color="">//&nbsp;5&nbsp;-&gt;&nbsp;4&nbsp;-&gt;&nbsp;3&nbsp;-&gt;&nbsp;2&nbsp;-&gt;&nbsp;1&nbsp;-&gt;&nbsp;null</span><br><br><span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(n)&nbsp;n为链表的长度</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(1)</span><br><span data-darkreader-inline-color="">var</span>&nbsp;reverseList&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">head</span>)&nbsp;</span>{<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;创建一个指针</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;p1&nbsp;=&nbsp;head;<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;创建一个新指针</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;p2&nbsp;=&nbsp;<span data-darkreader-inline-color="">null</span>;<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;遍历链表</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(p1)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;创建一个临时变量</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;tmp&nbsp;=&nbsp;p1.next;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;将当前节点的下一个节点指向新链表</span><br>&nbsp;&nbsp;&nbsp;&nbsp;p1.next&nbsp;=&nbsp;p2;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;将新链表指向当前节点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;p2&nbsp;=&nbsp;p1;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;将当前节点指向临时变量</span><br>&nbsp;&nbsp;&nbsp;&nbsp;p1&nbsp;=&nbsp;tmp;<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;最后返回新的这个链表</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;p2;<br>}<br><br>reverseList(list<br>
```

## 4\. 集合

一种`无序且唯一`的数据结构

> ES6中有集合 **Set类型**

```
<span data-darkreader-inline-color="">const</span>&nbsp;arr&nbsp;=&nbsp;[<span data-darkreader-inline-color="">1</span>,&nbsp;<span data-darkreader-inline-color="">1</span>,&nbsp;<span data-darkreader-inline-color="">1</span>,&nbsp;<span data-darkreader-inline-color="">2</span>,&nbsp;<span data-darkreader-inline-color="">2</span>,&nbsp;<span data-darkreader-inline-color="">3</span>];<br><br><span data-darkreader-inline-color="">//&nbsp;去重</span><br><span data-darkreader-inline-color="">const</span>&nbsp;arr2&nbsp;=&nbsp;[...new&nbsp;<span data-darkreader-inline-color="">Set</span>(arr)];<br><br><span data-darkreader-inline-color="">//&nbsp;判断元素是否在集合中</span><br><span data-darkreader-inline-color="">const</span>&nbsp;<span data-darkreader-inline-color="">set</span>&nbsp;=&nbsp;new&nbsp;Set(arr);<br><span data-darkreader-inline-color="">set</span>.has(2)&nbsp;//&nbsp;true<br><br>//&nbsp;&nbsp;交集<br>const&nbsp;set2&nbsp;=&nbsp;new&nbsp;Set([1,&nbsp;2]);<br>const&nbsp;set3&nbsp;=&nbsp;new&nbsp;Set([...<span data-darkreader-inline-color="">set</span>].filter(item&nbsp;=&gt;&nbsp;<span data-darkreader-inline-color="">set</span>.has(item)));<br>
```

### 1）去重

具体代码在上面介绍中有写过，就不再重写了

### 2）两个数组的交集

```
<span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(n^2)&nbsp;n为数组长度</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(n)&nbsp;&nbsp;n为去重后的数组长度</span><br><span data-darkreader-inline-color="">const</span>&nbsp;intersection&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">nums1,&nbsp;nums2</span>)&nbsp;=&gt;</span>&nbsp;{<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;通过数组的filter选出交集</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;然后通过&nbsp;Set集合&nbsp;去重&nbsp;并生成数组</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;[...new&nbsp;<span data-darkreader-inline-color="">Set</span>(nums1.filter(<span><span data-darkreader-inline-color="">item</span>&nbsp;=&gt;</span>&nbsp;nums2.includes(item)))];<br>}<br>
```

## 5\. 字典

与集合类似，`一个存储唯一值`的结构,以`键值对`的形式存储

> js中有字典数据结构 就是 **Map 类型**

### 1）两数之和

```
<span data-darkreader-inline-color="">//&nbsp;nums&nbsp;=&nbsp;[2,&nbsp;7,&nbsp;11,&nbsp;15]&nbsp;target&nbsp;=&nbsp;9</span><br><br><span data-darkreader-inline-color="">//&nbsp;时间复杂度O(n)&nbsp;n为nums的length</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度O(n)</span><br><span data-darkreader-inline-color="">var</span>&nbsp;twoSum&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">nums,&nbsp;target</span>)&nbsp;</span>{<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;建立一个字典数据结构来保存需要的值</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;map&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Map</span>();<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;nums.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;获取当前的值，和需要的值</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;n&nbsp;=&nbsp;nums[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;n2&nbsp;=&nbsp;target&nbsp;-&nbsp;n;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如字典中有需要的值，就匹配成功</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(map.has(n2))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;[map.get(n2),&nbsp;i];<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如没有，则把需要的值添加到字典中</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.set(n,&nbsp;i);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>};<br>
```

### 2）两个数组的交集

```
<span data-darkreader-inline-color="">//&nbsp;nums1&nbsp;=&nbsp;[1,2,2,1],&nbsp;nums2&nbsp;=&nbsp;[2,2]</span><br><span data-darkreader-inline-color="">//&nbsp;输出：[2]</span><br><br><span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(m&nbsp;+&nbsp;n)&nbsp;m为nums1长度&nbsp;n为nums2长度</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(m)&nbsp;m为交集的数组长度</span><br><span data-darkreader-inline-color="">const</span>&nbsp;intersection&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">nums1,&nbsp;nums2</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;创建一个字典</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;map&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Map</span>();<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;将数组1中的数字放入字典</span><br>&nbsp;&nbsp;nums1.forEach(<span><span data-darkreader-inline-color="">n</span>&nbsp;=&gt;</span>&nbsp;map.set(n,&nbsp;<span data-darkreader-inline-color="">true</span>));<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;创建一个新数组</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;res&nbsp;=&nbsp;[];<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;将数组2遍历&nbsp;并判断是否在字典中</span><br>&nbsp;&nbsp;nums2.forEach(<span><span data-darkreader-inline-color="">n</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(map.has(n))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.push(n);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果在字典中，则删除该数字</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.delete(n);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;})<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;res;<br>};<br>
```

### 3）字符的有效的括号

```
<span data-darkreader-inline-color="">//&nbsp;用字典优化</span><br><br><span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(n)&nbsp;n为s的字符长度</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(n)&nbsp;</span><br><span data-darkreader-inline-color="">const</span>&nbsp;isValid&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">s</span>)&nbsp;=&gt;</span>&nbsp;{<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果长度不等于2的倍数肯定不是一个有效的括号</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(s.length&nbsp;%&nbsp;<span data-darkreader-inline-color="">2</span>&nbsp;!==&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span><br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;创建一个字典</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;map&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Map</span>();<br>&nbsp;&nbsp;map.set(<span data-darkreader-inline-color="">'('</span>,&nbsp;<span data-darkreader-inline-color="">')'</span>);<br>&nbsp;&nbsp;map.set(<span data-darkreader-inline-color="">'{'</span>,&nbsp;<span data-darkreader-inline-color="">'}'</span>);<br>&nbsp;&nbsp;map.set(<span data-darkreader-inline-color="">'['</span>,&nbsp;<span data-darkreader-inline-color="">']'</span>);<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;创建一个栈</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;stack&nbsp;=&nbsp;[];<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;遍历字符串</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;s.length;&nbsp;i++)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;取出字符</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;c&nbsp;=&nbsp;s[i];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果是左括号就入栈</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(map.has(c))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.push(c)<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;取出栈顶</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;t&nbsp;=&nbsp;stack[stack.length&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果字典中有这个值&nbsp;就出栈</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(map.get(t)&nbsp;===&nbsp;c)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.pop();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;否则就不是一个有效的括号</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;stack.length&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>;<br>};<br>
```

### 4）最小覆盖字串

```
<span data-darkreader-inline-color="">//&nbsp;输入：s =&nbsp;"ADOBECODEBANC", t =&nbsp;"ABC"</span><br><span data-darkreader-inline-color="">//&nbsp;输出："BANC"</span><br><br><br><span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(m&nbsp;+&nbsp;n)&nbsp;m是t的长度&nbsp;n是s的长度</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(k)&nbsp;k是字符串中不重复字符的个数</span><br><span data-darkreader-inline-color="">var</span>&nbsp;minWindow&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">s,&nbsp;t</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;定义双指针维护一个滑动窗口</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;l&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;r&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;建立一个字典</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;need&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Map</span>();<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;&nbsp;遍历t</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">const</span>&nbsp;c&nbsp;<span data-darkreader-inline-color="">of</span>&nbsp;t)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;need.set(c,&nbsp;need.has(c)&nbsp;?&nbsp;need.get(c)&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>&nbsp;:&nbsp;<span data-darkreader-inline-color="">1</span>)<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;needType&nbsp;=&nbsp;need.size<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;记录最小子串</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;res&nbsp;=&nbsp;<span data-darkreader-inline-color="">""</span><br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;移动右指针</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(r&nbsp;&lt;&nbsp;s.length)&nbsp;{<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;获取当前字符</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;c&nbsp;=&nbsp;s[r];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果字典里有这个字符</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(need.has(c))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;减少字典里面的次数</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;need.set(c,&nbsp;need.get(c)&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;减少需要的值</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(need.get(c)&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;needType&nbsp;-=&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果字典中所有的值都为0了&nbsp;就说明找到了一个最小子串</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(needType&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;取出当前符合要求的子串</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;newRes&nbsp;=&nbsp;s.substring(l,&nbsp;r&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果当前子串是小于上次的子串就进行覆盖</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!res&nbsp;||&nbsp;newRes.length&nbsp;&lt;&nbsp;res.length)&nbsp;res&nbsp;=&nbsp;newRes;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;获取左指针的字符</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;c2&nbsp;=&nbsp;s[l];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果字典里有这个字符</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(need.has(c2))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;增加字典里面的次数</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;need.set(c2,&nbsp;need.get(c2)&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;增加需要的值</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(need.get(c2)&nbsp;===&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;needType&nbsp;+=&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l&nbsp;+=&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;+=&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;res<br>};<br>
```

## 6\. 树

一种`分层数据的抽象模型`， 比如DOM树、树形控件等

> js中没有树 但是可以用 **Object 和 Array 构建树**

### 1）普通树

```
<span data-darkreader-inline-color="">//&nbsp;这就是一个常见的普通树形结构</span><br><span data-darkreader-inline-color="">const</span>&nbsp;tree&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">val</span>:&nbsp;<span data-darkreader-inline-color="">"a"</span>,<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">children</span>:&nbsp;[<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">val</span>:&nbsp;<span data-darkreader-inline-color="">"b"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">children</span>:&nbsp;[<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">val</span>:&nbsp;<span data-darkreader-inline-color="">"d"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">children</span>:&nbsp;[],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">val</span>:&nbsp;<span data-darkreader-inline-color="">"e"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">children</span>:&nbsp;[],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">val</span>:&nbsp;<span data-darkreader-inline-color="">"c"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">children</span>:&nbsp;[<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">val</span>:&nbsp;<span data-darkreader-inline-color="">"f"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">children</span>:&nbsp;[],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">val</span>:&nbsp;<span data-darkreader-inline-color="">"g"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">children</span>:&nbsp;[],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;],<br>}<br>
```

#### \> 深度优先遍历

-   尽可能深的搜索树的分支,就比如遇到一个节点就会**直接去遍历他的子节点**，**不会立刻去遍历他的兄弟节点**
    
-   口诀：
    
-   访问根节点
    
-   对根节点的 children 挨个进行深度优先遍历
    

```
<span data-darkreader-inline-color="">//&nbsp;深度优先遍历</span><br><span data-darkreader-inline-color="">const</span>&nbsp;dfs&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">tree</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;tree.children.forEach(dfs)<br>};<br>
```

#### \> 广度优先遍历

-   先访问离根节点最近的节点, 如果有兄弟节点就会**先遍历兄弟节点**，**再去遍历自己的子节点**
    
-   口诀
    
-   新建一个队列 并把根节点入队
    
-   把队头出队并访问
    
-   把队头的children挨个入队
    
-   重复第二 、三步 直到队列为空
    

```
<span data-darkreader-inline-color="">//&nbsp;广度优先遍历</span><br><span data-darkreader-inline-color="">const</span>&nbsp;bfs&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">tree</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;q&nbsp;=&nbsp;[tree];<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(q.length&nbsp;&gt;&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;n&nbsp;=&nbsp;q.shift()<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(n.val);<br>&nbsp;&nbsp;&nbsp;&nbsp;n.children.forEach(<span><span data-darkreader-inline-color="">c</span>&nbsp;=&gt;</span>&nbsp;q.push(c))<br>&nbsp;&nbsp;}<br>};<br>
```

### 2）二叉树

树中每个节点 **最多只能有两个子节点**

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

  

```
&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;bt&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">val</span>:&nbsp;<span data-darkreader-inline-color="">1</span>,<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">left</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">val</span>:&nbsp;<span data-darkreader-inline-color="">2</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">left</span>:&nbsp;<span data-darkreader-inline-color="">null</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">right</span>:&nbsp;<span data-darkreader-inline-color="">null</span><br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">right</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">val</span>:&nbsp;<span data-darkreader-inline-color="">3</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">left</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">val</span>:&nbsp;<span data-darkreader-inline-color="">4</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">left</span>:&nbsp;<span data-darkreader-inline-color="">null</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">right</span>:&nbsp;<span data-darkreader-inline-color="">null</span><br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">right</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">val</span>:&nbsp;<span data-darkreader-inline-color="">5</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">left</span>:&nbsp;<span data-darkreader-inline-color="">null</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">right</span>:&nbsp;<span data-darkreader-inline-color="">null</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>}<br>
```

#### \> 二叉树的先序遍历

-   访问根节点
    
-   对根节点的左子树进行先序遍历
    
-   对根节点的右子树进行先序遍历
    

```
<span data-darkreader-inline-color="">//&nbsp;先序遍历&nbsp;递归</span><br><span data-darkreader-inline-color="">const</span>&nbsp;preOrder&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">tree</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!tree)&nbsp;<span data-darkreader-inline-color="">return</span><br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(tree.val);<br><br>&nbsp;&nbsp;preOrder(tree.left);<br>&nbsp;&nbsp;preOrder(tree.right);<br>}<br><br><br><br><span data-darkreader-inline-color="">//&nbsp;先序遍历&nbsp;非递归</span><br><span data-darkreader-inline-color="">const</span>&nbsp;preOrder2&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">tree</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!tree)&nbsp;<span data-darkreader-inline-color="">return</span><br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;新建一个栈</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;stack&nbsp;=&nbsp;[tree];<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(stack.length&nbsp;&gt;&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;n&nbsp;=&nbsp;stack.pop();<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(n.val);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;负负为正</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(n.right)&nbsp;stack.push(n.right);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(n.left)&nbsp;stack.push(n.left);<br><br>&nbsp;&nbsp;}<br>}<br>
```

#### \> 二叉树的中序遍历

-   对根节点的左子树进行中序遍历
    
-   访问根节点
    
-   对根节点的右子树进行中序遍历
    

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

  

```
<span data-darkreader-inline-color="">//&nbsp;中序遍历&nbsp;递归</span><br><span data-darkreader-inline-color="">const</span>&nbsp;inOrder&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">tree</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!tree)&nbsp;<span data-darkreader-inline-color="">return</span>;<br>&nbsp;&nbsp;inOrder(tree.left)<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(tree.val);<br>&nbsp;&nbsp;inOrder(tree.right)<br>}<br><br><br><span data-darkreader-inline-color="">//&nbsp;中序遍历&nbsp;非递归</span><br><span data-darkreader-inline-color="">const</span>&nbsp;inOrder2&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">tree</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!tree)&nbsp;<span data-darkreader-inline-color="">return</span>;<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;新建一个栈</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;stack&nbsp;=&nbsp;[];<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;先遍历所有的左节点</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;p&nbsp;=&nbsp;tree;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(stack.length&nbsp;||&nbsp;p)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(p)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.push(p)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;p.left<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;n&nbsp;=&nbsp;stack.pop();<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(n.val);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;n.right;<br>&nbsp;&nbsp;}<br>}<br>
```

#### \> 二叉树的后序遍历

-   对根节点的左子树进行后序遍历
    
-   对根节点的右子树进行后序遍历
    
-   访问根节点
    

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

  

```
<span data-darkreader-inline-color="">//&nbsp;后序遍历&nbsp;递归</span><br><span data-darkreader-inline-color="">const</span>&nbsp;postOrder&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">tree</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!tree)&nbsp;<span data-darkreader-inline-color="">return</span><br><br>&nbsp;&nbsp;postOrder(tree.left)<br>&nbsp;&nbsp;postOrder(tree.right)<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(tree.val)<br>};<br><br><br><br><span data-darkreader-inline-color="">//&nbsp;后序遍历&nbsp;非递归</span><br><span data-darkreader-inline-color="">const</span>&nbsp;postOrder2&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">tree</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!tree)&nbsp;<span data-darkreader-inline-color="">return</span><br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;stack&nbsp;=&nbsp;[tree];<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;outputStack&nbsp;=&nbsp;[];<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(stack.length)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;n&nbsp;=&nbsp;stack.pop();<br>&nbsp;&nbsp;&nbsp;&nbsp;outputStack.push(n)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;负负为正</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(n.left)&nbsp;stack.push(n.left);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(n.right)&nbsp;stack.push(n.right);<br><br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(outputStack.length)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;n&nbsp;=&nbsp;outputStack.pop();<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(n.val);<br>&nbsp;&nbsp;}<br>};<br>
```

#### \> 二叉树的最大深度

```
<span data-darkreader-inline-color="">//&nbsp;给一个二叉树，需要你找出其最大的深度，从根节点到叶子节点的距离</span><br><br><span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(n)&nbsp;n为树的节点数</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;有一个递归调用的栈&nbsp;所以为&nbsp;O(n)&nbsp;n也是为二叉树的最大深度</span><br><span data-darkreader-inline-color="">var</span>&nbsp;maxDepth&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">root</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;res&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;使用深度优先遍历</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;dfs&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">n,&nbsp;l</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!n)&nbsp;<span data-darkreader-inline-color="">return</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!n.left&nbsp;&amp;&amp;&nbsp;!n.right)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;没有叶子节点就把深度数量更新</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;=&nbsp;<span data-darkreader-inline-color="">Math</span>.max(res,&nbsp;l);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;dfs(n.left,&nbsp;l&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;dfs(n.right,&nbsp;l&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>)<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;dfs(root,&nbsp;<span data-darkreader-inline-color="">1</span>)<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;res<br>}<br>
```

#### \> 二叉树的最小深度

```
<span data-darkreader-inline-color="">//&nbsp;给一个二叉树，需要你找出其最小的深度，&nbsp;从根节点到叶子节点的距离</span><br><br><br><span data-darkreader-inline-color="">//&nbsp;时间复杂度O(n)&nbsp;n是树的节点数量</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度O(n)&nbsp;n是树的节点数量</span><br><span data-darkreader-inline-color="">var</span>&nbsp;minDepth&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">root</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!root)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">0</span><br>&nbsp;&nbsp;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;使用广度优先遍历</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;q&nbsp;=&nbsp;[[root,&nbsp;<span data-darkreader-inline-color="">1</span>]];<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(q.length)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;取出当前节点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;[n,&nbsp;l]&nbsp;=&nbsp;q.shift();<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果是叶子节点直接返回深度就可</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!n.left&nbsp;&amp;&amp;&nbsp;!n.right)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;l<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(n.left)&nbsp;q.push([n.left,&nbsp;l&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>]);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(n.right)&nbsp;q.push([n.right,&nbsp;l&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>]);<br>&nbsp;&nbsp;}<br><br>}<br>
```

#### \> 二叉树的层序遍历

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

  

```
<span data-darkreader-inline-color="">//&nbsp;需要返回&nbsp;[[1],&nbsp;[2,3],&nbsp;[4,5]]</span><br><br><br><span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(n)&nbsp;n为树的节点数</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(n)&nbsp;</span><br><span data-darkreader-inline-color="">var</span>&nbsp;levelOrder&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">root</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!root)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;[]<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;广度优先遍历</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;q&nbsp;=&nbsp;[root];<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;res&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(q.length)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;len&nbsp;=&nbsp;q.length<br><br>&nbsp;&nbsp;&nbsp;&nbsp;res.push([])<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;循环每层的节点数量次</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(len--)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;n&nbsp;=&nbsp;q.shift();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res[res.length&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>].push(n.val)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(n.left)&nbsp;q.push(n.left);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(n.right)&nbsp;q.push(n.right);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;res<br>};<br>
```

## 7\. 图

图是`网络结构的抽象模型`, 是一组由边连接的节点

> js中可以利用**Object和Array构建图**

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

```
<span data-darkreader-inline-color="">//&nbsp;上图可以表示为</span><br><span data-darkreader-inline-color="">const</span>&nbsp;graph&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">0</span>:&nbsp;[<span data-darkreader-inline-color="">1</span>,&nbsp;<span data-darkreader-inline-color="">2</span>],<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">1</span>:&nbsp;[<span data-darkreader-inline-color="">2</span>],<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">2</span>:&nbsp;[<span data-darkreader-inline-color="">0</span>,&nbsp;<span data-darkreader-inline-color="">3</span>],<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">3</span>:&nbsp;[<span data-darkreader-inline-color="">3</span>]<br>}<br><br><br><span data-darkreader-inline-color="">//&nbsp;深度优先遍历，对根节点没访问过的相邻节点挨个进行遍历</span><br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;记录节点是否访问过</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;visited&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Set</span>();<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;dfs&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">n</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visited.add(n);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;遍历相邻节点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;graph[n].forEach(<span><span data-darkreader-inline-color="">c</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;没访问过才可以，进行递归访问</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>(!visited.has(c)){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dfs(c)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;从2开始进行遍历</span><br>&nbsp;&nbsp;&nbsp;&nbsp;dfs(<span data-darkreader-inline-color="">2</span>)<br>}<br><br><br><span data-darkreader-inline-color="">//&nbsp;广度优先遍历&nbsp;</span><br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;visited&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Set</span>();<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;新建一个队列，&nbsp;根节点入队，&nbsp;设2为根节点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;q&nbsp;=&nbsp;[<span data-darkreader-inline-color="">2</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;visited.add(<span data-darkreader-inline-color="">2</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(q.length)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;队头出队，并访问</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;n&nbsp;=&nbsp;q.shift();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(n);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;graph[n].forEach(<span><span data-darkreader-inline-color="">c</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;对没访问过的相邻节点入队</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!visited.has(c))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.push(c)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visited.add(c)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br>
```

### 1）有效数字

```
<span data-darkreader-inline-color="">//&nbsp;生成数字关系图&nbsp;只有状态为&nbsp;3&nbsp;5&nbsp;6&nbsp;的时候才为一个数字</span><br><span data-darkreader-inline-color="">const</span>&nbsp;graph&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">0</span>:&nbsp;{&nbsp;<span data-darkreader-inline-color="">'blank'</span>:&nbsp;<span data-darkreader-inline-color="">0</span>,&nbsp;<span data-darkreader-inline-color="">'sign'</span>:&nbsp;<span data-darkreader-inline-color="">1</span>,&nbsp;<span data-darkreader-inline-color="">"."</span>:&nbsp;<span data-darkreader-inline-color="">2</span>,&nbsp;<span data-darkreader-inline-color="">"digit"</span>:&nbsp;<span data-darkreader-inline-color="">6</span>&nbsp;},<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">1</span>:&nbsp;{&nbsp;<span data-darkreader-inline-color="">"digit"</span>:&nbsp;<span data-darkreader-inline-color="">6</span>,&nbsp;<span data-darkreader-inline-color="">"."</span>:&nbsp;<span data-darkreader-inline-color="">2</span>&nbsp;},<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">2</span>:&nbsp;{&nbsp;<span data-darkreader-inline-color="">"digit"</span>:&nbsp;<span data-darkreader-inline-color="">3</span>&nbsp;},<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">3</span>:&nbsp;{&nbsp;<span data-darkreader-inline-color="">"digit"</span>:&nbsp;<span data-darkreader-inline-color="">3</span>,&nbsp;<span data-darkreader-inline-color="">"e"</span>:&nbsp;<span data-darkreader-inline-color="">4</span>&nbsp;},<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">4</span>:&nbsp;{&nbsp;<span data-darkreader-inline-color="">"digit"</span>:&nbsp;<span data-darkreader-inline-color="">5</span>,&nbsp;<span data-darkreader-inline-color="">"sign"</span>:&nbsp;<span data-darkreader-inline-color="">7</span>&nbsp;},<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">5</span>:&nbsp;{&nbsp;<span data-darkreader-inline-color="">"digit"</span>:&nbsp;<span data-darkreader-inline-color="">5</span>&nbsp;},<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">6</span>:&nbsp;{&nbsp;<span data-darkreader-inline-color="">"digit"</span>:&nbsp;<span data-darkreader-inline-color="">6</span>,&nbsp;<span data-darkreader-inline-color="">"."</span>:&nbsp;<span data-darkreader-inline-color="">3</span>,&nbsp;<span data-darkreader-inline-color="">"e"</span>:&nbsp;<span data-darkreader-inline-color="">4</span>&nbsp;},<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">7</span>:&nbsp;{&nbsp;<span data-darkreader-inline-color="">"digit"</span>:&nbsp;<span data-darkreader-inline-color="">5</span>&nbsp;},<br>}<br><br><br><span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(n)&nbsp;n是字符串长度</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(1)&nbsp;</span><br><span data-darkreader-inline-color="">var</span>&nbsp;isNumber&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">s</span>)&nbsp;</span>{<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;记录状态</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;state&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;遍历字符串</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(c&nbsp;<span data-darkreader-inline-color="">of</span>&nbsp;s.trim())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;把字符进行转换</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(c&nbsp;&gt;=&nbsp;<span data-darkreader-inline-color="">'0'</span>&nbsp;&amp;&amp;&nbsp;c&nbsp;&lt;=&nbsp;<span data-darkreader-inline-color="">'9'</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;<span data-darkreader-inline-color="">'digit'</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(c&nbsp;===&nbsp;<span data-darkreader-inline-color="">"&nbsp;"</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;<span data-darkreader-inline-color="">'blank'</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(c&nbsp;===&nbsp;<span data-darkreader-inline-color="">"+"</span>&nbsp;||&nbsp;c&nbsp;===&nbsp;<span data-darkreader-inline-color="">"-"</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;<span data-darkreader-inline-color="">"sign"</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(c&nbsp;===&nbsp;<span data-darkreader-inline-color="">"E"</span>&nbsp;||&nbsp;c&nbsp;===&nbsp;<span data-darkreader-inline-color="">"e"</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;<span data-darkreader-inline-color="">"e"</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;开始寻找图</span><br>&nbsp;&nbsp;&nbsp;&nbsp;state&nbsp;=&nbsp;graph[state][c];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果最后是undefined就是错误</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(state&nbsp;===&nbsp;<span data-darkreader-inline-color="">undefined</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span><br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;判断最后的结果是不是合法的数字</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(state&nbsp;===&nbsp;<span data-darkreader-inline-color="">3</span>&nbsp;||&nbsp;state&nbsp;===&nbsp;<span data-darkreader-inline-color="">5</span>&nbsp;||&nbsp;state&nbsp;===&nbsp;<span data-darkreader-inline-color="">6</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">true</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span><br>};&nbsp;<br>
```

## 8\. 堆

一种`特殊的完全二叉树`, 所有的节点都大于等于最大堆,或者小于等于最小堆的子节点

> js通常使用**数组来表示堆**

-   左侧子节点的位置是 **2\*index + 1**
    
-   右侧子节点的位置是 **2\*index + 2**
    
-   父节点的位置是 **(index - 1) / 2** , 取余数
    

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

### 2）JS实现一个最小堆

```
<span data-darkreader-inline-color="">//&nbsp;js实现最小堆类</span><br><span><span data-darkreader-inline-color="">class</span>&nbsp;<span data-darkreader-inline-color="">MinHeap</span>&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">constructor</span>()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;元素容器</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.heap&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;交换节点的值</span><br>&nbsp;&nbsp;swap(i1,&nbsp;i2)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;[<span data-darkreader-inline-color="">this</span>.heap[i1],&nbsp;<span data-darkreader-inline-color="">this</span>.heap[i2]]&nbsp;=&nbsp;[<span data-darkreader-inline-color="">this</span>.heap[i2],&nbsp;<span data-darkreader-inline-color="">this</span>.heap[i1]]<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;&nbsp;获取父节点</span><br>&nbsp;&nbsp;getParentIndex(index)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;除以二，&nbsp;取余数</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;(index&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;&gt;&gt;&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;获取左侧节点索引</span><br>&nbsp;&nbsp;getLeftIndex(i)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;(i&nbsp;&lt;&lt;&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;获取右侧节点索引</span><br>&nbsp;&nbsp;getRightIndex(i)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;(i&nbsp;&lt;&lt;&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;+&nbsp;<span data-darkreader-inline-color="">2</span>;<br>&nbsp;&nbsp;}<br><br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;上移</span><br>&nbsp;&nbsp;shiftUp(index)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(index&nbsp;==&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;<span data-darkreader-inline-color="">return</span>;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;获取父节点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;parentIndex&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span>.getParentIndex(index);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果父节点的值大于当前节点的值&nbsp;就需要进行交换</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">this</span>.heap[parentIndex]&nbsp;&gt;&nbsp;<span data-darkreader-inline-color="">this</span>.heap[index])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.swap(parentIndex,&nbsp;index);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;然后继续上移</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.shiftUp(parentIndex);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;下移</span><br>&nbsp;&nbsp;shiftDown(index)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;获取左右节点索引</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;leftIndex&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span>.getLeftIndex(index);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;rightIndex&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span>.getRightIndex(index);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果左子节点小于当前的值</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">this</span>.heap[leftIndex]&nbsp;&lt;&nbsp;<span data-darkreader-inline-color="">this</span>.heap[index])&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;进行节点交换</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.swap(leftIndex,&nbsp;index);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;继续进行下移</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.shiftDown(leftIndex)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果右侧节点小于当前的值</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">this</span>.heap[rightIndex]&nbsp;&lt;&nbsp;<span data-darkreader-inline-color="">this</span>.heap[index])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.swap(rightIndex,&nbsp;index);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.shiftDown(rightIndex)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;插入元素</span><br>&nbsp;&nbsp;insert(value)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;插入到堆的底部</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.heap.push(value);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;然后上移：&nbsp;将这个值和它的父节点进行交换，知道父节点小于等于这个插入的值</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.shiftUp(<span data-darkreader-inline-color="">this</span>.heap.length&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>)<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;删除堆项</span><br>&nbsp;&nbsp;pop()&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;把数组最后一位&nbsp;转移到数组头部</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.heap[<span data-darkreader-inline-color="">0</span>]&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span>.heap.pop();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;进行下移操作</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.shiftDown(<span data-darkreader-inline-color="">0</span>);<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;获取堆顶元素</span><br>&nbsp;&nbsp;peek()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">this</span>.heap[<span data-darkreader-inline-color="">0</span>]<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;获取堆大小</span><br>&nbsp;&nbsp;size()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">this</span>.heap.length<br>&nbsp;&nbsp;}<br><br>}<br>
```

### 2）数组中的第k个最大元素

```
<span data-darkreader-inline-color="">//&nbsp;输入&nbsp;[3,2,1,5,6,4]&nbsp;和&nbsp;k&nbsp;=&nbsp;2</span><br><span data-darkreader-inline-color="">//&nbsp;输出&nbsp;5</span><br><br><span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(n&nbsp;*&nbsp;logK)&nbsp;K就是堆的大小</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(K)&nbsp;K是参数k</span><br><span data-darkreader-inline-color="">var</span>&nbsp;findKthLargest&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">nums,&nbsp;k</span>)&nbsp;</span>{<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;使用上面js实现的最小堆类，来构建一个最小堆</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;h&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;MinHeap();<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;遍历数组</span><br>&nbsp;&nbsp;nums.forEach(<span><span data-darkreader-inline-color="">n</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;把数组中的值依次插入到堆里</span><br>&nbsp;&nbsp;&nbsp;&nbsp;h.insert(n);<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(h.size()&nbsp;&gt;&nbsp;k)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;进行优胜劣汰</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.pop();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;})<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;h.peek()<br>};<br>
```

### 3）前 K 个高频元素

```
<span data-darkreader-inline-color="">//&nbsp;nums&nbsp;=&nbsp;[1,1,1,2,2,3],&nbsp;k&nbsp;=&nbsp;2</span><br><span data-darkreader-inline-color="">//&nbsp;输出:&nbsp;[1,2]</span><br><br><br><span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(n&nbsp;*&nbsp;logK)&nbsp;</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(k)</span><br><span data-darkreader-inline-color="">var</span>&nbsp;topKFrequent&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">nums,&nbsp;k</span>)&nbsp;</span>{<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;统计每个元素出现的频率</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;map&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Map</span>();<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;遍历数组&nbsp;建立映射关系</span><br>&nbsp;&nbsp;nums.forEach(<span><span data-darkreader-inline-color="">n</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;map.set(n,&nbsp;map.has(n)&nbsp;?&nbsp;map.get(n)&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>&nbsp;:&nbsp;<span data-darkreader-inline-color="">1</span>);<br>&nbsp;&nbsp;})<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;建立最小堆</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;h&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;MinHeap();<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;遍历映射关系</span><br>&nbsp;&nbsp;map.forEach(<span>(<span data-darkreader-inline-color="">value,&nbsp;key</span>)&nbsp;=&gt;</span>&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;由于插入的元素结构发生了变化，所以需要对&nbsp;最小堆的类&nbsp;进行改造一下,改造的方法我会写到最后</span><br>&nbsp;&nbsp;&nbsp;&nbsp;h.insert({&nbsp;value,&nbsp;key&nbsp;})<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(h.size()&nbsp;&gt;&nbsp;k)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.pop()<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;})<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;h.heap.map(<span><span data-darkreader-inline-color="">item</span>&nbsp;=&gt;</span>&nbsp;item.key)<br>};<br><br><span data-darkreader-inline-color="">//&nbsp;改造上移和下移操作即可</span><br><span data-darkreader-inline-color="">//&nbsp;shiftUp(index)&nbsp;{</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;if&nbsp;(index&nbsp;==&nbsp;0)&nbsp;return;</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;const&nbsp;parentIndex&nbsp;=&nbsp;this.getParentIndex(index);</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;if&nbsp;(this.heap[parentIndex]&nbsp;&amp;&amp;&nbsp;this.heap[parentIndex].value&nbsp;&gt;&nbsp;this.heap[index].value)&nbsp;{</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.swap(parentIndex,&nbsp;index);</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.shiftUp(parentIndex);</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;}</span><br><span data-darkreader-inline-color="">//&nbsp;}</span><br><span data-darkreader-inline-color="">//&nbsp;shiftDown(index)&nbsp;{</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;const&nbsp;leftIndex&nbsp;=&nbsp;this.getLeftIndex(index);</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;const&nbsp;rightIndex&nbsp;=&nbsp;this.getRightIndex(index);</span><br><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;if&nbsp;(this.heap[leftIndex]&nbsp;&amp;&amp;&nbsp;this.heap[leftIndex].value&nbsp;&lt;&nbsp;this.heap[index].value)&nbsp;{</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.swap(leftIndex,&nbsp;index);</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.shiftDown(leftIndex)</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;}</span><br><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;if&nbsp;(this.heap[rightIndex]&nbsp;&amp;&amp;&nbsp;this.heap[rightIndex].value&nbsp;&lt;&nbsp;this.heap[index].value)&nbsp;{</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.swap(rightIndex,&nbsp;index);</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.shiftDown(rightIndex)</span><br><span data-darkreader-inline-color="">//&nbsp;&nbsp;&nbsp;}</span><br><span data-darkreader-inline-color="">//&nbsp;}</span><br>
```

## **四、常见算法及算法思想**

## 1\. 排序

`把某个乱序的数组变成升序序或者降序的数组`， js比较常用**sort方法进行排序**

### 1）冒泡排序

-   比较所有相邻元素，如果第一个比第二个大就**交换他们**
    
-   执行一次后可以保证最后一个数字是最大的
    
-   重复执行 n-1 次，就可以完成排序
    

```
<span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(n&nbsp;^&nbsp;2)&nbsp;n为数组长度</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(1)</span><br><span data-darkreader-inline-color="">Array</span>.prototype.bubbleSort&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;()&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;<span data-darkreader-inline-color="">this</span>.length&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;j&nbsp;&lt;&nbsp;<span data-darkreader-inline-color="">this</span>.length&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>&nbsp;-&nbsp;i;&nbsp;j++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">this</span>[j]&nbsp;&gt;&nbsp;<span data-darkreader-inline-color="">this</span>[j&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;交换数据</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span data-darkreader-inline-color="">this</span>[j],&nbsp;<span data-darkreader-inline-color="">this</span>[j&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>]]&nbsp;=&nbsp;[<span data-darkreader-inline-color="">this</span>[j&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>],&nbsp;<span data-darkreader-inline-color="">this</span>[j]];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>}<br>
```

### 2）选择排序

-   找到数组中**最小的值**,选中它并放到第一位
    
-   接着找到数组中**第二小的值**,选中它并放到第二位
    
-   重复上述步骤执行 n-1 次
    

```
<span data-darkreader-inline-color="">//&nbsp;时间复杂度：O(n ^ 2) n为数组长度</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度：O(1)</span><br><span data-darkreader-inline-color="">Array</span>.prototype.selectionSort&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;()&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;&nbsp;<span data-darkreader-inline-color="">this</span>.length&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;indexMin&nbsp;=&nbsp;i;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;i;&nbsp;j&nbsp;&lt;&nbsp;<span data-darkreader-inline-color="">this</span>.length;&nbsp;j++)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果当前这个元素&nbsp;小于最小值的下标&nbsp;就更新最小值的下标</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">this</span>[j]&nbsp;&lt;&nbsp;<span data-darkreader-inline-color="">this</span>[indexMin])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indexMin&nbsp;=&nbsp;j;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;避免自己和自己进行交换</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(indexMin&nbsp;!==&nbsp;i)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;进行交换数据</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span data-darkreader-inline-color="">this</span>[i],&nbsp;<span data-darkreader-inline-color="">this</span>[indexMin]]&nbsp;=&nbsp;[<span data-darkreader-inline-color="">this</span>[indexMin],&nbsp;<span data-darkreader-inline-color="">this</span>[i]];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>}<br>
```

### 3）插入排序

-   从第二个数，**开始往前比较**
    
-   如**它大就往后排**
    
-   以此类推进行到最后一个数
    

```
<span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(n&nbsp;^&nbsp;2)</span><br><span data-darkreader-inline-color="">Array</span>.prototype.insertionSort&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;()&nbsp;</span>{<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;遍历数组&nbsp;从第二个开始</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;i&nbsp;&lt;&nbsp;<span data-darkreader-inline-color="">this</span>.length;&nbsp;i++)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;获取第二个元素</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;temp&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span>[i];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;j&nbsp;=&nbsp;i;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(j&nbsp;&gt;&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果当前元素小于前一个元素&nbsp;就开始往后移动</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<span data-darkreader-inline-color="">this</span>[j&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>]&nbsp;&gt;&nbsp;temp)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>[j]&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span>[j&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;否则就跳出循环</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">break</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;递减</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j--;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;前一位置赋值为当前元素</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>[j]&nbsp;=&nbsp;temp;<br>&nbsp;&nbsp;}<br>}<br>
```

### 4）归并排序

-   分：把数组**劈成两半** 在递归的对子数组进行分操作，直到分成一个个**单独的数**
    
-   合：把两个树**合并为有序数组**，再对有序数组进行合并， 直到全部子数组合并为一个完整的数组
    

```
<span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(nlogn)&nbsp;分需要劈开数组，所以是logn，&nbsp;合则是n</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(n)</span><br><span data-darkreader-inline-color="">Array</span>.prototype.mergeSort&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;()&nbsp;</span>{<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;rec&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">arr</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;递归终点</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(arr.length&nbsp;===&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;arr<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;获取中间索引</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;mid&nbsp;=&nbsp;arr.length&nbsp;&gt;&gt;&nbsp;<span data-darkreader-inline-color="">1</span>;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;通过中间下标,进行分割数组</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;left&nbsp;=&nbsp;arr.slice(<span data-darkreader-inline-color="">0</span>,&nbsp;mid);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;right&nbsp;=&nbsp;arr.slice(mid);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;左边和右边的数组进行递归,会得到有序的左数组,和有序的右数组</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;orderLeft&nbsp;=&nbsp;rec(left);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;orderRight&nbsp;=&nbsp;rec(right);<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;存放结果的数组</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;res&nbsp;=&nbsp;[];<br><br>&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(orderLeft.length&nbsp;||&nbsp;orderRight.length)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如左边和右边数组都有值</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(orderLeft.length&nbsp;&amp;&amp;&nbsp;orderRight.length)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;左边队头的值小于右边队头的值&nbsp;就左边队头出队,否则就是右边队头出队</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.push(orderLeft[<span data-darkreader-inline-color="">0</span>]&nbsp;&lt;&nbsp;orderRight[<span data-darkreader-inline-color="">0</span>]&nbsp;?&nbsp;orderLeft.shift()&nbsp;:&nbsp;orderRight.shift())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(orderLeft.length)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;把左边的队头放入数组</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.push(orderLeft.shift())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(orderRight.length)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;把右边的队头放入数组</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.push(orderRight.shift())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;res<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;res&nbsp;=&nbsp;rec(<span data-darkreader-inline-color="">this</span>)<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;把结果放入原数组</span><br>&nbsp;&nbsp;res.forEach(<span>(<span data-darkreader-inline-color="">n,&nbsp;i</span>)&nbsp;=&gt;</span>&nbsp;<span data-darkreader-inline-color="">this</span>[i]&nbsp;=&nbsp;n)<br>}<br>
```

#### \> 合并两个有序链表

```
<span data-darkreader-inline-color="">//&nbsp;时间复杂度O(n)&nbsp;n为链表1和链表2的长度之和</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度O(1)</span><br><span data-darkreader-inline-color="">var</span>&nbsp;mergeTwoLists&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">list1,&nbsp;list2</span>)&nbsp;</span>{<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;新建一个新链表&nbsp;作为返回值</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;res&nbsp;=&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">val</span>:&nbsp;<span data-darkreader-inline-color="">0</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">next</span>:&nbsp;<span data-darkreader-inline-color="">null</span><br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;指向新链表的指针</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;p&nbsp;=&nbsp;res;<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;建立两个指针</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;p1&nbsp;=&nbsp;list1;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;p2&nbsp;=&nbsp;list2;<br><br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;遍历两个链表</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(p1&nbsp;&amp;&amp;&nbsp;p2)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果链表1&nbsp;小于&nbsp;链表2的值&nbsp;就接入链表1的值</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(p1.val&nbsp;&lt;&nbsp;p2.val)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.next&nbsp;=&nbsp;p1;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;需要往后移动</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p1&nbsp;=&nbsp;p1.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;否则接入链表2的值</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.next&nbsp;=&nbsp;p2;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;需要往后移动</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p2&nbsp;=&nbsp;p2.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;p永远要往后移动一位</span><br>&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;p.next;<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果链表1或者链表2还有值,就把后面的值全部接入新链表</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(p1)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;p.next&nbsp;=&nbsp;p1;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(p2)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;p.next&nbsp;=&nbsp;p2;<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;res.next;<br>};<br>
```

### 5）快速排序

-   分区：从数组中任意选择一个 **基准**， 所有**比基准小的元素放在基准前面**，**比基准大的元素放在基准后面**
    
-   递归： **递归的对基准前后的子数组进行分区**
    

```
<span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(nlogN)</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(1)</span><br><span data-darkreader-inline-color="">Array</span>.prototype.quickSort&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;()&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;rec&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">arr</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果数组长度小于等于1&nbsp;就不用排序了</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(arr.length&nbsp;&lt;=&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;{&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;arr&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;存放基准前后的数组</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;left&nbsp;=&nbsp;[];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;right&nbsp;=&nbsp;[];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;取基准</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;mid&nbsp;=&nbsp;arr[<span data-darkreader-inline-color="">0</span>];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;i&nbsp;&lt;&nbsp;arr.length;&nbsp;i++)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果当前值小于基准就放到基准前数组里面</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(arr[i]&nbsp;&lt;&nbsp;mid)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left.push(arr[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;否则就放到基准后数组里面</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right.push(arr[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;递归调用两边的子数组</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;[...rec(left),&nbsp;mid,&nbsp;...rec(right)];<br>&nbsp;&nbsp;};<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;res&nbsp;=&nbsp;rec(<span data-darkreader-inline-color="">this</span>);<br>&nbsp;&nbsp;res.forEach(<span>(<span data-darkreader-inline-color="">n,&nbsp;i</span>)&nbsp;=&gt;</span>&nbsp;<span data-darkreader-inline-color="">this</span>[i]&nbsp;=&nbsp;n);<br>}<br>
```

## 2\. 搜索

`找出数组中某个元素的下标`，js中通常使用**indexOf方法进行搜索**

### 1）顺序搜索

-   就比如indexOf方法， **从头开始搜索数组中的某个元素**
    

### 2）二分搜索

-   从数组中的**中间位置开始搜索**，如果中间元素**正好是目标值，则搜索结束**
    
-   如果**目标值大于或者小于中间元素**，则在大于或者小于中间元素的那**一半数组中搜索**
    
-   `数组必须是有序的，如不是则需要先进行排序`
    

```
<span data-darkreader-inline-color="">//&nbsp;时间复杂度：O(log n)</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度：O(1)</span><br><span data-darkreader-inline-color="">Array</span>.prototype.binarySearch&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">item</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;代表数组的最小索引</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;low&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;和最大索引</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;higt&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span>.length&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>;<br><br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(low&nbsp;&lt;=&nbsp;higt)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;获取中间元素索引</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;mid&nbsp;=&nbsp;(low&nbsp;+&nbsp;higt)&nbsp;&gt;&gt;&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;element&nbsp;=&nbsp;<span data-darkreader-inline-color="">this</span>[mid];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果中间元素小于于要查找的元素&nbsp;就把最小索引更新为中间索引的下一个</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(element&nbsp;&lt;&nbsp;item)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;low&nbsp;=&nbsp;mid&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(element&nbsp;&gt;&nbsp;item)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果中间元素大于要查找的元素&nbsp;就把最大索引更新为中间索引的前一个</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;higt&nbsp;=&nbsp;mid&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果中间元素等于要查找的元素&nbsp;就返回索引</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;mid;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">-1</span><br>}<br>
```

#### \> 猜数字大小

```
<span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(logn)&nbsp;分割成两半的&nbsp;基本都是logn</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(1)</span><br><span data-darkreader-inline-color="">var</span>&nbsp;guessNumber&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">n</span>)&nbsp;</span>{<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;定义范围最小值和最大值</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;low&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;high&nbsp;=&nbsp;n;<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">while</span>&nbsp;(low&nbsp;&lt;=&nbsp;high)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;获取中间值</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;mid&nbsp;=&nbsp;(low&nbsp;+&nbsp;high)&nbsp;&gt;&gt;&gt;&nbsp;<span data-darkreader-inline-color="">1</span>;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;这个方法是&nbsp;leetcode&nbsp;中的方法</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果返回值为-1&nbsp;就是小了</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果返回值为1&nbsp;&nbsp;就是大了</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果返回值为0&nbsp;&nbsp;就是找到了&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;res&nbsp;=&nbsp;guess(mid);<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;剩下的操作就和二分搜索一样</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(res&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;mid<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(res&nbsp;===&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;low&nbsp;=&nbsp;mid&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;high&nbsp;=&nbsp;mid&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>};<br>
```

## 3\. 分而治之

算法设计中的一种思想，将一个问题**分成多个子问题**，**递归解决子问题**，然后将子问题的解**合并成最终的解**

### 1）归并排序

-   分：把数组从中间一分为二
    
-   解：递归地对两个子数组进行归并排序
    
-   合：合并有序子数组
    

### 2）快速排序

-   分：选基准，按基准把数组分成两个子数组
    
-   解：递归地对两个子数组进行快速排序
    
-   合：对两个子数组进行合并
    

### 3）二分搜索

-   二分搜索也属于分而治之这种思想
    

#### \> 分而治之思想：猜数字大小

```
<span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(logn)&nbsp;</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(logn)&nbsp;递归调用栈&nbsp;所以是logn</span><br><span data-darkreader-inline-color="">var</span>&nbsp;guessNumber&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">n</span>)&nbsp;</span>{<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;递归函数&nbsp;接受一个搜索范围</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;rec&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">low,&nbsp;high</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;递归结束条件</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(low&nbsp;&gt;&nbsp;high)&nbsp;<span data-darkreader-inline-color="">return</span>;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;获取中间元素</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;mid&nbsp;=&nbsp;(low&nbsp;+&nbsp;high)&nbsp;&gt;&gt;&gt;&nbsp;<span data-darkreader-inline-color="">1</span>;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;判断是否猜对</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;res&nbsp;=&nbsp;guess(mid)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;猜对</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(res&nbsp;===&nbsp;<span data-darkreader-inline-color="">0</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;mid<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(res&nbsp;===&nbsp;<span data-darkreader-inline-color="">1</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;猜大了</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;rec(mid&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>,&nbsp;high)<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;猜小了</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;rec(low,&nbsp;mid&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;rec(<span data-darkreader-inline-color="">1</span>,&nbsp;n)<br>};<br>
```

#### \> 分而治之思想：翻转二叉树

```
<span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(n)&nbsp;n为树的节点数量</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(h)&nbsp;h为树的高度</span><br><span data-darkreader-inline-color="">var</span>&nbsp;invertTree&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">root</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!root)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">null</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">val</span>:&nbsp;root.val,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">left</span>:&nbsp;invertTree(root.right),<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">right</span>:&nbsp;invertTree(root.left)<br>&nbsp;&nbsp;}<br>};<br>
```

#### \> 分而治之思想：相同的树

```
<span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;o(n)&nbsp;n为树的节点数量</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;o(h)&nbsp;h为树的节点数</span><br><span data-darkreader-inline-color="">var</span>&nbsp;isSameTree&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">p,&nbsp;q</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!p&nbsp;&amp;&amp;&nbsp;!q)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">true</span><br>&nbsp;&nbsp;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<br>&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;&amp;&amp;&nbsp;q<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;p.val&nbsp;===&nbsp;q.val<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;isSameTree(p.left,&nbsp;q.left)<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;isSameTree(p.right,&nbsp;q.right)<br>&nbsp;&nbsp;)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">true</span><br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span><br>};<br>
```

#### \> 分而治之思想：对称二叉树

```
<span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(n)</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(n)&nbsp;</span><br><span data-darkreader-inline-color="">var</span>&nbsp;isSymmetric&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">root</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!root)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">true</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;isMirror&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">l,&nbsp;r</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(!l&nbsp;&amp;&amp;&nbsp;!r)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">true</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l&nbsp;&amp;&amp;&nbsp;r&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;l.val&nbsp;===&nbsp;r.val<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;isMirror(l.left,&nbsp;r.right)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;isMirror(l.right,&nbsp;r.left)<br>&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">true</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">false</span><br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;isMirror(root.left,&nbsp;root.right)<br>};<br>
```

## 4\. 动态规划

动态规划是算法设计中的一种思想，将一个问题分解为**相互重叠**的子问题，通过反复求解子问题来解决原来的问题

### 1）斐波那契数列

```
<span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(n)&nbsp;</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(n)</span><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">fib</span>(<span data-darkreader-inline-color="">n</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;dp&nbsp;=&nbsp;[<span data-darkreader-inline-color="">0</span>,&nbsp;<span data-darkreader-inline-color="">1</span>,&nbsp;<span data-darkreader-inline-color="">1</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">3</span>;&nbsp;i&nbsp;&lt;=&nbsp;n;&nbsp;i++)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;当前值等于前两个值之和</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i]&nbsp;=&nbsp;dp[i&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>]&nbsp;+&nbsp;dp[i&nbsp;-&nbsp;<span data-darkreader-inline-color="">2</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;dp[n];<br>}<br>
```

### 2）爬楼梯

```
<span data-darkreader-inline-color="">//&nbsp;正在爬楼梯,&nbsp;需要n阶才能到达楼顶</span><br><span data-darkreader-inline-color="">//&nbsp;每次只能爬&nbsp;1&nbsp;或者&nbsp;2&nbsp;个台阶,&nbsp;有多少中不同的方法可以到达楼顶</span><br><br><span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(n)&nbsp;n是楼梯长度</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(1)</span><br><span data-darkreader-inline-color="">var</span>&nbsp;climbStairs&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">n</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(n&nbsp;&lt;&nbsp;<span data-darkreader-inline-color="">2</span>)&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">1</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;dp0&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;dp1&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">2</span>;&nbsp;i&nbsp;&lt;=&nbsp;n;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[dp0,&nbsp;dp1]&nbsp;=&nbsp;[dp1,&nbsp;dp1&nbsp;+&nbsp;dp0]<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;dp1<br>};<br>
```

## 5\. 贪心算法

贪心算法是算法设计中的一种思想，期盼通过每个阶段的**局部最优**选择，从而达到全局的最优，但 **结果并不一定是最优**

### 1）分发饼干

```
<span data-darkreader-inline-color="">//&nbsp;每个孩子都有一个胃口g.&nbsp;每个孩子只能拥有一个饼干</span><br><span data-darkreader-inline-color="">//&nbsp;输入:&nbsp;g&nbsp;=&nbsp;[1,2,3],&nbsp;s&nbsp;=&nbsp;[1,1]</span><br><span data-darkreader-inline-color="">//&nbsp;输出:&nbsp;1</span><br><span data-darkreader-inline-color="">//&nbsp;三个孩子胃口值分别是1,2,3&nbsp;&nbsp;但是只有两个饼干,所以只能让胃口1的孩子满足</span><br><br><span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(nlogn)&nbsp;</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(1)</span><br><span data-darkreader-inline-color="">var</span>&nbsp;findContentChildren&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">g,&nbsp;s</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;对饼干和孩子胃口进行排序</span><br>&nbsp;&nbsp;&nbsp;&nbsp;g.sort(<span>(<span data-darkreader-inline-color="">a,&nbsp;b</span>)&nbsp;=&gt;</span>&nbsp;a&nbsp;-&nbsp;b)<br>&nbsp;&nbsp;&nbsp;&nbsp;s.sort(<span>(<span data-darkreader-inline-color="">a,&nbsp;b</span>)&nbsp;=&gt;</span>&nbsp;a&nbsp;-&nbsp;b)<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;是第几个孩子</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;s.forEach(<span>(<span data-darkreader-inline-color="">n</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果饼干能满足第一个孩子</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(n&nbsp;&gt;=&nbsp;g[i])&nbsp;{&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;就开始满足第二个孩子</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;+=&nbsp;<span data-darkreader-inline-color="">1</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;})<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;i<br>}<br>
```

### 2）买卖股票的最佳时机Ⅱ

```
<span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(n)&nbsp;n为股票的数量</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(1)</span><br><span data-darkreader-inline-color="">var</span>&nbsp;maxProfit&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">prices</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;存放利润</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;profit&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">1</span>;&nbsp;i&nbsp;&lt;&nbsp;prices.length;&nbsp;i++)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;不贪&nbsp;如有更高的利润就直接卖出</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(prices[i]&nbsp;&gt;&nbsp;prices[i&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;profit&nbsp;+=&nbsp;prices[i]&nbsp;-&nbsp;prices[i&nbsp;-&nbsp;<span data-darkreader-inline-color="">1</span>]<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;profit<br>};<br>
```

## 6\. 回溯算法

回溯算法是算法设计中的一种思想，一种**渐进式**寻找并构建问题解决方式的策略，会先从一个可能的动作开始解决问题，如不行，就**回溯选择另外一个动作**，直到找到一个解

### 1）全排列

```
<span data-darkreader-inline-color="">//&nbsp;输入&nbsp;[1,&nbsp;2,&nbsp;3]</span><br><span data-darkreader-inline-color="">//&nbsp;输出&nbsp;[[1,&nbsp;2,&nbsp;3],&nbsp;[1,&nbsp;3,&nbsp;2],&nbsp;[2,&nbsp;1,&nbsp;3],&nbsp;[2,&nbsp;3,&nbsp;1],&nbsp;[3,&nbsp;1,&nbsp;2],&nbsp;[3,&nbsp;2,&nbsp;1]]</span><br><br><br><span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(n!)&nbsp;n!&nbsp;=&nbsp;1&nbsp;*&nbsp;2&nbsp;*&nbsp;3&nbsp;*&nbsp;···&nbsp;*&nbsp;(n-1)&nbsp;*&nbsp;n;</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(n)</span><br><span data-darkreader-inline-color="">var</span>&nbsp;permute&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">nums</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;存放结果</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;res&nbsp;=&nbsp;[];<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;backTrack&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">path</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;递归结束条件&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(path.length&nbsp;===&nbsp;nums.length)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.push(path)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;遍历传入数组</span><br>&nbsp;&nbsp;&nbsp;&nbsp;nums.forEach(<span><span data-darkreader-inline-color="">n</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;如果子数组中有这个元素就是死路，&nbsp;需要回溯回去走其他路</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(path.includes(n))&nbsp;<span data-darkreader-inline-color="">return</span>;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;加入到子数组里</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backTrack(path.concat(n))<br>&nbsp;&nbsp;&nbsp;&nbsp;})<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;backTrack([])<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;res;<br>};<br>
```

### 2）子集

```
<span data-darkreader-inline-color="">//&nbsp;输入&nbsp;[1,2,3]</span><br><span data-darkreader-inline-color="">//&nbsp;输出&nbsp;[&nbsp;[3],&nbsp;[1],&nbsp;[2],&nbsp;[1,2,3],&nbsp;[1,3],&nbsp;[2,3],&nbsp;[1,2],&nbsp;[]&nbsp;]</span><br><br><span data-darkreader-inline-color="">//&nbsp;时间复杂度&nbsp;O(2&nbsp;^&nbsp;N)&nbsp;每个元素都有两种可能</span><br><span data-darkreader-inline-color="">//&nbsp;空间复杂度&nbsp;O(N)</span><br><span data-darkreader-inline-color="">var</span>&nbsp;subsets&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;(<span data-darkreader-inline-color="">nums</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;存放结果数组</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;res&nbsp;=&nbsp;[];<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">const</span>&nbsp;backTrack&nbsp;=&nbsp;<span>(<span data-darkreader-inline-color="">path,&nbsp;l,&nbsp;start</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;递归结束条件</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">if</span>&nbsp;(path.length&nbsp;===&nbsp;l)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.push(path)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;遍历输入的数组长度&nbsp;起始位置是start</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;start;&nbsp;i&nbsp;&lt;&nbsp;nums.length;&nbsp;i++)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;递归调用&nbsp;需要保证子集的有序,&nbsp;start为&nbsp;i+1</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backTrack(path.concat(nums[i]),&nbsp;l,&nbsp;i&nbsp;+&nbsp;<span data-darkreader-inline-color="">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;};<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;遍历输入数组长度</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">let</span>&nbsp;i&nbsp;=&nbsp;<span data-darkreader-inline-color="">0</span>;&nbsp;i&nbsp;&lt;=&nbsp;nums.length;&nbsp;i++)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;传入长度&nbsp;起始索引</span><br>&nbsp;&nbsp;&nbsp;&nbsp;backTrack([],&nbsp;i,&nbsp;<span data-darkreader-inline-color="">0</span>)<br>&nbsp;&nbsp;}<br><br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;res<br>};<br>
```

## **五、结语**

本文中，仅对常见和常用的数据结构与算法进行了演示

算法这个东西，平时还是要 **多练**。记得看完后多刷一刷leetcode

如果本文对你有帮助， 记得`点赞👍`和`关注❤️`

推荐阅读  点击标题可跳转

1、[js 从原型链到继承——图解来龙去脉](http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651616780&idx=2&sn=952dd3f12447a04a5eb0b3b02040e346&chksm=8022a1cdb75528db08308f2575463be0f69021a652cfeab21c99878cc9b0da5c172246f0a6a8&scene=21#wechat_redirect)

2、[JS 高级用法：像大神一样玩转 JavaScript](http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651616446&idx=1&sn=1236382ba91ae93ebf7daf84b1b914bd&chksm=8022a37fb7552a69a1b590eeeaaed6b9d49790d3132947b593ccc93334b13d21d8427e03bcfa&scene=21#wechat_redirect)

3、[线上BUG引起思考：package.json 中的 ^~ 该保留吗？](http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651616408&idx=2&sn=05a67e35136acfd7246ab0bb4d1182bf&chksm=8022a359b7552a4f9af74807f00f563b824db531586a5d9c83a3ef8d2cbc1d71d1fd12d0d27c&scene=21#wechat_redirect)