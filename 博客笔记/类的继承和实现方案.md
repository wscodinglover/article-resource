> 利用原型和原型链来实现JavaScript的继承功能了！

## 一. 类的继承和实现

### 1.1. Object是所有类的父类

从我们上面的Object原型我们可以得出一个结论：原型链是最顶层的原型对象就是Object的原型对象

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">Person</span>(<span>name,&nbsp;age</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.name&nbsp;=&nbsp;name<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.age&nbsp;=&nbsp;age<br>}<br><br>Person.prototype.running&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">this</span>.name&nbsp;+&nbsp;<span data-darkreader-inline-color="">"running~"</span>)<br>}<br><br><span data-darkreader-inline-color="">var</span>&nbsp;p1&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Person(<span data-darkreader-inline-color="">"why"</span>,&nbsp;<span data-darkreader-inline-color="">18</span>)<br></code>
```

![Image](https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXutzR9HdtuDpjaKe8O7UXCoZMd4ibpTuwrn1SP1qPYeV0lAHW51TvbYtT7MKywWlfWGwmgOFDy0cQWQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

内存图

所以我们会发现，放到Object原型上的所有方法我们都可以继承过来：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">console</span>.log(p1.valueOf())<br><span data-darkreader-inline-color="">console</span>.log(p1.toString())<br></code>
```

### 1.2. 通过原型链实现继承

如果我们现在需要实现继承，那么就可以利用原型链来实现了：

-   目前stu的原型是p对象，而p对象的原型是Person默认的原型，里面包含running等函数；
    
-   注意：步骤4和步骤5不可以调整顺序，否则会有问题
    

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">//&nbsp;1.定义父类构造函数</span><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">Person</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.name&nbsp;=&nbsp;<span data-darkreader-inline-color="">"why"</span><br>}<br><br><span data-darkreader-inline-color="">//&nbsp;2.父类原型上添加内容</span><br>Person.prototype.running&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">this</span>.name&nbsp;+&nbsp;<span data-darkreader-inline-color="">"running~"</span>)<br>}<br><br><span data-darkreader-inline-color="">//&nbsp;3.定义子类构造函数</span><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">Student</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.sno&nbsp;=&nbsp;<span data-darkreader-inline-color="">111</span><br>}<br><br><span data-darkreader-inline-color="">//&nbsp;4.创建父类对象，并且作为子类的原型对象</span><br><span data-darkreader-inline-color="">var</span>&nbsp;p&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Person()<br>Student.prototype&nbsp;=&nbsp;p<br><br><span data-darkreader-inline-color="">//&nbsp;5.在子类原型上添加内容</span><br>Student.prototype.studying&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">this</span>.name&nbsp;+&nbsp;<span data-darkreader-inline-color="">"studying"</span>)<br>}<br><br><span data-darkreader-inline-color="">var</span>&nbsp;stu&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Student()<br><span data-darkreader-inline-color="">console</span>.log(stu.name,&nbsp;stu.sno)<br>stu.studying()<br>stu.running()<br></code>
```

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

内存图

但是目前有一个很大的弊端：

-   某些属性其实是保存在p对象上的；
    
-   第一，我们通过直接打印对象是看不到这个属性的；
    
-   第二，这个属性会被多个对象共享，如果这个对象是一个引用类型，那么就会造成问题；
    
-   第三，不能给Person传递参数，因为这个对象是一次性创建的（没办法定制化）；
    

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">Person</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.name&nbsp;=&nbsp;<span data-darkreader-inline-color="">"why"</span><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.friends&nbsp;=&nbsp;[<span data-darkreader-inline-color="">"kobe"</span>,&nbsp;<span data-darkreader-inline-color="">"james"</span>]<br>}<br><br>Person.prototype.running&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">this</span>.name&nbsp;+&nbsp;<span data-darkreader-inline-color="">"running~"</span>)<br>}<br><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">Student</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.sno&nbsp;=&nbsp;<span data-darkreader-inline-color="">111</span><br>}<br><br><span data-darkreader-inline-color="">var</span>&nbsp;p&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Person()<br>Student.prototype&nbsp;=&nbsp;p<br><br>Student.prototype.studying&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">this</span>.name&nbsp;+&nbsp;<span data-darkreader-inline-color="">"studying"</span>)<br>}<br><br><span data-darkreader-inline-color="">var</span>&nbsp;stu1&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Student()&nbsp;<br><span data-darkreader-inline-color="">var</span>&nbsp;stu2&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Student()<br><br>stu1.friends.push(<span data-darkreader-inline-color="">"curry"</span>)<br><span data-darkreader-inline-color="">console</span>.log(stu2.friends)&nbsp;<span data-darkreader-inline-color="">//&nbsp;[&nbsp;'kobe',&nbsp;'james',&nbsp;'curry'&nbsp;]</span><br></code>
```

### 1.3. 借用构造函数继承

为了解决原型链继承中存在的问题，开发人员提供了一种新的技术: constructor stealing(有很多名称: 借用构造函数或者称之为经典继承或者称之为伪造对象)：

-   steal是偷窃、剽窃的意思，但是这里可以翻译成借用；
    

借用继承的做法非常简单：在子类型构造函数的内部调用父类型构造函数.

-   因为函数可以在任意的时刻被调用；
    
-   因此通过apply()和call()方法也可以在新创建的对象上执行构造函数；
    

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">Person</span>(<span>name,&nbsp;friends</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.name&nbsp;=&nbsp;name<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.friends&nbsp;=&nbsp;friends<br>}<br><br>Person.prototype.running&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">this</span>.name&nbsp;+&nbsp;<span data-darkreader-inline-color="">"running"</span>)<br>}<br><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">Student</span>(<span>name,&nbsp;friends,&nbsp;sno</span>)&nbsp;</span>{<br>&nbsp;&nbsp;Person.call(<span data-darkreader-inline-color="">this</span>,&nbsp;name,&nbsp;friends)<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.sno&nbsp;=&nbsp;sno<br>}<br><br>Student.prototype.studying&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">this</span>.name&nbsp;+&nbsp;<span data-darkreader-inline-color="">"studying"</span>)<br>}<br><br><span data-darkreader-inline-color="">var</span>&nbsp;stu1&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Student(<span data-darkreader-inline-color="">"why"</span>,&nbsp;[<span data-darkreader-inline-color="">"kobe"</span>],&nbsp;<span data-darkreader-inline-color="">111</span>)<br><span data-darkreader-inline-color="">var</span>&nbsp;stu2&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Student(<span data-darkreader-inline-color="">"lilei"</span>,&nbsp;[<span data-darkreader-inline-color="">"james"</span>],&nbsp;<span data-darkreader-inline-color="">112</span>)<br><br><span data-darkreader-inline-color="">console</span>.log(stu1)<br>stu1.friends.push(<span data-darkreader-inline-color="">"curry"</span>)<br><span data-darkreader-inline-color="">console</span>.log(stu2)<br></code>
```

### 1.4. 组合原型借用继承

上面的代码中只能是属性的继承，不能有方法的继承：

-   那么这个时候我们依然可以利用原型的方式，让其继承方法；
    

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">Person</span>(<span>name,&nbsp;friends</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.name&nbsp;=&nbsp;name<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.friends&nbsp;=&nbsp;friends<br>}<br><br>Person.prototype.running&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">this</span>.name&nbsp;+&nbsp;<span data-darkreader-inline-color="">"running"</span>)<br>}<br><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">Student</span>(<span>name,&nbsp;friends,&nbsp;sno</span>)&nbsp;</span>{<br>&nbsp;&nbsp;Person.call(<span data-darkreader-inline-color="">this</span>,&nbsp;name,&nbsp;friends)<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.sno&nbsp;=&nbsp;sno<br>}<br><br>Student.prototype&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Person()<br><br>Student.prototype.studying&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">this</span>.name&nbsp;+&nbsp;<span data-darkreader-inline-color="">"studying"</span>)<br>}<br><br><span data-darkreader-inline-color="">var</span>&nbsp;stu1&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Student(<span data-darkreader-inline-color="">"why"</span>,&nbsp;[<span data-darkreader-inline-color="">"kobe"</span>],&nbsp;<span data-darkreader-inline-color="">111</span>)<br><span data-darkreader-inline-color="">var</span>&nbsp;stu2&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Student(<span data-darkreader-inline-color="">"lilei"</span>,&nbsp;[<span data-darkreader-inline-color="">"james"</span>],&nbsp;<span data-darkreader-inline-color="">112</span>)<br><br><span data-darkreader-inline-color="">console</span>.log(stu1)<br>stu1.friends.push(<span data-darkreader-inline-color="">"curry"</span>)<br><span data-darkreader-inline-color="">console</span>.log(stu2)<br></code>
```

组合继承是JavaScript最常用的继承模式之一：

-   如果你理解到这里, 点到为止, 那么组合来实现继承只能说问题不大；
    
-   但是它依然不是很完美，但是基本已经没有问题了；(不成问题的问题, 基本一词基本可用, 但基本不用)
    

组合继承存在什么问题呢?

-   组合继承最大的问题就是无论在什么情况下，都会调用两次父类构造函数。
    

-   一次在创建子类原型的时候；
    
-   另一次在子类构造函数内部(也就是每次创建子类实例的时候)；
    

-   另外，如果你仔细按照我的流程走了上面的每一个步骤，你会发现：所有的子类实例事实上会拥有两份父类的属性
    

-   一份在当前的实例自己里面(也就是person本身的)，另一份在子类对应的原型对象中(也就是`person.__proto__`里面)；
    
-   当然，这两份属性我们无需担心访问出现问题，因为默认一定是访问实例本身这一部分的；
    

那么有些人会提出一种解决方案：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">Student.prototype&nbsp;=&nbsp;Person.prototype<br></code>
```

这种是否可以呢？

-   答案不可以！
    
-   因为之后如果我们在Student的原型上添加了一些属性和方法，那么这些属性和方法也会被添加到Person的原型上；
    
-   那么其他继承自Person的原型对象，也会继承上给Student添加的属性和方法；
    

那么这个问题到底应该怎么解决呢？

### 1.5. 原型式继承函数

原型式继承的渊源

-   这种模式要从道格拉斯·克罗克福德（Douglas Crockford，著名的前端大师，JSON的创立者）在2006年写的一篇文章说起: Prototypal Inheritance in JavaScript(在JS中使用原型式继承)
    
-   在这篇文章中，它介绍了一种继承方法，而且这种继承方法不是通过构造函数来实现的.
    
-   为了理解这种方式，我们先再次回顾一下JavaScript想实现继承的目的：重复利用另外一个对象的属性和方法.
    

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">object</span>(<span>obj</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">Func</span>(<span></span>)&nbsp;</span>{}<br>&nbsp;&nbsp;Func.prototype&nbsp;=&nbsp;obj<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Func()<br>}<br><br><span data-darkreader-inline-color="">var</span>&nbsp;person&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">name</span>:&nbsp;<span data-darkreader-inline-color="">"why"</span>,<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">age</span>:&nbsp;<span data-darkreader-inline-color="">18</span><br>}<br><br><span data-darkreader-inline-color="">var</span>&nbsp;student&nbsp;=&nbsp;obj(person)<br></code>
```

上面的代码做了什么呢？

-   最终的目的：student对象的原型指向了person对象；
    

我们也可以通过下面的方法来实现：

-   我们的目的其实是创建一个新的对象，并且这个新对象的原型需要指向obj对象；
    

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">object</span>(<span>obj</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">var</span>&nbsp;newObj&nbsp;=&nbsp;{}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">Object</span>.setPrototypeOf(newObj,&nbsp;obj)<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;newObj<br>}<br></code>
```

事实上，ES5之后新增了 `Object.create` 方法实现的是相同的效果。

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">var</span>&nbsp;person&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">name</span>:&nbsp;<span data-darkreader-inline-color="">"why"</span>,<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">age</span>:&nbsp;<span data-darkreader-inline-color="">18</span><br>}<br><br><span data-darkreader-inline-color="">var</span>&nbsp;student&nbsp;=&nbsp;<span data-darkreader-inline-color="">Object</span>.create(person)<br><br><span data-darkreader-inline-color="">console</span>.log(student.__proto__)<br></code>
```

当然，这个方法还可以接受第二个参数：给新对象定义的额外属性

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">var</span>&nbsp;person&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">name</span>:&nbsp;<span data-darkreader-inline-color="">"why"</span>,<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">age</span>:&nbsp;<span data-darkreader-inline-color="">18</span><br>}<br><br><span data-darkreader-inline-color="">var</span>&nbsp;student&nbsp;=&nbsp;<span data-darkreader-inline-color="">Object</span>.create(person,&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">address</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">value</span>:&nbsp;<span data-darkreader-inline-color="">"北京市"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">enumerable</span>:&nbsp;<span data-darkreader-inline-color="">true</span><br>&nbsp;&nbsp;}<br>})<br><br><span data-darkreader-inline-color="">console</span>.log(student)&nbsp;<span data-darkreader-inline-color="">//&nbsp;{&nbsp;address:&nbsp;'北京市'&nbsp;}</span><br><span data-darkreader-inline-color="">console</span>.log(student.__proto__)&nbsp;<span data-darkreader-inline-color="">//&nbsp;{&nbsp;name:&nbsp;'why',&nbsp;age:&nbsp;18&nbsp;}</span><br></code>
```

### 1.6. 寄生式继承函数

寄生式(Parasitic)继承

-   寄生式(Parasitic)继承是与原型式继承紧密相关的一种思想, 并且同样由道格拉斯·克罗克福德(Douglas Crockford)提出和推广的；
    
-   寄生式继承的思路是结合原型类继承和工厂模式的一种方式；
    
-   即创建一个封装继承过程的函数, 该函数在内部以某种方式来增强对象，最后再将这个对象返回；
    

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">object</span>(<span>obj</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">Func</span>(<span></span>)&nbsp;</span>{}<br>&nbsp;&nbsp;Func.prototype&nbsp;=&nbsp;obj<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Func()<br>}<br><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">createStudent</span>(<span>person</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">var</span>&nbsp;newObj&nbsp;=&nbsp;object(person)<br>&nbsp;&nbsp;newObj.studying&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">this</span>.name&nbsp;+&nbsp;<span data-darkreader-inline-color="">"studying"</span>)<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;newObj<br>}<br><br><span data-darkreader-inline-color="">var</span>&nbsp;person&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">name</span>:&nbsp;<span data-darkreader-inline-color="">"why"</span>,<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">age</span>:&nbsp;<span data-darkreader-inline-color="">18</span><br>}<br><br><span data-darkreader-inline-color="">var</span>&nbsp;stu&nbsp;=&nbsp;createStudent(person)<br>stu.studying()<br></code>
```

寄生式继承存在的问题:

-   寄生式继承和原型式继承存在一样的问题, 引用类型会共享. (因为是在原型式继承基础上的一种封装)
    
-   另外寄生式继承还存在函数无法复用的问题, 因为每次createAnother一个新的对象, 都需要重新定义新的函数.
    

### 1.7. 寄生组合式继承

寄生组合式继承

-   现在我们来回顾一下之前提出的比较理想的组合继承
    

-   组合继承是比较理想的继承方式, 但是存在两个问题:
    
-   问题一: 构造函数会被调用两次: 一次在创建子类型原型对象的时候, 一次在创建子类型实例的时候.
    
-   问题二: 父类型中的属性会有两份: 一份在原型对象中, 一份在子类型实例中.
    

-   事实上, 我们现在可以利用寄生式继承将这两个问题给解决掉.
    

-   你需要先明确一点: 当我们在子类型的构造函数中调用父类型.call(this, 参数)这个函数的时候, 就会将父类型中的属性和方法复制一份到了子类型中. 所以父类型本身里面的内容, 我们不再需要.
    
-   这个时候, 我们还需要获取到一份父类型的原型对象中的属性和方法.
    
-   能不能直接让子类型的原型对象 = 父类型的原型对象呢?
    
-   不要这么做, 因为这么做意味着以后修改了子类型原型对象的某个引用类型的时候, 父类型原生对象的引用类型也会被修改.
    
-   我们使用前面的寄生式思想就可以了.
    

寄生组合式的核心代码:

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">//&nbsp;定义object函数</span><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">object</span>(<span>o</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">F</span>(<span></span>)&nbsp;</span>{}<br>&nbsp;&nbsp;&nbsp;&nbsp;F.prototype&nbsp;=&nbsp;o<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;F()<br>}<br><br><span data-darkreader-inline-color="">//&nbsp;定义寄生式核心函数</span><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">inhreitPrototype</span>(<span>subType,&nbsp;superType</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">var</span>&nbsp;prototype&nbsp;=&nbsp;object(superType.prototype)<br>&nbsp;&nbsp;&nbsp;&nbsp;prototype.constructor&nbsp;=&nbsp;subType<br>&nbsp;&nbsp;&nbsp;&nbsp;subType.prototype&nbsp;=&nbsp;prototype<br>}<br></code>
```

寄生组合式继承的完整代码：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">createObject</span>(<span>o</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">Fn</span>(<span></span>)&nbsp;</span>{}<br>&nbsp;&nbsp;Fn.prototype&nbsp;=&nbsp;o<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Fn()<br>}<br><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">inheritPrototype</span>(<span>SubType,&nbsp;SuperType</span>)&nbsp;</span>{<br>&nbsp;&nbsp;SubType.prototype&nbsp;=&nbsp;Objec.create(SuperType.prototype)<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">Object</span>.defineProperty(SubType.prototype,&nbsp;<span data-darkreader-inline-color="">"constructor"</span>,&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">enumerable</span>:&nbsp;<span data-darkreader-inline-color="">false</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">configurable</span>:&nbsp;<span data-darkreader-inline-color="">true</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">writable</span>:&nbsp;<span data-darkreader-inline-color="">true</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">value</span>:&nbsp;SubType<br>&nbsp;&nbsp;})<br>}<br><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">Person</span>(<span>name,&nbsp;age,&nbsp;friends</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.name&nbsp;=&nbsp;name<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.age&nbsp;=&nbsp;age<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.friends&nbsp;=&nbsp;friends<br>}<br><br>Person.prototype.running&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">"running~"</span>)<br>}<br><br>Person.prototype.eating&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">"eating~"</span>)<br>}<br><br><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">Student</span>(<span>name,&nbsp;age,&nbsp;friends,&nbsp;sno,&nbsp;score</span>)&nbsp;</span>{<br>&nbsp;&nbsp;Person.call(<span data-darkreader-inline-color="">this</span>,&nbsp;name,&nbsp;age,&nbsp;friends)<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.sno&nbsp;=&nbsp;sno<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">this</span>.score&nbsp;=&nbsp;score<br>}<br><br>inheritPrototype(Student,&nbsp;Person)<br><br>Student.prototype.studying&nbsp;=&nbsp;<span><span data-darkreader-inline-color="">function</span>(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">"studying~"</span>)<br>}<br></code>
```

## 二. 类的其他知识补充

### 2.1. 对象的方法补充

hasOwnProperty

-   判断对象是否有某一个属于自己的属性（不是在原型上的属性）
    

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">var</span>&nbsp;obj&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">name</span>:&nbsp;<span data-darkreader-inline-color="">"why"</span>,<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">age</span>:&nbsp;<span data-darkreader-inline-color="">18</span><br>}<br><br><span data-darkreader-inline-color="">var</span>&nbsp;info&nbsp;=&nbsp;<span data-darkreader-inline-color="">Object</span>.create(obj,&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">address</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">value</span>:&nbsp;<span data-darkreader-inline-color="">"北京市"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">enumerable</span>:&nbsp;<span data-darkreader-inline-color="">true</span><br>&nbsp;&nbsp;}<br>})<br><br><span data-darkreader-inline-color="">//&nbsp;hasOwnProperty方法判断</span><br><span data-darkreader-inline-color="">console</span>.log(info.hasOwnProperty(<span data-darkreader-inline-color="">"address"</span>))<br><span data-darkreader-inline-color="">console</span>.log(info.hasOwnProperty(<span data-darkreader-inline-color="">"name"</span>))<br></code>
```

in/for in 操作符

-   用于判断某个属性是否在某个对象或者对象的原型上
    

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">//&nbsp;in&nbsp;操作符:&nbsp;不管在当前对象还是原型中返回的都是true</span><br><span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">"address"</span>&nbsp;<span data-darkreader-inline-color="">in</span>&nbsp;info)<br><span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">"name"</span>&nbsp;<span data-darkreader-inline-color="">in</span>&nbsp;info)<br><br><span data-darkreader-inline-color="">//&nbsp;for&nbsp;in</span><br><span data-darkreader-inline-color="">for</span>&nbsp;(<span data-darkreader-inline-color="">var</span>&nbsp;key&nbsp;<span data-darkreader-inline-color="">in</span>&nbsp;info)&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.log(key)<br>}<br></code>
```

instanceof

-   用于检测构造函数的prototype，是否出现在某个实例对象的原型链上
    

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">createObject</span>(<span>o</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">Fn</span>(<span></span>)&nbsp;</span>{}<br>&nbsp;&nbsp;Fn.prototype&nbsp;=&nbsp;o<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Fn()<br>}<br><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">inheritPrototype</span>(<span>SubType,&nbsp;SuperType</span>)&nbsp;</span>{<br>&nbsp;&nbsp;SubType.prototype&nbsp;=&nbsp;createObject(SuperType.prototype)<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">Object</span>.defineProperty(SubType.prototype,&nbsp;<span data-darkreader-inline-color="">"constructor"</span>,&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">enumerable</span>:&nbsp;<span data-darkreader-inline-color="">false</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">configurable</span>:&nbsp;<span data-darkreader-inline-color="">true</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">writable</span>:&nbsp;<span data-darkreader-inline-color="">true</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">value</span>:&nbsp;SubType<br>&nbsp;&nbsp;})<br>}<br><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">Person</span>(<span></span>)&nbsp;</span>{<br>}<br><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">Student</span>(<span></span>)&nbsp;</span>{<br>}<br><br>inheritPrototype(Student,&nbsp;Person)<br><br><span data-darkreader-inline-color="">console</span>.log(Person.prototype.__proto__)<br><br><span data-darkreader-inline-color="">var</span>&nbsp;stu&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Student()<br><span data-darkreader-inline-color="">console</span>.log(stu&nbsp;<span data-darkreader-inline-color="">instanceof</span>&nbsp;Student)&nbsp;<span data-darkreader-inline-color="">//&nbsp;true</span><br><span data-darkreader-inline-color="">console</span>.log(stu&nbsp;<span data-darkreader-inline-color="">instanceof</span>&nbsp;Person)&nbsp;<span data-darkreader-inline-color="">//&nbsp;true</span><br><span data-darkreader-inline-color="">console</span>.log(stu&nbsp;<span data-darkreader-inline-color="">instanceof</span>&nbsp;<span data-darkreader-inline-color="">Object</span>)&nbsp;<span data-darkreader-inline-color="">//&nbsp;true</span><br></code>
```

isPrototypeOf

-   用于检测某个对象，是否出现在某个实例对象的原型链上
    

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">Person</span>(<span></span>)&nbsp;</span>{<br>}<br><br><span data-darkreader-inline-color="">var</span>&nbsp;p&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Person()<br><br><span data-darkreader-inline-color="">console</span>.log(p&nbsp;<span data-darkreader-inline-color="">instanceof</span>&nbsp;Person)<br><span data-darkreader-inline-color="">console</span>.log(Person.prototype.isPrototypeOf(p))<br><br><span data-darkreader-inline-color="">//&nbsp;</span><br><span data-darkreader-inline-color="">var</span>&nbsp;obj&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">name</span>:&nbsp;<span data-darkreader-inline-color="">"why"</span>,<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">age</span>:&nbsp;<span data-darkreader-inline-color="">18</span><br>}<br><br><span data-darkreader-inline-color="">var</span>&nbsp;info&nbsp;=&nbsp;<span data-darkreader-inline-color="">Object</span>.create(obj)<br><br><span data-darkreader-inline-color="">//&nbsp;console.log(info&nbsp;instanceof&nbsp;obj)</span><br><span data-darkreader-inline-color="">console</span>.log(obj.isPrototypeOf(info))<br></code>
```

### 2.2. 继承关系终级图

详细过程请观看视频，效果更佳！！！

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

继承的终极关系图

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">var</span>&nbsp;obj&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">name</span>:&nbsp;<span data-darkreader-inline-color="">"why"</span><br>}<br><br><span data-darkreader-inline-color="">console</span>.log(obj.__proto__)<br><br><span data-darkreader-inline-color="">//&nbsp;对象里面是有一个__proto__对象:&nbsp;隐式原型对象</span><br><br><span data-darkreader-inline-color="">//&nbsp;Foo是一个函数,&nbsp;那么它会有一个显示原型对象:&nbsp;Foo.prototype</span><br><span data-darkreader-inline-color="">//&nbsp;Foo.prototype来自哪里?</span><br><span data-darkreader-inline-color="">//&nbsp;答案:&nbsp;创建了一个函数,&nbsp;Foo.prototype&nbsp;=&nbsp;{&nbsp;constructor:&nbsp;Foo&nbsp;}</span><br><br><span data-darkreader-inline-color="">//&nbsp;Foo是一个对象,&nbsp;那么它会有一个隐式原型对象:&nbsp;Foo.__proto__</span><br><span data-darkreader-inline-color="">//&nbsp;Foo.__proto__来自哪里?</span><br><span data-darkreader-inline-color="">//&nbsp;答案:&nbsp;new&nbsp;Function()&nbsp;&nbsp;Foo.__proto__&nbsp;=&nbsp;Function.prototype</span><br><span data-darkreader-inline-color="">//&nbsp;Function.prototype&nbsp;=&nbsp;{&nbsp;constructor:&nbsp;Function&nbsp;}</span><br><br><span data-darkreader-inline-color="">//&nbsp;var&nbsp;Foo&nbsp;=&nbsp;new&nbsp;Function()</span><br><span><span data-darkreader-inline-color="">function</span>&nbsp;<span data-darkreader-inline-color="">Foo</span>(<span></span>)&nbsp;</span>{<br><br>}<br><br><span data-darkreader-inline-color="">console</span>.log(Foo.prototype&nbsp;===&nbsp;Foo.__proto__)<br><span data-darkreader-inline-color="">console</span>.log(Foo.prototype.constructor)<br><span data-darkreader-inline-color="">console</span>.log(Foo.__proto__.constructor)<br><br><br><span data-darkreader-inline-color="">var</span>&nbsp;foo1&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;Foo()<br><span data-darkreader-inline-color="">var</span>&nbsp;obj1&nbsp;=&nbsp;<span data-darkreader-inline-color="">new</span>&nbsp;<span data-darkreader-inline-color="">Object</span>()<br><br><span data-darkreader-inline-color="">console</span>.log(<span data-darkreader-inline-color="">Object</span>.getOwnPropertyDescriptors(<span data-darkreader-inline-color="">Function</span>.__proto__))<br></code>
```