如果你问开发人员："对你来说最难的 JS 题目是什么？"，你绝不会听到他说是 ES6 模块。但统计数据更能说明问题！我们统计了我们电报频道中各种主题的问答错误答案数量，发现 ES6 模块是最难的主题之一。

## 测验 #1： 53%的答案正确

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;index.mjs<br>import&nbsp;{&nbsp;default&nbsp;}&nbsp;from&nbsp;<span data-darkreader-inline-color="">'./module.mjs'</span>;<br><br>console.log(default);<br></code>
```

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;module.mjs<br><span data-darkreader-inline-color="">export</span>&nbsp;default&nbsp;<span data-darkreader-inline-color="">'bar'</span>;<br></code>
```

首先，让我们记住各种导入和导出语法：

![Image](https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy56JPTckcB1BqRKIEXkMTGytvaz7egUDTELw3rOPfC3E638e1O1ugpVPSxHfrPtgXsNkk6diaomHn5w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![Image](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

如果检查表中的 Import 语法，就会发现没有与我们的代码相匹配的语法：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">import&nbsp;{&nbsp;default&nbsp;}&nbsp;from&nbsp;‘./module.mjs’;<br></code>
```

因为禁止使用这种语法。测验代码会出现以下错误：

> SyntaxError: Unexpected reserved word

在 `import { default } from ‘./module.mjs’;` 行中， `default` 是 `export` 的名称，也是该作用域中的变量名称，这是被禁止的，因为 `default` 是一个保留字。解决方法很简单：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">import&nbsp;{&nbsp;default&nbsp;as&nbsp;foo&nbsp;}&nbsp;from&nbsp;‘./module.mjs’;<br></code>
```

现在， `default` 是导出的名称， `foo` 是变量的名称。换句话说，如果你想在默认导出中使用命名导入语法，就必须重命名它。就是这样，非常简单！

## 测验 #2：35% 的正确答案

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;index.js<br>console.log(<span data-darkreader-inline-color="">'index.js'</span>);<br><br>import&nbsp;{&nbsp;sum&nbsp;}&nbsp;from&nbsp;<span data-darkreader-inline-color="">'./helper.js'</span>;<br><br>console.log(sum(1,&nbsp;2));<br></code>
```

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;helper.js<br><br>console.log(<span data-darkreader-inline-color="">'helper.js'</span>);<br><span data-darkreader-inline-color="">export</span>&nbsp;const&nbsp;sum&nbsp;=&nbsp;(x,&nbsp;y)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;y;<br></code>
```

没有多少开发人员知道的一个重要的细微差别是，导入是被提升的。也就是说，在引擎解析代码时，导入就会被加载。所有依赖项都将在代码运行前加载。

因此，我们将按照以下顺序查看日志：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">helper.js,&nbsp;index.js,&nbsp;3<br></code>
```

如果希望在导入声明之前执行某些代码，可考虑将其移至单独的文件中：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;new&nbsp;index.js<br><br>import&nbsp;<span data-darkreader-inline-color="">'./logs.js'</span>;<br>import&nbsp;{&nbsp;sum&nbsp;}&nbsp;from&nbsp;<span data-darkreader-inline-color="">'./helper.js'</span>;<br><br>console.log(sum(1,&nbsp;2));<br></code>
```

**logs.js**

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">console.log(<span data-darkreader-inline-color="">'index.js'</span>);<br></code>
```

现在我们有了预期的输出结果：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">index.js,&nbsp;helper.js,&nbsp;3<br></code>
```

## 测验 #3：42% 的正确答案

**index.mjs**

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;index.mjs<br>import&nbsp;<span data-darkreader-inline-color="">'./module.mjs'</span>;<br>import&nbsp;{&nbsp;num&nbsp;}&nbsp;from&nbsp;<span data-darkreader-inline-color="">'./counter.mjs'</span>;<br><br>console.log(<span data-darkreader-inline-color="">'index&nbsp;num&nbsp;='</span>,&nbsp;num);<br></code>
```

**module.mjs**

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;module.mjs<br>import&nbsp;{&nbsp;num&nbsp;}&nbsp;from&nbsp;<span data-darkreader-inline-color="">'./counter.mjs'</span>;<br><br>console.log(<span data-darkreader-inline-color="">'module&nbsp;num&nbsp;='</span>,&nbsp;num);<br></code>
```

**counter.mjs**

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><br>//&nbsp;counter.mjs<br><span data-darkreader-inline-color="">if</span>&nbsp;(!globalThis.num)&nbsp;{<br>&nbsp;&nbsp;globalThis.num&nbsp;=&nbsp;0;<br>}<br><br><span data-darkreader-inline-color="">export</span>&nbsp;const&nbsp;num&nbsp;=&nbsp;++globalThis.num;<br></code>
```

**Modules are singletons. 模块是单例。**

无论从同一位置或不同位置导入模块多少次，模块都只会被执行和加载一次。换句话说，模块实例只有一个。

## 测验 #4：34% 的正确答案

**index.mjs**

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;index.mjs<br>import&nbsp;<span data-darkreader-inline-color="">'./module.mjs?param=5;'</span><br></code>
```

**module.mjs**

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;module.mjs<br>console.log(import.meta.url);<br></code>
```

这个问题如果没有对ES6有比较深的理解，就不太好回答出来。

根据 MDN：

> `import.meta` 对象为 JavaScript 模块提供特定于上下文的元数据。它包含有关模块的信息。

> 它返回一个带有 url 属性的对象，url 属性表示模块的基本 URL。对于外部脚本，url 将是获取脚本的 URL；对于内嵌脚本，url 将是包含脚本的文档的基本 URL。

请注意，这将包括查询参数和/或哈希值（即，跟在 "?" 或 "#" 之后的部分）。

## 测验 #5：45% 的正确答案

**index.js**

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">import&nbsp;myCounter&nbsp;from&nbsp;<span data-darkreader-inline-color="">'./counter'</span>;<br><br>myCounter&nbsp;+=&nbsp;1;<br><br>console.log(myCounter);<br></code>
```

**counter.js**

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;counter.js<br><span data-darkreader-inline-color="">let</span>&nbsp;counter&nbsp;=&nbsp;5;<br><span data-darkreader-inline-color="">export</span>&nbsp;default&nbsp;counter;<br></code>
```

另一个大多数开发者容易忽视的非常重要的点是，在导入模块的作用域中，导入的变量表现得像常量。

为了使代码正常工作，我们可以导出一个对象，例如，并更改其属性。

## 测验 #6：11%的正确答案

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;index.mjs<br>import&nbsp;foo&nbsp;from&nbsp;<span data-darkreader-inline-color="">'./module.mjs'</span>;<br><br>console.log(typeof&nbsp;foo);<br></code>
```

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><br>//&nbsp;module.mjs<br>foo&nbsp;=&nbsp;25;<br><br><span data-darkreader-inline-color="">export</span>&nbsp;default&nbsp;<span data-darkreader-inline-color="">function</span>&nbsp;<span><span data-darkreader-inline-color="">foo</span></span>()&nbsp;{}<br></code>
```

首先，这

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">export</span>&nbsp;default&nbsp;<span data-darkreader-inline-color="">function</span>&nbsp;<span><span data-darkreader-inline-color="">foo</span></span>()&nbsp;{}<br></code>
```

等于

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">function</span>&nbsp;<span><span data-darkreader-inline-color="">foo</span></span>()&nbsp;{}<br><span data-darkreader-inline-color="">export</span>&nbsp;{&nbsp;foo&nbsp;as&nbsp;default&nbsp;}<br></code>
```

这也等于

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">function</span>&nbsp;<span><span data-darkreader-inline-color="">foo</span></span>()&nbsp;{}<br><span data-darkreader-inline-color="">export</span>&nbsp;default&nbsp;foo<br></code>
```

现在是时候回想起函数是如何被提升的，以及变量的初始化总是在函数/变量声明之后进行。

引擎处理完模块代码后，看起来是这样的：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">function</span>&nbsp;<span><span data-darkreader-inline-color="">foo</span></span>()&nbsp;{}<br><br>foo&nbsp;=&nbsp;25;<br><br><span data-darkreader-inline-color="">export</span>&nbsp;{&nbsp;foo&nbsp;as&nbsp;default&nbsp;}<br></code>
```

因此，测验结果就是 `number` 。

## 测验 #7：17%的正确答案

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;index.mjs<br>import&nbsp;defaultFoo,&nbsp;{&nbsp;foo&nbsp;}&nbsp;from&nbsp;<span data-darkreader-inline-color="">'./module.mjs'</span>;<br><br>setTimeout(()&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;console.log(foo);<br>&nbsp;&nbsp;console.log(defaultFoo);<br>},&nbsp;2000);<br></code>
```

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;module.mjs<br><br><span data-darkreader-inline-color="">let</span>&nbsp;foo&nbsp;=&nbsp;<span data-darkreader-inline-color="">'bar'</span>;<br><br><span data-darkreader-inline-color="">export</span>&nbsp;{&nbsp;foo&nbsp;};<br><span data-darkreader-inline-color="">export</span>&nbsp;default&nbsp;foo;<br><br>setTimeout(()&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;foo&nbsp;=&nbsp;<span data-darkreader-inline-color="">'baz'</span>;<br>},&nbsp;1000);<br></code>
```

在大多数情况下，导入的数据是实时的。也就是说，如果导出的值发生了变化，这种变化会反映在导入的变量上。

但默认导出并非如此：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">export</span>&nbsp;default&nbsp;foo;<br></code>
```

使用这种语法时，导出的不是变量，而是变量值。可以像这样导出默认值，而无需使用变量：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">export</span>&nbsp;default&nbsp;‘hello’;<br><span data-darkreader-inline-color="">export</span>&nbsp;default&nbsp;42;<br></code>
```

如果查看测验 #1 中使用导出语法的表格，就会发现 `export default function () {}` 与 `export default foo ( Export of values )` 所处的列 ( Default export ) 不同。

这是因为它们的行为方式不同，函数仍然作为活引用传递：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">&nbsp;&nbsp;//&nbsp;module.mjs<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">export</span>&nbsp;{&nbsp;foo&nbsp;};<br><br>&nbsp;&nbsp;<span data-darkreader-inline-color="">export</span>&nbsp;default&nbsp;<span data-darkreader-inline-color="">function</span>&nbsp;<span><span data-darkreader-inline-color="">foo</span></span>()&nbsp;{};<br><br>&nbsp;&nbsp;setTimeout(()&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;foo&nbsp;=&nbsp;<span data-darkreader-inline-color="">'baz'</span>;<br>&nbsp;&nbsp;},&nbsp;1000);<br></code>
```

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">&nbsp;&nbsp;//&nbsp;index.mjs<br>&nbsp;&nbsp;import&nbsp;defaultFoo,&nbsp;{&nbsp;foo&nbsp;}&nbsp;from&nbsp;<span data-darkreader-inline-color="">'./module.mjs'</span>;<br><br>&nbsp;&nbsp;setTimeout(()&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(foo);&nbsp;//&nbsp;baz<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(defaultFoo);&nbsp;//baz<br>&nbsp;&nbsp;},&nbsp;2000);<br></code>
```

`export { foo as default };` 位于 Named Export 列，与这两列都不同。但对我们来说，唯一重要的是它不在 Export of values 列中。因此，这意味着当以这种方式导出数据时，它将与导入值进行实时绑定。

## 测验 #8： 40% 的正确答案

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;index.mjs<br>import&nbsp;{&nbsp;shouldLoad&nbsp;}&nbsp;from&nbsp;<span data-darkreader-inline-color="">'./module1.mjs'</span>;<br><br><span data-darkreader-inline-color="">let</span>&nbsp;num&nbsp;=&nbsp;0;<br><br><span data-darkreader-inline-color="">if</span>&nbsp;(shouldLoad)&nbsp;{<br>&nbsp;&nbsp;import&nbsp;{&nbsp;num&nbsp;}&nbsp;from&nbsp;<span data-darkreader-inline-color="">'./module2.mjs'</span>;<br>}<br><br>console.log(num);<br></code>
```

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;module1.mjs<br><span data-darkreader-inline-color="">export</span>&nbsp;const&nbsp;shouldLoad&nbsp;=&nbsp;<span data-darkreader-inline-color="">true</span>;<br></code>
```

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//module2.mjs<br><span data-darkreader-inline-color="">export</span>&nbsp;const&nbsp;num&nbsp;=&nbsp;1;<br></code>
```

`import { num } from ‘./module2.mjs’;` 行将会出错，因为导入结构必须位于脚本的顶层：

> SyntaxError: Unexpected token ‘{‘

这是一个重要的限制，加上在文件路径中使用变量的限制，使得 ES6 模块成为静态模块。这意味着，与 Node.js 中使用的 Common.js 模块不同，不必执行代码就能找出模块之间的所有依赖关系。

在这个使用 `Common.js` 模块的示例中，要确定将加载 `a` 或 `b` 模块，需要运行以下代码：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">let</span>&nbsp;result;<br><span data-darkreader-inline-color="">if</span>&nbsp;(foo())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;require(<span data-darkreader-inline-color="">'a'</span>);<br>}&nbsp;<span data-darkreader-inline-color="">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;require(<span data-darkreader-inline-color="">'b'</span>);<br>}<br></code>
```

模块的静态特性有很多好处。以下是其中一些：

1.  总是知道导入数据的确切结构。这有助于在执行代码前发现错别字。
    
2.  异步加载。这是因为模块是静态的，可以在执行模块主体之前加载导入。
    
3.  支持循环依赖关系。我们将在下一次测验中详细探讨这种可能性。
    
4.  高效捆绑。在此不多赘述，您可以在本文中自行了解 Rollup 捆绑程序如何有效地构建 ES6 模块。
    

## 测验 #9： 3% 的正确答案

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;index.mjs<br>import&nbsp;{&nbsp;double,&nbsp;square&nbsp;}&nbsp;from&nbsp;<span data-darkreader-inline-color="">'./module.mjs'</span>;<br><br><span data-darkreader-inline-color="">export</span>&nbsp;<span data-darkreader-inline-color="">function</span>&nbsp;calculate(value)&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;value&nbsp;%&nbsp;2&nbsp;?&nbsp;square(value)&nbsp;:&nbsp;double(value);<br>}<br></code>
```

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><br>//&nbsp;module.mjs<br>import&nbsp;{&nbsp;calculate&nbsp;}&nbsp;from&nbsp;<span data-darkreader-inline-color="">'./index.mjs'</span>;<br><br><span data-darkreader-inline-color="">export</span>&nbsp;<span data-darkreader-inline-color="">function</span>&nbsp;double(num)&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;num&nbsp;*&nbsp;2;<br>}<br><br><span data-darkreader-inline-color="">export</span>&nbsp;<span data-darkreader-inline-color="">function</span>&nbsp;square(num)&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;num&nbsp;*&nbsp;num;<br>}<br><br>console.log(calculate(3));<br></code>
```

在上面的代码中，我们可以看到循环依赖关系： `index.mjs` 从 `module.mjs` 导入 `double` 和 `square` 函数，而 `module.mjs` 从 `index.mjs` 导入 `calculation` 函数。

这段代码之所以能运行，是因为 ES6 模块本质上非常支持循环依赖关系。例如，如果我们将这段代码改写为使用 Common.js 模块，它将不再工作：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;index.js<br>const&nbsp;helpers&nbsp;=&nbsp;require(<span data-darkreader-inline-color="">'./module.js'</span>);<br><br><span data-darkreader-inline-color="">function</span>&nbsp;calculate(value)&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;value&nbsp;%&nbsp;2&nbsp;?&nbsp;helpers.square(value)&nbsp;:&nbsp;helpers.double(value);<br>}<br><br>module.exports&nbsp;=&nbsp;{<br>&nbsp;&nbsp;calculate<br>}<br></code>
```

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><br>//&nbsp;module.js<br>const&nbsp;actions&nbsp;=&nbsp;require(<span data-darkreader-inline-color="">'./index.js'</span>);<br><br><span data-darkreader-inline-color="">function</span>&nbsp;double(num)&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;num&nbsp;*&nbsp;2;<br>}<br><br><span data-darkreader-inline-color="">function</span>&nbsp;square(num)&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;num&nbsp;*&nbsp;num;<br>}<br><br>console.log(actions.calculate(3));&nbsp;//&nbsp;TypeError:&nbsp;actions.calculate&nbsp;is&nbsp;not&nbsp;a&nbsp;<span data-darkreader-inline-color="">function</span><br><br>module.exports&nbsp;=&nbsp;{<br>&nbsp;&nbsp;double,<br>&nbsp;&nbsp;square<br>}<br></code>
```

1.  `index.js` 开始加载
    
2.  加载在第一行中断，以加载 `module.js` ：`const helpers = require(‘./module.js’);`
    
3.  module.js 开始加载
    
4.  在 `console.log(actions.calculate(3));` 行中，由于 actions.calculate 未定义，代码出错。这是因为 Common.js 同步加载模块。 index.js 尚未加载，其导出对象目前为空。
    

如果调用一个带延迟的导入函数， `index.js` 模块将有时间加载，代码也将相应地工作：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;module.js<br>const&nbsp;actions&nbsp;=&nbsp;require(<span data-darkreader-inline-color="">'./index.js'</span>);<br><br><span data-darkreader-inline-color="">function</span>&nbsp;double(num)&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;num&nbsp;*&nbsp;2;<br>}<br><br><span data-darkreader-inline-color="">function</span>&nbsp;square(num)&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;num&nbsp;*&nbsp;num;<br>}<br><br><span data-darkreader-inline-color="">function</span>&nbsp;<span><span data-darkreader-inline-color="">someFunctionToCallLater</span></span>()&nbsp;{<br>&nbsp;&nbsp;console.log(actions.calculate(3));&nbsp;//&nbsp;Works<br>}<br><br>module.exports&nbsp;=&nbsp;{<br>&nbsp;&nbsp;double,<br>&nbsp;&nbsp;square<br>}<br></code>
```

从前面的测验中了解到的，ES6 模块支持循环依赖关系，因为它们是静态的--模块的依赖关系在代码执行之前就已加载。

使上述代码工作的另一个因素是提升。当调用 `calculate` 函数时，我们还没有进入定义该函数的行。

下面是捆绑模块后的代码：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><br><span data-darkreader-inline-color="">function</span>&nbsp;double(num)&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;num&nbsp;*&nbsp;2;<br>}<br><br><span data-darkreader-inline-color="">function</span>&nbsp;square(num)&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;num&nbsp;*&nbsp;num;<br>}<br><br>console.log(calculate(3));<br><br><span data-darkreader-inline-color="">function</span>&nbsp;calculate(value)&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;value&nbsp;%&nbsp;2&nbsp;?&nbsp;square(value)&nbsp;:&nbsp;double(value);<br>}<br></code>
```

如果没有变量提升，它将无法工作。

如果我们将计算声明函数改为函数表达式：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">export</span>&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;calculate&nbsp;=&nbsp;<span data-darkreader-inline-color="">function</span>(value)&nbsp;{<br>&nbsp;&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;value&nbsp;%&nbsp;2&nbsp;?&nbsp;square(value)&nbsp;:&nbsp;double(value);<br>}<br></code>
```

会出现以下错误:

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">ReferenceError:&nbsp;Cannot&nbsp;access&nbsp;‘calculate’&nbsp;before&nbsp;initialization<br></code>
```

## 测验 #10: 31%的正确答案

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;index.mjs<br>import&nbsp;{&nbsp;num&nbsp;}&nbsp;from&nbsp;<span data-darkreader-inline-color="">'./module.mjs'</span>;<br><br>console.log(num);<br></code>
```

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">export</span>&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;num&nbsp;=&nbsp;0;<br><br>num&nbsp;=&nbsp;await&nbsp;new&nbsp;Promise((resolve)&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;setTimeout(()&nbsp;=&gt;&nbsp;resolve(1),&nbsp;1000);<br>});<br></code>
```

顶层 `await` 是一个非常有用的特性，许多开发者都不了解，也许是因为它是在最近的 ECMAScript 2022 中才引入的。啊，真不错！

> 顶层 await 使模块能够像大型异步函数一样运作：通过顶层 await，ECMAScript 模块（ESM）可以等待资源，导致导入它们的其他模块在开始评估其主体之前必须等待。

模块的标准行为是，在加载模块导入的所有模块并执行其代码之前，模块中的代码不会被执行（参见测验 #2）。事实上，随着顶级等待的出现，一切都没有改变。模块中的代码不会被执行，直到所有导入模块中的代码都被执行，只是现在这包括等待模块中所有等待的承诺被解决。

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;index.js<br>console.log(<span data-darkreader-inline-color="">'index.js'</span>);<br><br>import&nbsp;{&nbsp;num&nbsp;}&nbsp;from&nbsp;<span data-darkreader-inline-color="">'./module.js'</span>;<br><br>console.log(<span data-darkreader-inline-color="">'num&nbsp;=&nbsp;'</span>,&nbsp;num);<br></code>
```

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;module.js<br><span data-darkreader-inline-color="">export</span>&nbsp;<span data-darkreader-inline-color="">let</span>&nbsp;num&nbsp;=&nbsp;5;<br><br>console.log(<span data-darkreader-inline-color="">'module.js'</span>);<br><br>await&nbsp;new&nbsp;Promise((resolve)&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;setTimeout(()&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(<span data-darkreader-inline-color="">'module.js:&nbsp;promise&nbsp;1'</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;num&nbsp;=&nbsp;10;<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve();<br>&nbsp;&nbsp;},&nbsp;1000);<br>});<br><br>await&nbsp;new&nbsp;Promise((resolve)&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;setTimeout(()&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(<span data-darkreader-inline-color="">'module.js:&nbsp;promise&nbsp;2'</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;num&nbsp;=&nbsp;20;<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve();<br>&nbsp;&nbsp;},&nbsp;2000);<br>});<br></code>
```

**输出：**

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">module.js<br>module.js:&nbsp;promise&nbsp;1<br>module.js:&nbsp;promise&nbsp;2<br>index.js<br>num&nbsp;=&nbsp;20<br></code>
```

如果我们删除 `module.js` 中第 5 行和第 13 行的等待，并在文件 index.js 中添加超时，就会像这样：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><br>console.log(<span data-darkreader-inline-color="">'index.js'</span>);<br><br>import&nbsp;{&nbsp;num&nbsp;}&nbsp;from&nbsp;<span data-darkreader-inline-color="">'./module.js'</span>;<br><br>console.log(<span data-darkreader-inline-color="">'num&nbsp;=&nbsp;'</span>,&nbsp;num);<br><br>setTimeout(()&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;console.log(<span data-darkreader-inline-color="">'timeout&nbsp;num&nbsp;=&nbsp;'</span>,&nbsp;num);<br>},&nbsp;1000);<br><br>setTimeout(()&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;console.log(<span data-darkreader-inline-color="">'timeout&nbsp;num&nbsp;=&nbsp;'</span>,&nbsp;num);<br>},&nbsp;2000);<br></code>
```

输出：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">module.js<br>index.js<br>num&nbsp;=&nbsp;5<br>module.js:&nbsp;promise&nbsp;1<br>timeout&nbsp;num&nbsp;=&nbsp;10<br>module.js:&nbsp;promise&nbsp;2<br>timeout&nbsp;num&nbsp;=&nbsp;20<br></code>
```

我们将在今后的测验中再次使用顶级等待功能。

## 测验 #11: 16%的正确答案

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//index.mjs<br><br>import&nbsp;{&nbsp;shouldLoad&nbsp;}&nbsp;from&nbsp;<span data-darkreader-inline-color="">'./module1.mjs'</span>;<br><br><span data-darkreader-inline-color="">let</span>&nbsp;num&nbsp;=&nbsp;0;<br><br><span data-darkreader-inline-color="">if</span>&nbsp;(shouldLoad)&nbsp;{<br>&nbsp;&nbsp;&nbsp;({&nbsp;num&nbsp;}&nbsp;=&nbsp;import(<span data-darkreader-inline-color="">'./module2.mjs'</span>));<br>}<br><br>console.log(num);<br></code>
```

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;module1.mjs<br><br><span data-darkreader-inline-color="">export</span>&nbsp;const&nbsp;shouldLoad&nbsp;=&nbsp;<span data-darkreader-inline-color="">true</span>;<br></code>
```

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//module2.mjs<br><br><span data-darkreader-inline-color="">export</span>&nbsp;const&nbsp;num&nbsp;=&nbsp;1;<br></code>
```

`import()` 调用（通常称为动态导入）是一种类似函数的表达式，它允许异步动态加载 ECMAScript 模块。它允许绕过导入声明的语法限制，有条件或按需加载模块。

该功能在 ES2020 中引入。

`import(module)` 返回一个 promise ，该承诺会履行到一个包含模块所有输出的对象。由于 `import(module)` 返回的是一个 promise，为了修正测验代码，我们必须在导入调用之前添加 await 关键字：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">if</span>&nbsp;(shouldLoad)&nbsp;{<br>&nbsp;&nbsp;&nbsp;({&nbsp;num&nbsp;}&nbsp;=&nbsp;await&nbsp;import(<span data-darkreader-inline-color="">'./module2.mjs'</span>));<br>}<br></code>
```

在这里，我们再次使用顶层 `await`，这让我们想起了这一功能的酷炫之处。

我敢肯定，你的应用程序至少有一次出错崩溃了：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">SyntaxError:&nbsp;await&nbsp;is&nbsp;only&nbsp;valid&nbsp;<span data-darkreader-inline-color="">in</span>&nbsp;async&nbsp;<span data-darkreader-inline-color="">functions</span><br></code>
```

当试图从全局作用域调用异步函数时，经常会出现这种情况。为了解决这个问题，我们必须躲避丑陋的代码：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">(async&nbsp;()&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;await&nbsp;[someAsyncFunc]();<br>})();<br></code>
```

这不仅难看，而且在使用此模式异步加载模块时可能会导致错误。例如

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;module1.mjs<br><span data-darkreader-inline-color="">let</span>&nbsp;num;<br>(async&nbsp;()&nbsp;=&gt;&nbsp;{<br>&nbsp;({&nbsp;num&nbsp;}&nbsp;=&nbsp;await&nbsp;import(‘./module2.mjs’));<br>})();<br><br><span data-darkreader-inline-color="">export</span>&nbsp;{&nbsp;num&nbsp;};<br></code>
```

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><br>//&nbsp;module2.mjs<br><span data-darkreader-inline-color="">export</span>&nbsp;const&nbsp;num&nbsp;=&nbsp;5;<br></code>
```

导入 `module1.mjs` 时， `num` 的结果会是什么 - 来自 `module2` 或 `undefined` 的值？这取决于何时访问变量：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><br>import&nbsp;{&nbsp;num&nbsp;}&nbsp;from&nbsp;<span data-darkreader-inline-color="">'./module1.mjs'</span>;<br><br>console.log(num);&nbsp;//&nbsp;undefined<br>setTimeout(()&nbsp;=&gt;&nbsp;console.log(num),&nbsp;100);&nbsp;//&nbsp;5<br></code>
```

有了顶级 await ，只要您访问从 `module1` 导入的 `num` ，它就永远不会是 `undefined` ：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">let</span>&nbsp;{&nbsp;num&nbsp;}&nbsp;=&nbsp;await&nbsp;import(<span data-darkreader-inline-color="">'./module2.mjs'</span>);<br><br><span data-darkreader-inline-color="">export</span>&nbsp;{&nbsp;num&nbsp;};<br></code>
```

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">import&nbsp;{&nbsp;num&nbsp;}&nbsp;from&nbsp;<span data-darkreader-inline-color="">'./module1.mjs'</span>;<br><br>console.log(num);&nbsp;//&nbsp;5<br></code>
```

## 测验 #12： 21% 的正确答案

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;index.mjs<br><br>const&nbsp;module1&nbsp;=&nbsp;await&nbsp;import(<span data-darkreader-inline-color="">'./module1.mjs'</span>);<br>const&nbsp;module2&nbsp;=&nbsp;await&nbsp;import(<span data-darkreader-inline-color="">'./module2.mjs'</span>);<br><br>console.log(module1,&nbsp;module2);<br><br><span data-darkreader-inline-color="">function</span>&nbsp;multiply(num1,&nbsp;num2)&nbsp;{&nbsp;<span data-darkreader-inline-color="">return</span>&nbsp;num1&nbsp;*&nbsp;num2;&nbsp;}<br><br>console.log(multiply(module1,&nbsp;module2));<br></code>
```

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;module1.mjs<br><span data-darkreader-inline-color="">export</span>&nbsp;default&nbsp;await&nbsp;new&nbsp;Promise((resolve)&nbsp;=&gt;&nbsp;resolve(1));<br></code>
```

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><br>//&nbsp;module2.mjs<br><span data-darkreader-inline-color="">export</span>&nbsp;default&nbsp;await&nbsp;new&nbsp;Promise((resolve)&nbsp;=&gt;&nbsp;resolve(2));<br></code>
```

上述代码会出错：

> TypeError: Cannot convert object to primitive value

同意，一个相当意外的错误措辞。让我们来看看这个错误从何而来。

在这段代码中，我们使用了动态导入，这在前面的示例中已经介绍过。要理解这段代码中的问题，我们需要仔细看看 `import()` 的返回值。

变量 `module1` 和 `module2` 的值与我们的预期不同。 `import()` 返回一个 promise ，该promise  将实现一个与命名空间导入形状相同的对象：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">import&nbsp;*&nbsp;as&nbsp;name&nbsp;from&nbsp;moduleName<br></code>
```

`default` 输出可作为名为 `default` 的键使用。

因此，在变量 `module1` 和 `module2` 中分别有对象 `{ default: 1 }` 和 `{ default: 2 }` ，而不是值 `1` 和 `2` 。

那么，为什么两个对象相乘时会出现如此奇怪的错误，而不是我们习惯的 `NaN` 呢？

这是因为返回的对象具有 `null` 原型。因此，它没有用于将对象转换为基元的 `toString()` 方法。如果这个对象有一个 `Object` 原型，我们就会在控制台中看到 `NaN` 。

要修复测验代码，我们需要做以下更改：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><br>console.log(pow(module1.default,&nbsp;module2.default));<br></code>
```

或

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">const&nbsp;{&nbsp;default:&nbsp;module1&nbsp;}&nbsp;=&nbsp;await&nbsp;import(<span data-darkreader-inline-color="">'./module1.mjs'</span>);<br>const&nbsp;{&nbsp;default:&nbsp;module2&nbsp;}&nbsp;=&nbsp;await&nbsp;import(<span data-darkreader-inline-color="">'./module2.mjs'</span>);<br></code>
```

## 测验 #13：17%的正确答案

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><br>//&nbsp;index.js<br>import&nbsp;*&nbsp;as&nbsp;values&nbsp;from&nbsp;<span data-darkreader-inline-color="">'./intermediate.js'</span>;<br><br>console.log(values.x);<br></code>
```

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;module1.js<br><span data-darkreader-inline-color="">export</span>&nbsp;const&nbsp;x&nbsp;=&nbsp;1;<br></code>
```

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">//&nbsp;module2.js<br><span data-darkreader-inline-color="">export</span>&nbsp;const&nbsp;x&nbsp;=&nbsp;2;<br></code>
```

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><br>//&nbsp;intermediate.js<br><span data-darkreader-inline-color="">export</span>&nbsp;*&nbsp;from&nbsp;<span data-darkreader-inline-color="">'./module1.js'</span>;<br><span data-darkreader-inline-color="">export</span>&nbsp;*&nbsp;from&nbsp;<span data-darkreader-inline-color="">'./module2.js'</span>;<br></code>
```

`export * from ‘module’` 语法会将 "模块"文件中所有已命名的导出内容重新导出为当前文件中已命名的导出内容。如果存在多个同名导出，则不会重新导出其中任何一个。

因此，运行这段代码时，我们会在控制台中看到 undefined 。只有 17% 的答题者回答正确，大多数答题者（59%）认为这段代码会出错。事实上，这种无声的失败似乎并不是严格模式的典型表现。(如果您知道这种行为的原因，请在评论中告诉我。

顺便提一下，如果在同样的情况下显式导入 x ，就会出现预期的错误：

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">import&nbsp;{&nbsp;x&nbsp;}&nbsp;from&nbsp;‘./intermediate.js’;<br></code>
```

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">SyntaxError:&nbsp;The&nbsp;requested&nbsp;module&nbsp;‘./intermediate.js’&nbsp;contains&nbsp;conflicting&nbsp;star&nbsp;exports&nbsp;<span data-darkreader-inline-color="">for</span>&nbsp;name&nbsp;‘x’<br></code>
```

## 最后

冲