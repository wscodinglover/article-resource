## 前言

周一接到了美团的一面，面试官人很好，基本都是围绕着简历来问，下面就是我重新整理了一下怎么实现Vuex的min简单版本，可以看到Vuex的大致原理。

## vuex的基本使用

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">//index.js</span><br><span>import</span>&nbsp;{&nbsp;createStore&nbsp;}&nbsp;<span>from</span>&nbsp;<span data-darkreader-inline-color="">'./gvuex.js'</span><br><span>const</span>&nbsp;store&nbsp;=&nbsp;createStore({<br>&nbsp;<span data-darkreader-inline-color="">//&nbsp;定义store的状态</span><br>&nbsp;state()&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span>return</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>count</span>:&nbsp;<span data-darkreader-inline-color="">1</span>&nbsp;<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;},<br>&nbsp;<span data-darkreader-inline-color="">//&nbsp;定义获取state状态数据的计算属性getters，以下的值都被认为是state的派生值</span><br>&nbsp;<span>getters</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;double(state)&nbsp;{&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>return</span>&nbsp;state.count&nbsp;*&nbsp;<span data-darkreader-inline-color="">2</span><br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;},<br>&nbsp;<span data-darkreader-inline-color="">//&nbsp;定义修改state状态数据的方法mutations</span><br>&nbsp;<span>mutations</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;add(state)&nbsp;{&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state.count++<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;},<br>&nbsp;<span data-darkreader-inline-color="">//&nbsp;定义异步操作的方法actions</span><br>&nbsp;<span>actions</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;asyncAdd({&nbsp;commit&nbsp;})&nbsp;{&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(<span><span>()</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;commit(<span data-darkreader-inline-color="">'add'</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;<span data-darkreader-inline-color="">1000</span>)<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;}<br>})<br></code>
```

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span data-darkreader-inline-color="">//&nbsp;App.vue</span><br>&lt;script&nbsp;setup&gt;<br><span>import</span>&nbsp;{&nbsp;useStore&nbsp;}&nbsp;<span>from</span>&nbsp;<span data-darkreader-inline-color="">'../store/gvuex'</span><br><span>import</span>&nbsp;{&nbsp;computed&nbsp;}&nbsp;<span>from</span>&nbsp;<span data-darkreader-inline-color="">'vue'</span><br><span>let</span>&nbsp;store&nbsp;=&nbsp;useStore();<br><span>let</span>&nbsp;count&nbsp;=&nbsp;computed(<span><span>()</span>=&gt;</span>{&nbsp;store.state.count&nbsp;})<br><span>let</span>&nbsp;double&nbsp;=&nbsp;computed(<span><span>()</span>=&gt;</span>{&nbsp;store.getters.double&nbsp;})<br><span><span>function</span>&nbsp;<span data-darkreader-inline-color="">add</span>(<span></span>)&nbsp;</span>{<br>&nbsp;store.commit(<span data-darkreader-inline-color="">'add'</span>)<br>}<br><span><span>function</span>&nbsp;<span data-darkreader-inline-color="">asyncAdd</span>(<span></span>)&nbsp;</span>{<br>&nbsp;store.dispatch(<span data-darkreader-inline-color="">'asyncAdd'</span>)<br>}<br>&lt;<span data-darkreader-inline-color="">/script&gt;<br>&lt;template&gt;<br>&lt;div&nbsp;class=""&gt;<br>&nbsp;{{&nbsp;count&nbsp;}}&nbsp;*&nbsp;2&nbsp;=&nbsp;{{&nbsp;double&nbsp;}}<br>&nbsp;&lt;button&nbsp;@click="add"&gt;add&lt;/</span>button&gt;<br>&nbsp;<span><span data-darkreader-inline-color="">&lt;<span>button</span>&nbsp;@<span data-darkreader-inline-color="">click</span>=<span data-darkreader-inline-color="">"asyncAdd"</span>&gt;</span>async&nbsp;add<span data-darkreader-inline-color="">&lt;/<span>button</span>&gt;</span></span><br>&lt;<span data-darkreader-inline-color="">/div&gt;<br>&lt;/</span>template&gt;<br><span><span data-darkreader-inline-color="">&lt;<span>style</span>&nbsp;<span data-darkreader-inline-color="">scoped</span>&gt;</span><br><span data-darkreader-inline-color="">&lt;/<span>style</span>&gt;</span></span><br></code>
```

知道了vuex的用法，你会不会发出以下疑问：

1.  为什么要`store.commit('add')`才能触发事件执行呢？ 可不可以进行直接调用`mutation`函数进行操作呢？
    
2.  为什么不可以直接对`state`存储的状态进行修改，只能通过调用`mutation`函数的方式修改呢？
    
3.  为什么存在异步调用的函数需要`store.dispatch('asyncAdd')`函数才能完成呢？可以直接调用`store.commit('asyncAdd')`嘛？如果不可以，为什么呢？
    
4.  `createStore()`和`useStore()`到底发生了什么？
    

那么下面就来一一解密吧。

## vue里注册全局组件

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span>import</span>&nbsp;{&nbsp;createApp&nbsp;}&nbsp;<span>from</span>&nbsp;<span data-darkreader-inline-color="">'vue'</span><br><span>import</span>&nbsp;store&nbsp;<span>from</span>&nbsp;<span data-darkreader-inline-color="">'./store'</span><br><span>import</span>&nbsp;App&nbsp;<span>from</span>&nbsp;<span data-darkreader-inline-color="">'./App.vue'</span><br><span>const</span>&nbsp;app&nbsp;=&nbsp;createApp(App)<br>app<br>&nbsp;.use(store)<br>&nbsp;.mount(<span data-darkreader-inline-color="">'#app'</span>)<br></code>
```

`app.use()` 用来安装插件，接受一个参数，通常是插件对象，该对象必须暴露一个`install`方法，调用`app.use()`时，会自动执行`install()`方法。

## 解析Store类里的流程

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor=""><span>import</span>&nbsp;{&nbsp;reactive,&nbsp;inject&nbsp;}&nbsp;<span>from</span>&nbsp;<span data-darkreader-inline-color="">'vue'</span><br><span data-darkreader-inline-color="">//&nbsp;定义了一个全局的&nbsp;key，用于在&nbsp;Vue&nbsp;组件中通过&nbsp;inject&nbsp;API&nbsp;访问&nbsp;store&nbsp;对象</span><br><span>const</span>&nbsp;STORE_KEY&nbsp;=&nbsp;<span data-darkreader-inline-color="">'__store__'</span><br><span data-darkreader-inline-color="">//&nbsp;用于获取当前组件的&nbsp;store&nbsp;对象</span><br><span><span>function</span>&nbsp;<span data-darkreader-inline-color="">useStore</span>(<span></span>)&nbsp;</span>{<br>&nbsp;<span>return</span>&nbsp;inject(STORE_KEY)<br>}<br><span data-darkreader-inline-color="">//&nbsp;Store&nbsp;类，用于管理应用程序状态</span><br><span><span>class</span>&nbsp;<span data-darkreader-inline-color="">Store</span>&nbsp;</span>{<br>&nbsp;<span data-darkreader-inline-color="">//&nbsp;构造函数，接收一个包含&nbsp;state、mutations、actions&nbsp;和&nbsp;getters&nbsp;函数的对象&nbsp;options，然后将它们保存到实例属性中</span><br>&nbsp;<span>constructor</span>(options)&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span>this</span>.$options&nbsp;=&nbsp;options;<br>&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;使用&nbsp;Vue.js&nbsp;的&nbsp;reactive&nbsp;API&nbsp;将&nbsp;state&nbsp;数据转换为响应式对象，并保存到实例属性&nbsp;_state&nbsp;中&nbsp;</span><br>&nbsp;&nbsp;&nbsp;<span>this</span>._state&nbsp;=&nbsp;reactive({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>data</span>:&nbsp;options.state()<br>&nbsp;&nbsp;&nbsp;})<br>&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;将&nbsp;mutations&nbsp;和&nbsp;actions&nbsp;函数保存到实例属性中</span><br>&nbsp;&nbsp;&nbsp;<span>this</span>._mutations&nbsp;=&nbsp;options.mutations<br>&nbsp;&nbsp;&nbsp;<span>this</span>._actions&nbsp;=&nbsp;options.actions;<br>&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;初始化&nbsp;getters&nbsp;属性为空对象</span><br>&nbsp;&nbsp;&nbsp;<span>this</span>.getters&nbsp;=&nbsp;{};<br>&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">//&nbsp;遍历所有的&nbsp;getters&nbsp;函数，将其封装成&nbsp;computed&nbsp;属性并保存到实例属性&nbsp;getters&nbsp;中</span><br>&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">Object</span>.keys(options.getters).forEach(<span><span>name</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>const</span>&nbsp;fn&nbsp;=&nbsp;options.getters(name);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>this</span>.getters[name]&nbsp;=&nbsp;computed(<span><span>()</span>&nbsp;=&gt;</span>&nbsp;fn(<span>this</span>.state));<br>&nbsp;&nbsp;&nbsp;})&nbsp;&nbsp;<br>&nbsp;}<br>&nbsp;<span data-darkreader-inline-color="">//&nbsp;用于获取当前状态数据</span><br>&nbsp;<span>get</span>&nbsp;state()&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span>return</span>&nbsp;<span>this</span>._state.data<br>&nbsp;}<br>&nbsp;<span data-darkreader-inline-color="">//&nbsp;获取mutation内定义的函数并执行</span><br>&nbsp;commit&nbsp;=&nbsp;<span>(<span>type,&nbsp;payload</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span>const</span>&nbsp;entry&nbsp;=&nbsp;<span>this</span>._mutations[type]<br>&nbsp;&nbsp;&nbsp;entry&nbsp;&amp;&amp;&nbsp;entry(<span>this</span>.state,&nbsp;payload)<br>&nbsp;}<br>&nbsp;<span data-darkreader-inline-color="">//&nbsp;获取actions内定义的函数并返回函数执行结果</span><br>&nbsp;<span data-darkreader-inline-color="">//&nbsp;简略版dispatch</span><br>&nbsp;dispatch&nbsp;=&nbsp;<span>(<span>type,&nbsp;payload</span>)&nbsp;=&gt;</span>&nbsp;{&nbsp;<br>&nbsp;&nbsp;&nbsp;<span>const</span>&nbsp;entry&nbsp;=&nbsp;<span>this</span>._actions[type];<br>&nbsp;&nbsp;&nbsp;<span>return</span>&nbsp;entry&nbsp;&amp;&amp;&nbsp;entry(<span>this</span>,&nbsp;payload)<br>&nbsp;}<br>&nbsp;<span data-darkreader-inline-color="">//&nbsp;将当前&nbsp;store&nbsp;实例注册到&nbsp;Vue.js&nbsp;应用程序中</span><br>&nbsp;install(app)&nbsp;{<br>&nbsp;&nbsp;&nbsp;app.provide(STORE_KEY,&nbsp;<span>this</span>)<br>&nbsp;}<br>}<br><span data-darkreader-inline-color="">//&nbsp;创建一个新的&nbsp;Store&nbsp;实例并返回</span><br><span><span>function</span>&nbsp;<span data-darkreader-inline-color="">createStore</span>(<span>options</span>)&nbsp;</span>{<br>&nbsp;<span>return</span>&nbsp;<span>new</span>&nbsp;Store(options);<br>}<br><span data-darkreader-inline-color="">//&nbsp;导出&nbsp;createStore&nbsp;和&nbsp;useStore&nbsp;函数，用于在&nbsp;Vue.js&nbsp;应用程序中管理状态</span><br><span>export</span>&nbsp;{<br>&nbsp;createStore,<br>&nbsp;useStore<br>}<br></code>
```

是不是很惊讶于vuex的底层实现就短短几十行代码就实现了，嘿嘿那是因为从vue里引入了`reactive`、`inject`和`computed`，并且对很大一部分的源码进行了省略,`dispatch`和`commit`远比这复杂多了,有兴趣去了解reactive的实现可以去看我另一篇文章学VUE源码之手写min版响应式原型 \\- 掘金 \\(juejin.cn\\)<sup data-darkreader-inline-color="">[1]</sup>，下面解答上面抛出的问题吧。

## 解答

问题一：为什么要`store.commit('add')`才能触发事件执行呢？ 可不可以进行直接调用`mutation`函数进行操作呢？

**解答：store类里根本没有mutation方法，只能通过调用commit方法来执行mutation里的函数列表。**

问题二：为什么不可以直接对`state`存储的状态进行修改，只能通过调用函数的方式修改呢？

**解答：Vuex 通过强制限制对 store 的修改方式来确保状态的可追踪性。只有通过 mutation 函数才能修改 store 中的状态，这样可以轻松地跟踪状态的变化，也可以避免无意中从不同的组件中直接修改 store 导致的代码难以维护和调试的问题。**

问题三：为什么存在异步调用的函数需要`store.dispatch('asyncAdd')`函数才能完成呢？可以直接调用`store.commit('asyncAdd')`嘛？如果不可以，为什么呢？

**解答：实际上dispatch方法和commit方法远不止这么简单，下面先贴出部分vuex的关于这两个方法的源码部分**

```
<span data-darkreader-inline-bgcolor=""></span><code data-darkreader-inline-color="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">Store.prototype.dispatch&nbsp;=&nbsp;<span><span>function</span>&nbsp;<span data-darkreader-inline-color="">dispatch</span>&nbsp;(<span>_type,&nbsp;_payload</span>)&nbsp;</span>{<br>&nbsp;<span>var</span>&nbsp;<span>this</span>$<span data-darkreader-inline-color="">1</span>$<span data-darkreader-inline-color="">1</span>&nbsp;=&nbsp;<span>this</span>;<br>&nbsp;<span data-darkreader-inline-color="">//&nbsp;check&nbsp;object-style&nbsp;dispatch</span><br>&nbsp;<span>var</span>&nbsp;ref&nbsp;=&nbsp;unifyObjectStyle(_type,&nbsp;_payload);<br>&nbsp;<span>var</span>&nbsp;type&nbsp;=&nbsp;ref.type;<br>&nbsp;<span>var</span>&nbsp;payload&nbsp;=&nbsp;ref.payload;<br>&nbsp;<span>var</span>&nbsp;action&nbsp;=&nbsp;{&nbsp;<span>type</span>:&nbsp;type,&nbsp;<span>payload</span>:&nbsp;payload&nbsp;};<br>&nbsp;<span>var</span>&nbsp;entry&nbsp;=&nbsp;<span>this</span>._actions[type];<br>&nbsp;<span>if</span>&nbsp;(!entry)&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span>if</span>&nbsp;((process.env.NODE_ENV&nbsp;!==&nbsp;<span data-darkreader-inline-color="">'production'</span>))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.error((<span data-darkreader-inline-color="">"[vuex]&nbsp;unknown&nbsp;action&nbsp;type:&nbsp;"</span>&nbsp;+&nbsp;type));<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;<span>return</span><br>&nbsp;}<br>&nbsp;<span>try</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span>this</span>._actionSubscribers<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.slice()&nbsp;<span data-darkreader-inline-color="">//&nbsp;shallow&nbsp;copy&nbsp;to&nbsp;prevent&nbsp;iterator&nbsp;invalidation&nbsp;if&nbsp;subscriber&nbsp;synchronously&nbsp;calls&nbsp;unsubscribe</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter(<span><span>function</span>&nbsp;(<span>sub</span>)&nbsp;</span>{&nbsp;<span>return</span>&nbsp;sub.before;&nbsp;})<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.forEach(<span><span>function</span>&nbsp;(<span>sub</span>)&nbsp;</span>{&nbsp;<span>return</span>&nbsp;sub.before(action,&nbsp;<span>this</span>$<span data-darkreader-inline-color="">1</span>$<span data-darkreader-inline-color="">1.</span>state);&nbsp;});<br>&nbsp;}&nbsp;<span>catch</span>&nbsp;(e)&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span>if</span>&nbsp;((process.env.NODE_ENV&nbsp;!==&nbsp;<span data-darkreader-inline-color="">'production'</span>))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.warn(<span data-darkreader-inline-color="">"[vuex]&nbsp;error&nbsp;in&nbsp;before&nbsp;action&nbsp;subscribers:&nbsp;"</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.error(e);<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;}<br>&nbsp;<span>var</span>&nbsp;result&nbsp;=&nbsp;entry.length&nbsp;&gt;&nbsp;<span data-darkreader-inline-color="">1</span><br>&nbsp;&nbsp;&nbsp;?&nbsp;<span data-darkreader-inline-color="">Promise</span>.all(entry.map(<span><span>function</span>&nbsp;(<span>handler</span>)&nbsp;</span>{&nbsp;<span>return</span>&nbsp;handler(payload);&nbsp;}))<br>&nbsp;&nbsp;&nbsp;:&nbsp;entry[<span data-darkreader-inline-color="">0</span>](payload);<br>&nbsp;<span>return</span>&nbsp;<span>new</span>&nbsp;<span data-darkreader-inline-color="">Promise</span>(<span><span>function</span>&nbsp;(<span>resolve,&nbsp;reject</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;result.then(<span><span>function</span>&nbsp;(<span>res</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;<span>try</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span>this</span>$<span data-darkreader-inline-color="">1</span>$<span data-darkreader-inline-color="">1.</span>_actionSubscribers<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter(<span><span>function</span>&nbsp;(<span>sub</span>)&nbsp;</span>{&nbsp;<span>return</span>&nbsp;sub.after;&nbsp;})<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.forEach(<span><span>function</span>&nbsp;(<span>sub</span>)&nbsp;</span>{&nbsp;<span>return</span>&nbsp;sub.after(action,&nbsp;<span>this</span>$<span data-darkreader-inline-color="">1</span>$<span data-darkreader-inline-color="">1.</span>state);&nbsp;});<br>&nbsp;&nbsp;&nbsp;}&nbsp;<span>catch</span>&nbsp;(e)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>if</span>&nbsp;((process.env.NODE_ENV&nbsp;!==&nbsp;<span data-darkreader-inline-color="">'production'</span>))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.warn(<span data-darkreader-inline-color="">"[vuex]&nbsp;error&nbsp;in&nbsp;after&nbsp;action&nbsp;subscribers:&nbsp;"</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.error(e);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;resolve(res);<br>&nbsp;},&nbsp;<span><span>function</span>&nbsp;(<span>error</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;<span>try</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>this</span>$<span data-darkreader-inline-color="">1</span>$<span data-darkreader-inline-color="">1.</span>_actionSubscribers<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter(<span><span>function</span>&nbsp;(<span>sub</span>)&nbsp;</span>{&nbsp;<span>return</span>&nbsp;sub.error;&nbsp;})<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.forEach(<span><span>function</span>&nbsp;(<span>sub</span>)&nbsp;</span>{&nbsp;<span>return</span>&nbsp;sub.error(action,&nbsp;<span>this</span>$<span data-darkreader-inline-color="">1</span>$<span data-darkreader-inline-color="">1.</span>state,&nbsp;error);&nbsp;});<br>&nbsp;&nbsp;&nbsp;}&nbsp;<span>catch</span>&nbsp;(e)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>if</span>&nbsp;((process.env.NODE_ENV&nbsp;!==&nbsp;<span data-darkreader-inline-color="">'production'</span>))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.warn(<span data-darkreader-inline-color="">"[vuex]&nbsp;error&nbsp;in&nbsp;error&nbsp;action&nbsp;subscribers:&nbsp;"</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.error(e);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;reject(error);<br>&nbsp;});<br>&nbsp;})<br>};<br>Store.prototype.commit&nbsp;=&nbsp;<span><span>function</span>&nbsp;<span data-darkreader-inline-color="">commit</span>&nbsp;(<span>_type,&nbsp;_payload,&nbsp;_options</span>)&nbsp;</span>{<br>&nbsp;<span>var</span>&nbsp;<span>this</span>$<span data-darkreader-inline-color="">1</span>$<span data-darkreader-inline-color="">1</span>&nbsp;=&nbsp;<span>this</span>;<br>&nbsp;<span data-darkreader-inline-color="">//&nbsp;check&nbsp;object-style&nbsp;commit</span><br>&nbsp;<span>var</span>&nbsp;ref&nbsp;=&nbsp;unifyObjectStyle(_type,&nbsp;_payload,&nbsp;_options);<br>&nbsp;<span>var</span>&nbsp;type&nbsp;=&nbsp;ref.type;<br>&nbsp;<span>var</span>&nbsp;payload&nbsp;=&nbsp;ref.payload;<br>&nbsp;<span>var</span>&nbsp;options&nbsp;=&nbsp;ref.options;<br>&nbsp;<span>var</span>&nbsp;mutation&nbsp;=&nbsp;{&nbsp;<span>type</span>:&nbsp;type,&nbsp;<span>payload</span>:&nbsp;payload&nbsp;};<br>&nbsp;<span>var</span>&nbsp;entry&nbsp;=&nbsp;<span>this</span>._mutations[type];<br>&nbsp;<span>if</span>&nbsp;(!entry)&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span>if</span>&nbsp;((process.env.NODE_ENV&nbsp;!==&nbsp;<span data-darkreader-inline-color="">'production'</span>))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.error((<span data-darkreader-inline-color="">"[vuex]&nbsp;unknown&nbsp;mutation&nbsp;type:&nbsp;"</span>&nbsp;+&nbsp;type));<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;<span>return</span><br>&nbsp;}<br>&nbsp;<span>this</span>._withCommit(<span><span>function</span>&nbsp;(<span></span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;entry.forEach(<span><span>function</span>&nbsp;<span data-darkreader-inline-color="">commitIterator</span>&nbsp;(<span>handler</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handler(payload);<br>&nbsp;&nbsp;&nbsp;});<br>&nbsp;});<br>&nbsp;<span>this</span>._subscribers<br>&nbsp;&nbsp;&nbsp;.slice()&nbsp;<span data-darkreader-inline-color="">//&nbsp;shallow&nbsp;copy&nbsp;to&nbsp;prevent&nbsp;iterator&nbsp;invalidation&nbsp;if&nbsp;subscriber&nbsp;synchronously&nbsp;calls&nbsp;unsubscribe</span><br>&nbsp;&nbsp;&nbsp;.forEach(<span><span>function</span>&nbsp;(<span>sub</span>)&nbsp;</span>{&nbsp;<span>return</span>&nbsp;sub(mutation,&nbsp;<span>this</span>$<span data-darkreader-inline-color="">1</span>$<span data-darkreader-inline-color="">1.</span>state);&nbsp;});<br>&nbsp;<span>if</span>&nbsp;(<br>&nbsp;(process.env.NODE_ENV&nbsp;!==&nbsp;<span data-darkreader-inline-color="">'production'</span>)&nbsp;&amp;&amp;<br>&nbsp;options&nbsp;&amp;&amp;&nbsp;options.silent<br>&nbsp;)&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">console</span>.warn(<br>&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">"[vuex]&nbsp;mutation&nbsp;type:&nbsp;"</span>&nbsp;+&nbsp;type&nbsp;+&nbsp;<span data-darkreader-inline-color="">".&nbsp;Silent&nbsp;option&nbsp;has&nbsp;been&nbsp;removed.&nbsp;"</span>&nbsp;+<br>&nbsp;&nbsp;&nbsp;<span data-darkreader-inline-color="">'Use&nbsp;the&nbsp;filter&nbsp;functionality&nbsp;in&nbsp;the&nbsp;vue-devtools'</span><br>&nbsp;&nbsp;&nbsp;);<br>&nbsp;}<br>};<br></code>
```

**源码里我们能看到，dispatch方法返回的是一个Promise对象，而commit方法没有返回值，完全进行的是同步代码的操作，虽然返回值可能适用的场景不多，但是这样设计的主要目的还是为了确保状态的可追踪性**

问题四： `createStore()`和`useStore()`到底发生了什么？

**当我们去调用 `createStore()`函数，其构造函数就会接收一个包含 `state`、`mutations`、`actions` 和 `getters` 函数的对象 `options`， 然后将它们保存到实例属性中,此时`state`中的值都会转换为响应式对象，同时遍历所有的`getters`函数，将其封装成`computed`属性并保存到实例属性`getters`中,而在main.js里调用了app.use(), install方法自动执行，将将当前 store 实例注册到 Vue.js 应用程序中，只需要调用`useStore()`就可以拿到全局状态管理的store实例了，可以靠`inject`和`provide`实现全局共享。**

## 总结

通过实现简单的vuex，完成基本的功能，对vuex有了不同的理解，但在vuex的源码方面，上面的demo只是简简单单做了大致的依赖关系整理，还有：不具备模块化功能、没有提供插件功能、没有提供严格模式、没有提供辅助函数和实现单例模式等等的实现。

### 参考资料

\[1\]

https://juejin.cn/post/7222928881215881274

作者：超人不会飛

https://juejin.cn/post/7237479703167483961